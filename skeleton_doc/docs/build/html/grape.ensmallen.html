
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>grape.ensmallen package &#8212; GraPE 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="grape-ensmallen-package">
<h1>grape.ensmallen package<a class="headerlink" href="#grape-ensmallen-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="grape.ensmallen.edge_list_utils.html">grape.ensmallen.edge_list_utils package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.edge_list_utils.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.edge_list_utils.html#module-grape.ensmallen.edge_list_utils.add_numeric_id_to_csv">grape.ensmallen.edge_list_utils.add_numeric_id_to_csv module</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.edge_list_utils.html#module-grape.ensmallen.edge_list_utils.are_there_selfloops_in_edge_list">grape.ensmallen.edge_list_utils.are_there_selfloops_in_edge_list module</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.edge_list_utils.html#module-grape.ensmallen.edge_list_utils.build_optimal_lists_files">grape.ensmallen.edge_list_utils.build_optimal_lists_files module</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.edge_list_utils.html#module-grape.ensmallen.edge_list_utils.convert_directed_edge_list_to_undirected">grape.ensmallen.edge_list_utils.convert_directed_edge_list_to_undirected module</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.edge_list_utils.html#module-grape.ensmallen.edge_list_utils.convert_edge_list_to_numeric">grape.ensmallen.edge_list_utils.convert_edge_list_to_numeric module</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.edge_list_utils.html#module-grape.ensmallen.edge_list_utils.convert_node_list_node_types_to_numeric">grape.ensmallen.edge_list_utils.convert_node_list_node_types_to_numeric module</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.edge_list_utils.html#module-grape.ensmallen.edge_list_utils.convert_undirected_edge_list_to_directed">grape.ensmallen.edge_list_utils.convert_undirected_edge_list_to_directed module</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.edge_list_utils.html#module-grape.ensmallen.edge_list_utils.densify_sparse_numeric_edge_list">grape.ensmallen.edge_list_utils.densify_sparse_numeric_edge_list module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="grape.ensmallen.edge_list_utils.html#safety">Safety</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.edge_list_utils.html#module-grape.ensmallen.edge_list_utils.filter_duplicates_from_edge_list">grape.ensmallen.edge_list_utils.filter_duplicates_from_edge_list module</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.edge_list_utils.html#module-grape.ensmallen.edge_list_utils.get_minmax_node_from_numeric_edge_list">grape.ensmallen.edge_list_utils.get_minmax_node_from_numeric_edge_list module</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.edge_list_utils.html#module-grape.ensmallen.edge_list_utils.get_rows_number">grape.ensmallen.edge_list_utils.get_rows_number module</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.edge_list_utils.html#module-grape.ensmallen.edge_list_utils.get_selfloops_number_from_edge_list">grape.ensmallen.edge_list_utils.get_selfloops_number_from_edge_list module</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.edge_list_utils.html#module-grape.ensmallen.edge_list_utils.is_numeric_edge_list">grape.ensmallen.edge_list_utils.is_numeric_edge_list module</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.edge_list_utils.html#module-grape.ensmallen.edge_list_utils.sort_numeric_edge_list">grape.ensmallen.edge_list_utils.sort_numeric_edge_list module</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.edge_list_utils.html#module-grape.ensmallen.edge_list_utils.sort_numeric_edge_list_inplace">grape.ensmallen.edge_list_utils.sort_numeric_edge_list_inplace module</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.edge_list_utils.html#module-grape.ensmallen.edge_list_utils">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="grape.ensmallen.preprocessing.html">grape.ensmallen.preprocessing package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.preprocessing.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.preprocessing.html#module-grape.ensmallen.preprocessing.cooccurence_matrix">grape.ensmallen.preprocessing.cooccurence_matrix module</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.preprocessing.html#module-grape.ensmallen.preprocessing.okapi_bm25_tfidf_int">grape.ensmallen.preprocessing.okapi_bm25_tfidf_int module</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.preprocessing.html#module-grape.ensmallen.preprocessing.okapi_bm25_tfidf_str">grape.ensmallen.preprocessing.okapi_bm25_tfidf_str module</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.preprocessing.html#module-grape.ensmallen.preprocessing.word2vec">grape.ensmallen.preprocessing.word2vec module</a></li>
<li class="toctree-l2"><a class="reference internal" href="grape.ensmallen.preprocessing.html#module-grape.ensmallen.preprocessing">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="grape-ensmallen-bfs-module">
<h2>grape.ensmallen.bfs module<a class="headerlink" href="#grape-ensmallen-bfs-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="grape-ensmallen-djkstra-module">
<h2>grape.ensmallen.djkstra module<a class="headerlink" href="#grape-ensmallen-djkstra-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="grape-ensmallen-graph-module">
<h2>grape.ensmallen.graph module<a class="headerlink" href="#grape-ensmallen-graph-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-grape.ensmallen">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-grape.ensmallen" title="Permalink to this headline">¶</a></h2>
<p>Module offering fast graph processing and graph datasets.</p>
<dl class="py class">
<dt class="sig sig-object py" id="grape.ensmallen.Graph">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">grape.ensmallen.</span></span><span class="sig-name descname"><span class="pre">Graph</span></span><a class="headerlink" href="#grape.ensmallen.Graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.add_selfloops">
<span class="sig-name descname"><span class="pre">add_selfloops</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.add_selfloops" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns new graph with added in missing self-loops with given edge type and weight.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – If the edge type for the new selfloops is provided but the graph does not have edge types.</p></li>
<li><p><strong>ValueError</strong> – If the edge weight for the new selfloops is provided but the graph does not have edge weights.</p></li>
<li><p><strong>ValueError</strong> – If the edge weight for the new selfloops is NOT provided but the graph does have edge weights.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.approximated_vertex_cover_set">
<span class="sig-name descname"><span class="pre">approximated_vertex_cover_set</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.approximated_vertex_cover_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 2-approximated verted cover set using greedy algorithm.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.are_nodes_remappable">
<span class="sig-name descname"><span class="pre">are_nodes_remappable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.are_nodes_remappable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether nodes are remappable to those of the given graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#grape.ensmallen.Graph" title="grape.ensmallen.Graph"><em>Graph</em></a><em>,</em>) – graph towards remap the nodes to.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.connected_components">
<span class="sig-name descname"><span class="pre">connected_components</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the connected components building in parallel a spanning tree using [bader’s algorithm](<a class="reference external" href="https://www.sciencedirect.com/science/article/abs/pii/S0743731505000882">https://www.sciencedirect.com/science/article/abs/pii/S0743731505000882</a>).</p>
<p><strong>This works only for undirected graphs.</strong></p>
<p>This method is <strong>not thread save and not deterministic</strong> but by design of the algorithm this
shouldn’t matter but if we will encounter non-detemristic bugs here is where we want to look.</p>
<p>The returned quadruple contains:
- Vector of the connected component for each node.
- Number of connected components.
- Minimum connected component size.
- Maximum connected component size.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show a loading bar or not.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the given graph is directed.</p></li>
<li><p><strong>ValueError</strong> – If the system configuration does not allow for the creation of the thread pool.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.connected_holdout">
<span class="sig-name descname"><span class="pre">connected_holdout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_types</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_all_edge_types</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.connected_holdout" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns holdout for training ML algorithms on the graph structure.</p>
<p>The holdouts returned are a tuple of graphs. The first one, which
is the training graph, is garanteed to have the same number of
graph components as the initial graph. The second graph is the graph
meant for testing or validation of the algorithm, and has no garantee
to be connected. It will have at most (1-train_size) edges,
as the bound of connectivity which is required for the training graph
may lead to more edges being left into the training partition.</p>
<p>In the option where a list of edge types has been provided, these
edge types will be those put into the validation set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_size</strong> (<em>float</em><em>,</em>) – Rate target to reserve for training.</p></li>
<li><p><strong>random_state</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The random_state to use for the holdout,</p></li>
<li><p><strong>edge_types</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Optional</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em><em>,</em>) – Edge types to be selected for in the validation set.</p></li>
<li><p><strong>include_all_edge_types</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to include all the edges between two nodes.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show the loading bar.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the edge types have been specified but the graph does not have edge types.</p></li>
<li><p><strong>ValueError</strong> – If the required training size is not a real value between 0 and 1.</p></li>
<li><p><strong>ValueError</strong> – If the current graph does not allow for the creation of a spanning tree for the requested training size.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.contains">
<span class="sig-name descname"><span class="pre">contains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if given graph edges are all contained within current graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#grape.ensmallen.Graph" title="grape.ensmallen.Graph"><em>Graph</em></a><em>,</em>) – The graph to check against.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If a graph is directed and the other is undirected.</p></li>
<li><p><strong>ValueError</strong> – If one of the two graphs has edge weights and the other does not.</p></li>
<li><p><strong>ValueError</strong> – If one of the two graphs has node types and the other does not.</p></li>
<li><p><strong>ValueError</strong> – If one of the two graphs has edge types and the other does not.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.decode_edge">
<span class="sig-name descname"><span class="pre">decode_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.decode_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns source and destination nodes corresponding to given edge ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge</strong> (<em>int</em><em>,</em>) – The edge value to decode.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.disable_all">
<span class="sig-name descname"><span class="pre">disable_all</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.disable_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable all extra perks, reducing memory impact but incresing time requirements</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.drop_disconnected_nodes">
<span class="sig-name descname"><span class="pre">drop_disconnected_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.drop_disconnected_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns new graph without disconnected nodes.</p>
<p>A disconnected node is a node with no connection to any other node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.drop_parallel_edges">
<span class="sig-name descname"><span class="pre">drop_parallel_edges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.drop_parallel_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns new graph without parallel edges</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.drop_selfloops">
<span class="sig-name descname"><span class="pre">drop_selfloops</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.drop_selfloops" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns new graph without selfloops.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.drop_singleton_nodes">
<span class="sig-name descname"><span class="pre">drop_singleton_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.drop_singleton_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns new graph without singleton nodes.</p>
<p>A node is singleton when does not have neither incoming or outgoing edges.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.drop_singleton_nodes_with_selfloops">
<span class="sig-name descname"><span class="pre">drop_singleton_nodes_with_selfloops</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.drop_singleton_nodes_with_selfloops" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns new graph without singleton nodes with selfloops.</p>
<p>A node is singleton with selfloop when does not have neither incoming or outgoing edges.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.drop_unknown_edge_types">
<span class="sig-name descname"><span class="pre">drop_unknown_edge_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.drop_unknown_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns new graph without unknown edge types and relative edges.</p>
<p>Note that this method will remove ALL edges labeled with unknown edge
type!</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.drop_unknown_node_types">
<span class="sig-name descname"><span class="pre">drop_unknown_node_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.drop_unknown_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns new graph without unknown node types and relative nodes.</p>
<p>Note that this method will remove ALL nodes labeled with unknown node
type!</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.enable">
<span class="sig-name descname"><span class="pre">enable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector_sources</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector_destinations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector_cumulative_node_degrees</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.enable" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable extra perks that buys you time as you accept to spend more memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vector_sources</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to cache sources into a vector for faster walks.</p></li>
<li><p><strong>vector_destinations</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to cache destinations into a vector for faster walks.</p></li>
<li><p><strong>vector_cumulative_node_degrees</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to cache cumulative_node_degrees into a vector for faster walks.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.encode_edge">
<span class="sig-name descname"><span class="pre">encode_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.encode_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return edge value corresponding to given node IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> (<em>int</em><em>,</em>) – The source node ID.</p></li>
<li><p><strong>dst</strong> (<em>int</em><em>,</em>) – The destination node ID.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.filter_from_ids">
<span class="sig-name descname"><span class="pre">filter_from_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_ids_to_keep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_ids_to_filter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type_ids_to_keep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type_ids_to_filter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type_id_to_keep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type_id_to_filter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_ids_to_keep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_ids_to_filter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_node_ids_to_keep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_node_ids_to_filter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type_ids_to_keep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type_ids_to_filter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_edge_weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_edge_weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_singleton_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_singleton_nodes_with_selfloop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_selfloops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_parallel_edges</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.filter_from_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <strong>NEW</strong> Graph that does not have the required attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_ids_to_keep</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em><em>,</em>) – List of node IDs to keep during filtering.</p></li>
<li><p><strong>node_ids_to_filter</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em><em>,</em>) – List of node IDs to remove during filtering.</p></li>
<li><p><strong>node_type_ids_to_keep</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Optional</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em><em>]</em><em>]</em><em>,</em>) – List of node type IDs to keep during filtering. The node types must match entirely the given node types vector provided.</p></li>
<li><p><strong>node_type_ids_to_filter</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Optional</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em><em>]</em><em>]</em><em>,</em>) – List of node type IDs to remove during filtering. The node types must match entirely the given node types vector provided.</p></li>
<li><p><strong>node_type_id_to_keep</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Optional</em><em>[</em><em>int</em><em>]</em><em>]</em><em>]</em><em>,</em>) – List of node type IDs to keep during filtering. Any of node types must match with one of the node types given.</p></li>
<li><p><strong>node_type_id_to_filter</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Optional</em><em>[</em><em>int</em><em>]</em><em>]</em><em>]</em><em>,</em>) – List of node type IDs to remove during filtering. Any of node types must match with one of the node types given.</p></li>
<li><p><strong>edge_ids_to_keep</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em><em>,</em>) – List of edge IDs to keep during filtering.</p></li>
<li><p><strong>edge_ids_to_filter</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em><em>,</em>) – List of edge IDs to remove during filtering.</p></li>
<li><p><strong>edge_node_ids_to_keep</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Tuple</em><em>[</em><em>int</em><em>, </em><em>int</em><em>]</em><em>]</em><em>]</em><em>,</em>) – List of tuple of node IDs to keep during filtering.</p></li>
<li><p><strong>edge_node_ids_to_filter</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Tuple</em><em>[</em><em>int</em><em>, </em><em>int</em><em>]</em><em>]</em><em>]</em><em>,</em>) – List of tuple of node IDs to remove during filtering.</p></li>
<li><p><strong>edge_type_ids_to_keep</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Optional</em><em>[</em><em>int</em><em>]</em><em>]</em><em>]</em><em>,</em>) – List of edge type IDs to keep during filtering.</p></li>
<li><p><strong>edge_type_ids_to_filter</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Optional</em><em>[</em><em>int</em><em>]</em><em>]</em><em>]</em><em>,</em>) – List of edge type IDs to remove during filtering.</p></li>
<li><p><strong>min_edge_weight</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – Minimum edge weight. Values lower than this are removed.</p></li>
<li><p><strong>max_edge_weight</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – Maximum edge weight. Values higher than this are removed.</p></li>
<li><p><strong>filter_singleton_nodes</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to filter out singleton nodes.</p></li>
<li><p><strong>filter_singleton_nodes_with_selfloop</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to filter out singleton nodes with selfloops.</p></li>
<li><p><strong>filter_selfloops</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to filter out selfloops.</p></li>
<li><p><strong>filter_parallel_edges</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to filter out parallel edges.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show loading bar while building the graphs.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.filter_from_names">
<span class="sig-name descname"><span class="pre">filter_from_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_names_to_keep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_names_to_filter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type_names_to_keep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type_names_to_filter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type_name_to_keep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type_name_to_filter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_node_names_to_keep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_node_names_to_filter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type_names_to_keep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type_names_to_filter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_edge_weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_edge_weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_singleton_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_singleton_nodes_with_selfloop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_selfloops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_parallel_edges</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.filter_from_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <strong>NEW</strong> Graph that does not have the required attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_names_to_keep</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – List of node names to keep during filtering.</p></li>
<li><p><strong>node_names_to_filter</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – List of node names to remove during filtering.</p></li>
<li><p><strong>node_type_names_to_keep</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Optional</em><em>[</em><em>List</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em><em>]</em><em>,</em>) – List of node type names to keep during filtering. The node types must match entirely the given node types vector provided.</p></li>
<li><p><strong>node_type_names_to_filter</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Optional</em><em>[</em><em>List</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em><em>]</em><em>,</em>) – List of node type names to remove during filtering. The node types must match entirely the given node types vector provided.</p></li>
<li><p><strong>node_type_name_to_keep</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Optional</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em><em>,</em>) – List of node type name to keep during filtering. Any of node types must match with one of the node types given.</p></li>
<li><p><strong>node_type_name_to_filter</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Optional</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em><em>,</em>) – List of node type name to remove during filtering. Any of node types must match with one of the node types given.</p></li>
<li><p><strong>edge_node_names_to_keep</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em><em>]</em><em>,</em>) – List of tuple of node names to keep during filtering.</p></li>
<li><p><strong>edge_node_names_to_filter</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em><em>]</em><em>,</em>) – List of tuple of node names to remove during filtering.</p></li>
<li><p><strong>edge_type_names_to_keep</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Optional</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em><em>,</em>) – List of edge type names to keep during filtering.</p></li>
<li><p><strong>edge_type_names_to_filter</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Optional</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em><em>,</em>) – List of edge type names to remove during filtering.</p></li>
<li><p><strong>min_edge_weight</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – Minimum edge weight. Values lower than this are removed.</p></li>
<li><p><strong>max_edge_weight</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – Maximum edge weight. Values higher than this are removed.</p></li>
<li><p><strong>filter_singleton_nodes</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to filter out singletons.</p></li>
<li><p><strong>filter_singleton_nodes_with_selfloop</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to filter out singleton nodes with selfloops.</p></li>
<li><p><strong>filter_selfloops</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to filter out selfloops.</p></li>
<li><p><strong>filter_parallel_edges</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to filter out parallel edges.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show loading bar while building the graphs.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.from_csv">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">from_csv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_type_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type_list_separator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_types_column_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_types_column</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_types_ids_column_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_types_ids_column</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_types_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numeric_node_type_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimum_node_type_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type_list_header</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type_list_rows_to_skip</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type_list_is_correct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type_list_max_rows_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type_list_comment_symbol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">load_node_type_list_in_parallel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_list_separator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_list_header</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_list_rows_to_skip</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_list_is_correct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_list_max_rows_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_list_comment_symbol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_node_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodes_column_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodes_column</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_types_separator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_list_node_types_column_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_list_node_types_column</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_ids_column</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_ids_column_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodes_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimum_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numeric_node_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_list_numeric_node_type_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_node_types_if_unavailable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">load_node_list_in_parallel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_types_column_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_types_column</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_types_ids_column_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_types_ids_column</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_types_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numeric_edge_type_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimum_edge_type_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type_list_separator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type_list_header</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type_list_rows_to_skip</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type_list_is_correct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type_list_max_rows_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type_list_comment_symbol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">load_edge_type_list_in_parallel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_list_separator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_list_header</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_list_rows_to_skip</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources_column_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources_column</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destinations_column_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destinations_column</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_list_edge_types_column_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_list_edge_types_column</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_edge_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights_column_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights_column</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_ids_column</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_ids_column_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_list_numeric_edge_type_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_list_numeric_node_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_weights_if_unavailable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_edge_types_if_unavailable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_list_is_complete</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_list_may_contain_duplicates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_list_is_sorted</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_list_is_correct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_list_max_rows_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_list_comment_symbol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">load_edge_list_in_parallel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">may_have_singletons</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">may_have_singleton_with_selfloops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.from_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return graph renderized from given CSVs or TSVs-like files.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_type_path</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The path to the file with the unique node type names.</p></li>
<li><p><strong>node_type_list_separator</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The separator to use for the node types file. Note that if this is not provided, one will be automatically detected among the following`: comma, semi-column, tab and space.</p></li>
<li><p><strong>node_types_column_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The number of the column of the node types file from where to load the node types.</p></li>
<li><p><strong>node_types_column</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The name of the column of the node types file from where to load the node types.</p></li>
<li><p><strong>node_types_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The number of the unique node types. This will be used in order to allocate the correct size for the data structure.</p></li>
<li><p><strong>numeric_node_type_ids</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the node type names should be loaded as numeric values, i.e. casted from string to a numeric representation.</p></li>
<li><p><strong>minimum_node_type_id</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The minimum node type ID to be used when using numeric node type IDs.</p></li>
<li><p><strong>node_type_list_header</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the node type file has an header.</p></li>
<li><p><strong>node_type_list_rows_to_skip</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The number of lines to skip in the node types file`: the header is already skipped if it has been specified that the file has an header.</p></li>
<li><p><strong>node_type_list_is_correct</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the node types file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</p></li>
<li><p><strong>node_type_list_max_rows_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximum number of lines to be loaded from the node types file.</p></li>
<li><p><strong>node_type_list_comment_symbol</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The comment symbol to skip lines in the node types file. Lines starting with this symbol will be skipped.</p></li>
<li><p><strong>load_node_type_list_in_parallel</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to load the node type list in parallel. Note that when loading in parallel, the internal order of the node type IDs may result changed across different iterations. We are working to get this to be stable.</p></li>
<li><p><strong>node_path</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The path to the file with the unique node names.</p></li>
<li><p><strong>node_list_separator</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The separator to use for the nodes file. Note that if this is not provided, one will be automatically detected among the following`: comma, semi-column, tab and space.</p></li>
<li><p><strong>node_list_header</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the nodes file has an header.</p></li>
<li><p><strong>node_list_rows_to_skip</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Number of rows to skip in the node list file.</p></li>
<li><p><strong>node_list_is_correct</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the nodes file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</p></li>
<li><p><strong>node_list_max_rows_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximum number of lines to be loaded from the nodes file.</p></li>
<li><p><strong>node_list_comment_symbol</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The comment symbol to skip lines in the nodes file. Lines starting with this symbol will be skipped.</p></li>
<li><p><strong>default_node_type</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node type to be used when the node type for a given node in the node file is None.</p></li>
<li><p><strong>nodes_column_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The number of the column of the node file from where to load the node names.</p></li>
<li><p><strong>nodes_column</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The name of the column of the node file from where to load the node names.</p></li>
<li><p><strong>node_types_separator</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node types separator.</p></li>
<li><p><strong>node_list_node_types_column_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The number of the column of the node file from where to load the node types.</p></li>
<li><p><strong>node_list_node_types_column</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The name of the column of the node file from where to load the node types.</p></li>
<li><p><strong>node_ids_column</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The name of the column of the node file from where to load the node IDs.</p></li>
<li><p><strong>node_ids_column_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The number of the column of the node file from where to load the node IDs</p></li>
<li><p><strong>nodes_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The expected number of nodes. Note that this must be the EXACT number of nodes in the graph.</p></li>
<li><p><strong>minimum_node_id</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The minimum node ID to be used, when loading the node IDs as numerical.</p></li>
<li><p><strong>numeric_node_ids</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to load the numeric node IDs as numeric.</p></li>
<li><p><strong>node_list_numeric_node_type_ids</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to load the node types IDs in the node file to be numeric.</p></li>
<li><p><strong>skip_node_types_if_unavailable</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to skip the node types without raising an error if these are unavailable.</p></li>
<li><p><strong>load_node_list_in_parallel</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to load the node list in parallel. When loading in parallel, without node IDs, the nodes may not be loaded in a deterministic order.</p></li>
<li><p><strong>edge_type_path</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The path to the file with the unique edge type names.</p></li>
<li><p><strong>edge_types_column_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The number of the column of the edge types file from where to load the edge types.</p></li>
<li><p><strong>edge_types_column</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The name of the column of the edge types file from where to load the edge types.</p></li>
<li><p><strong>edge_types_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The number of the unique edge types. This will be used in order to allocate the correct size for the data structure.</p></li>
<li><p><strong>numeric_edge_type_ids</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the edge type names should be loaded as numeric values, i.e. casted from string to a numeric representation.</p></li>
<li><p><strong>minimum_edge_type_id</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The minimum edge type ID to be used when using numeric edge type IDs.</p></li>
<li><p><strong>edge_type_list_separator</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The separator to use for the edge type list. Note that, if None is provided, one will be attempted to be detected automatically between ‘;’, ‘,’, tab or space.</p></li>
<li><p><strong>edge_type_list_header</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the edge type file has an header.</p></li>
<li><p><strong>edge_type_list_rows_to_skip</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Number of rows to skip in the edge type list file.</p></li>
<li><p><strong>edge_type_list_is_correct</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the edge types file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</p></li>
<li><p><strong>edge_type_list_max_rows_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximum number of lines to be loaded from the edge types file.</p></li>
<li><p><strong>edge_type_list_comment_symbol</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The comment symbol to skip lines in the edge types file. Lines starting with this symbol will be skipped.</p></li>
<li><p><strong>load_edge_type_list_in_parallel</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to load the edge type list in parallel. When loading in parallel, without edge type IDs, the edge types may not be loaded in a deterministic order.</p></li>
<li><p><strong>edge_path</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The path to the file with the edge list.</p></li>
<li><p><strong>edge_list_separator</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The separator to use for the edge list. Note that, if None is provided, one will be attempted to be detected automatically between ‘;’, ‘,’, tab or space.</p></li>
<li><p><strong>edge_list_header</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the edges file has an header.</p></li>
<li><p><strong>edge_list_rows_to_skip</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Number of rows to skip in the edge list file.</p></li>
<li><p><strong>sources_column_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The number of the column of the edges file from where to load the source nodes.</p></li>
<li><p><strong>sources_column</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The name of the column of the edges file from where to load the source nodes.</p></li>
<li><p><strong>destinations_column_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The number of the column of the edges file from where to load the destinaton nodes.</p></li>
<li><p><strong>destinations_column</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The name of the column of the edges file from where to load the destinaton nodes.</p></li>
<li><p><strong>edge_list_edge_types_column_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The number of the column of the edges file from where to load the edge types.</p></li>
<li><p><strong>edge_list_edge_types_column</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The name of the column of the edges file from where to load the edge types.</p></li>
<li><p><strong>default_edge_type</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The edge type to be used when the edge type for a given edge in the edge file is None.</p></li>
<li><p><strong>weights_column_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The number of the column of the edges file from where to load the edge weights.</p></li>
<li><p><strong>weights_column</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The name of the column of the edges file from where to load the edge weights.</p></li>
<li><p><strong>default_weight</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – The edge weight to be used when the edge weight for a given edge in the edge file is None.</p></li>
<li><p><strong>edge_ids_column</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The name of the column of the edges file from where to load the edge IDs.</p></li>
<li><p><strong>edge_ids_column_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The number of the column of the edges file from where to load the edge IDs.</p></li>
<li><p><strong>edge_list_numeric_edge_type_ids</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to load the edge type IDs as numeric from the edge list.</p></li>
<li><p><strong>edge_list_numeric_node_ids</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to load the edge node IDs as numeric from the edge list.</p></li>
<li><p><strong>skip_weights_if_unavailable</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to skip the weights without raising an error if these are unavailable.</p></li>
<li><p><strong>skip_edge_types_if_unavailable</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to skip the edge types without raising an error if these are unavailable.</p></li>
<li><p><strong>edge_list_is_complete</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to consider the edge list as complete, i.e. the edges are presented in both directions when loading an undirected graph.</p></li>
<li><p><strong>edge_list_may_contain_duplicates</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the edge list may contain duplicates. If the edge list surely DOES NOT contain duplicates, a validation step may be skipped. By default, it is assumed that the edge list may contain duplicates.</p></li>
<li><p><strong>edge_list_is_sorted</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the edge list is sorted. Note that a sorted edge list has the minimal memory peak, but requires the nodes number and the edges number.</p></li>
<li><p><strong>edge_list_is_correct</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the edges file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</p></li>
<li><p><strong>edge_list_max_rows_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximum number of lines to be loaded from the edges file.</p></li>
<li><p><strong>edge_list_comment_symbol</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The comment symbol to skip lines in the edges file. Lines starting with this symbol will be skipped.</p></li>
<li><p><strong>edges_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The expected number of edges. Note that this must be the EXACT number of edges in the graph.</p></li>
<li><p><strong>load_edge_list_in_parallel</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to load the edge list in parallel. Note that, if the edge IDs indices are not given, it is NOT possible to load a sorted edge list. Similarly, when loading in parallel, without edge IDs, the edges may not be loaded in a deterministic order.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show a loading bar while reading the files. Note that, if parallel loading is enabled, loading bars will not be showed because they are a synchronization bottleneck.</p></li>
<li><p><strong>may_have_singletons</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the graph may be expected to have singleton nodes. If it is said that it surely DOES NOT have any, it will allow for some speedups and lower mempry peaks.</p></li>
<li><p><strong>may_have_singleton_with_selfloops</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the graph may be expected to have singleton nodes with selfloops. If it is said that it surely DOES NOT have any, it will allow for some speedups and lower mempry peaks.</p></li>
<li><p><strong>directed</strong> (<em>bool</em><em>,</em>) – Whether to load the graph as directed or undirected.</p></li>
<li><p><strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The name of the graph to be loaded.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.generate_barbell_graph">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">generate_barbell_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">minimum_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">left_clique_nodes_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_clique_nodes_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chain_nodes_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_selfloops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">left_clique_node_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_clique_node_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chain_node_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">left_clique_edge_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_clique_edge_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chain_edge_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">left_clique_weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_clique_weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chain_weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.generate_barbell_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates new barbell graph with given sizes and types.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>minimum_node_id</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Minimum node ID to start with. May be needed when chaining graphs. By default 0.</p></li>
<li><p><strong>left_clique_nodes_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Number of nodes in the left clique. By default 10.</p></li>
<li><p><strong>right_clique_nodes_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Number of nodes in the right clique. By default equal to the left clique.</p></li>
<li><p><strong>chain_nodes_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Number of nodes in the chain. By default 10.</p></li>
<li><p><strong>include_selfloops</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to include selfloops.</p></li>
<li><p><strong>left_clique_node_type</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node type to use for the left clique. By default ‘left_clique’.</p></li>
<li><p><strong>right_clique_node_type</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node type to use for the right clique. By default ‘right_clique’.</p></li>
<li><p><strong>chain_node_type</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node type to use for the chain. By default ‘chain’.</p></li>
<li><p><strong>left_clique_edge_type</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node type to use for the left clique. By default ‘left_clique’.</p></li>
<li><p><strong>right_clique_edge_type</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node type to use for the right clique. By default ‘right_clique’.</p></li>
<li><p><strong>chain_edge_type</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node type to use for the chain. By default ‘chain’.</p></li>
<li><p><strong>left_clique_weight</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – The weight to use for the edges in the left clique. By default None.</p></li>
<li><p><strong>right_clique_weight</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – The weight to use for the edges in the right clique. By default None.</p></li>
<li><p><strong>chain_weight</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – The weight to use for the edges in the chain. By default None.</p></li>
<li><p><strong>directed</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the graph is to built as directed. By default false.</p></li>
<li><p><strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – Name of the graph. By default ‘Barbell’.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the edge weights are provided only for a subset.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.generate_chain_graph">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">generate_chain_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">minimum_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodes_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_selfloops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.generate_chain_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates new chain graph with given sizes and types.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>minimum_node_id</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Minimum node ID to start with. May be needed when chaining graphs. By default 0.</p></li>
<li><p><strong>nodes_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Number of nodes in the chain. By default 10.</p></li>
<li><p><strong>include_selfloops</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to include selfloops.</p></li>
<li><p><strong>node_type</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node type to use for the chain. By default ‘chain’.</p></li>
<li><p><strong>edge_type</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node type to use for the chain. By default ‘chain’.</p></li>
<li><p><strong>weight</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – The weight to use for the edges in the chain. By default None.</p></li>
<li><p><strong>directed</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the graph is to built as directed. By default false.</p></li>
<li><p><strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – Name of the graph. By default ‘Chain’.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.generate_circle_graph">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">generate_circle_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">minimum_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodes_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_selfloops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.generate_circle_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates new circle graph with given sizes and types.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>minimum_node_id</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Minimum node ID to start with. May be needed when circleing graphs. By default 0.</p></li>
<li><p><strong>nodes_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Number of nodes in the circle. By default 10.</p></li>
<li><p><strong>include_selfloops</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to include selfloops.</p></li>
<li><p><strong>node_type</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node type to use for the circle. By default ‘circle’.</p></li>
<li><p><strong>edge_type</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node type to use for the circle. By default ‘circle’.</p></li>
<li><p><strong>weight</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – The weight to use for the edges in the circle. By default None.</p></li>
<li><p><strong>directed</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the graph is to built as directed. By default false.</p></li>
<li><p><strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – Name of the graph. By default ‘Circle’.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.generate_complete_graph">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">generate_complete_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">minimum_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodes_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_selfloops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.generate_complete_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates new complete graph with given sizes and types.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>minimum_node_id</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Minimum node ID to start with. May be needed when combining graphs. By default 0.</p></li>
<li><p><strong>nodes_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Number of nodes in the chain. By default 10.</p></li>
<li><p><strong>include_selfloops</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to include selfloops.</p></li>
<li><p><strong>node_type</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node type to use. By default ‘complete’.</p></li>
<li><p><strong>edge_type</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node type to use. By default ‘complete’.</p></li>
<li><p><strong>weight</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – The weight to use for the edges. By default None.</p></li>
<li><p><strong>directed</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the graph is to built as directed. By default false.</p></li>
<li><p><strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – Name of the graph. By default ‘Complete’.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.generate_new_edges_from_node_features">
<span class="sig-name descname"><span class="pre">generate_new_edges_from_node_features</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">features</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbours_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_degree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.generate_new_edges_from_node_features" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns graph with edges added extracted from given node_features.</p>
<p>This operation might distrupt the graph topology.
Proceed with caution!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>features</strong> (<em>List</em><em>[</em><em>List</em><em>[</em><em>float</em><em>]</em><em>]</em><em>,</em>) – node_features to use to identify the new neighbours.</p></li>
<li><p><strong>neighbours_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Number of neighbours to add.</p></li>
<li><p><strong>max_degree</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximum degree a node can have its neighbours augmented. By default 0, that is, only singletons are augmented.</p></li>
<li><p><strong>distance_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – Name of distance to use. Can either be L2 or COSINE. By default COSINE.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show loading bars.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have nodes.</p></li>
<li><p><strong>ValueError</strong> – If the given node_features are not provided exactly for each node.</p></li>
<li><p><strong>ValueError</strong> – If the node_features do not have a consistent shape.</p></li>
<li><p><strong>ValueError</strong> – If the provided number of neighbours is zero.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.generate_random_connected_graph">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">generate_random_connected_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimum_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimum_node_sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximum_node_sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodes_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_selfloops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.generate_random_connected_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates new random connected graph with given sizes and types.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>random_state</strong> (<em>int</em><em>,</em>) – The random state to use to reproduce the sampling.</p></li>
<li><p><strong>minimum_node_id</strong> (<em>int</em><em>,</em>) – The minimum node ID for the connected graph.</p></li>
<li><p><strong>minimum_node_sampling</strong> (<em>int</em><em>,</em>) – The minimum amount of nodes to sample per node.</p></li>
<li><p><strong>maximum_node_sampling</strong> (<em>int</em><em>,</em>) – The maximum amount of nodes to sample per node.</p></li>
<li><p><strong>nodes_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Number of nodes in the chain. By default 10.</p></li>
<li><p><strong>include_selfloops</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to include selfloops.</p></li>
<li><p><strong>node_type</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node type to use for the chain. By default ‘chain’.</p></li>
<li><p><strong>edge_type</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node type to use for the chain. By default ‘chain’.</p></li>
<li><p><strong>weight</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – The weight to use for the edges in the chain. By default None.</p></li>
<li><p><strong>directed</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the graph is to built as directed. By default false.</p></li>
<li><p><strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – Name of the graph. By default ‘Chain’.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.generate_random_spanning_tree">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">generate_random_spanning_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimum_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodes_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_selfloops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.generate_random_spanning_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates new random connected graph with given sizes and types.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>random_state</strong> (<em>int</em><em>,</em>) – The random state to use to reproduce the sampling.</p></li>
<li><p><strong>minimum_node_id</strong> (<em>int</em><em>,</em>) – The minimum node ID for the connected graph.</p></li>
<li><p><strong>minimum_node_sampling</strong> (<em>int</em><em>,</em>) – The minimum amount of nodes to sample per node.</p></li>
<li><p><strong>maximum_node_sampling</strong> (<em>int</em><em>,</em>) – The maximum amount of nodes to sample per node.</p></li>
<li><p><strong>nodes_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Number of nodes in the chain. By default 10.</p></li>
<li><p><strong>include_selfloops</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to include selfloops.</p></li>
<li><p><strong>node_type</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node type to use for the chain. By default ‘chain’.</p></li>
<li><p><strong>edge_type</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node type to use for the chain. By default ‘chain’.</p></li>
<li><p><strong>weight</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – The weight to use for the edges in the chain. By default None.</p></li>
<li><p><strong>directed</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether the graph is to built as directed. By default false.</p></li>
<li><p><strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – Name of the graph. By default ‘Chain’.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_adamic_adar_index_from_node_ids">
<span class="sig-name descname"><span class="pre">get_adamic_adar_index_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination_node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_adamic_adar_index_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Adamic/Adar Index for the given pair of nodes from the given node IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the first node.</p></li>
<li><p><strong>destination_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the second node.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If either of the node IDs are higher than the number of nodes in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_adamic_adar_index_from_node_names">
<span class="sig-name descname"><span class="pre">get_adamic_adar_index_from_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second_node_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_adamic_adar_index_from_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Adamic/Adar Index for the given pair of nodes from the given node names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>first_node_name</strong> (<em>str</em><em>,</em>) – Node name of the first node.</p></li>
<li><p><strong>second_node_name</strong> (<em>str</em><em>,</em>) – Node name of the second node.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If either of the given node names do not exist in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_all_shortest_paths">
<span class="sig-name descname"><span class="pre">get_all_shortest_paths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_all_shortest_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns graph with unweighted shortest paths computed up to the given depth.</p>
<p>The returned graph will have no selfloops.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show a loading bar while building the graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_average_clustering_coefficient">
<span class="sig-name descname"><span class="pre">get_average_clustering_coefficient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">low_centrality</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_average_clustering_coefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the graph average clustering coefficient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>low_centrality</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The threshold over which to switch to parallel matryoshka. By default 50.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show a loading bar.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_betweenness_centrality">
<span class="sig-name descname"><span class="pre">get_betweenness_centrality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normalize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_betweenness_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector of betweenness centrality for all nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>normalize</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to normalize the values. By default, it is false.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show a loading bar. By default, it is true.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_bfs_topological_sorting_from_node_id">
<span class="sig-name descname"><span class="pre">get_bfs_topological_sorting_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root_node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_bfs_topological_sorting_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns topological sorting map using breadth-first search from the given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>root_node_id</strong> (<em>int</em><em>,</em>) – Node ID of node to be used as root of BFS</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the given root node ID does not exist in the graph</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_bipartite_edge_names">
<span class="sig-name descname"><span class="pre">get_bipartite_edge_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">removed_existing_edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_nodes_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second_nodes_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_node_types_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second_node_types_set</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_bipartite_edge_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector of tuple of Node IDs that form the edges of the required bipartite graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>removed_existing_edges</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to filter out the existing edges. By default, true.</p></li>
<li><p><strong>first_nodes_set</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – Optional set of nodes to use to create the first set of nodes of the graph.</p></li>
<li><p><strong>second_nodes_set</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – Optional set of nodes to use to create the second set of nodes of the graph.</p></li>
<li><p><strong>first_node_types_set</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – Optional set of node types to create the first set of nodes of the graph.</p></li>
<li><p><strong>second_node_types_set</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – Optional set of node types to create the second set of nodes of the graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_bipartite_edges">
<span class="sig-name descname"><span class="pre">get_bipartite_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">removed_existing_edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_nodes_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second_nodes_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_node_types_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second_node_types_set</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_bipartite_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector of tuple of Node IDs that form the edges of the required bipartite graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>removed_existing_edges</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to filter out the existing edges. By default, true.</p></li>
<li><p><strong>first_nodes_set</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – Optional set of nodes to use to create the first set of nodes of the graph.</p></li>
<li><p><strong>second_nodes_set</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – Optional set of nodes to use to create the second set of nodes of the graph.</p></li>
<li><p><strong>first_node_types_set</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – Optional set of node types to create the first set of nodes of the graph.</p></li>
<li><p><strong>second_node_types_set</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – Optional set of node types to create the second set of nodes of the graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_breadth_first_search_from_node_ids">
<span class="sig-name descname"><span class="pre">get_breadth_first_search_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_predecessors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximal_depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_breadth_first_search_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector of minimum paths distances and vector of nodes predecessors from given source node ID and optional destination node ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_id</strong> (<em>int</em><em>,</em>) – Node ID root of the tree of minimum paths.</p></li>
<li><p><strong>compute_predecessors</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to compute the vector of predecessors.</p></li>
<li><p><strong>maximal_depth</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximal number of iterations to execute the DFS for.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the given source node ID does not exist in the current graph.</p></li>
<li><p><strong>ValueError</strong> – If the given optional destination node ID does not exist in the current graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_breadth_first_search_from_node_names">
<span class="sig-name descname"><span class="pre">get_breadth_first_search_from_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_predecessors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximal_depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_breadth_first_search_from_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector of minimum paths distances and vector of nodes predecessors from given source node name and optional destination node name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_name</strong> (<em>str</em><em>,</em>) – Node name root of the tree of minimum paths.</p></li>
<li><p><strong>dst_node_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – Destination node name.</p></li>
<li><p><strong>compute_predecessors</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to compute the vector of predecessors.</p></li>
<li><p><strong>maximal_depth</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximal depth to execute the DFS for.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the weights are to be used and the graph does not have weights.</p></li>
<li><p><strong>ValueError</strong> – If the given source node name does not exist in the current graph.</p></li>
<li><p><strong>ValueError</strong> – If the given optional destination node name does not exist in the current graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_breadth_first_search_random_nodes">
<span class="sig-name descname"><span class="pre">get_breadth_first_search_random_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_of_nodes_to_sample</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_breadth_first_search_random_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nodes sampled from the neighbourhood of given root nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>number_of_nodes_to_sample</strong> (<em>int</em><em>,</em>) – The number of nodes to sample.</p></li>
<li><p><strong>root_node</strong> (<em>int</em><em>,</em>) – The root node from .</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the number of requested nodes is higher than the number of nodes in the graph.</p></li>
<li><p><strong>ValueError</strong> – If the given root node does not exist in the curret graph instance.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_clique_edge_names">
<span class="sig-name descname"><span class="pre">get_clique_edge_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">directed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_selfloops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">removed_existing_edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_node_type_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_node_set</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_clique_edge_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector of tuple of Node names that form the edges of the required clique.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>directed</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to return the edges as directed or undirected. By default, equal to the graph.</p></li>
<li><p><strong>allow_selfloops</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to allow self-loops in the clique. By default, equal to the graph.</p></li>
<li><p><strong>removed_existing_edges</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to filter out the existing edges. By default, true.</p></li>
<li><p><strong>allow_node_type_set</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – Node types to include in the clique.</p></li>
<li><p><strong>allow_node_set</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – Nodes to include i the clique.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_clique_edges">
<span class="sig-name descname"><span class="pre">get_clique_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">directed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_selfloops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">removed_existing_edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_node_type_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_node_set</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_clique_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector of tuple of Node IDs that form the edges of the required clique.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>directed</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to return the edges as directed or undirected. By default, equal to the graph.</p></li>
<li><p><strong>allow_selfloops</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to allow self-loops in the clique. By default, equal to the graph.</p></li>
<li><p><strong>removed_existing_edges</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to filter out the existing edges. By default, true.</p></li>
<li><p><strong>allow_node_type_set</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – Node types to include in the clique.</p></li>
<li><p><strong>allow_node_set</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – Nodes to include i the clique.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_closeness_centrality">
<span class="sig-name descname"><span class="pre">get_closeness_centrality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_closeness_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Return closeness centrality for all nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show an indicative progress bar.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_clustering_coefficient">
<span class="sig-name descname"><span class="pre">get_clustering_coefficient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">low_centrality</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_clustering_coefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the graph clustering coefficient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>low_centrality</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The threshold over which to switch to parallel matryoshka. By default 50.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show a loading bar.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_clustering_coefficient_per_node">
<span class="sig-name descname"><span class="pre">get_clustering_coefficient_per_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">low_centrality</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_clustering_coefficient_per_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns clustering coefficients for all nodes in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>low_centrality</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The threshold over which to switch to parallel matryoshka. By default 50.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show a loading bar.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_comulative_node_degree_from_node_id">
<span class="sig-name descname"><span class="pre">get_comulative_node_degree_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_comulative_node_degree_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the comulative node degree up to the given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – Integer ID of the node.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_connected_components_number">
<span class="sig-name descname"><span class="pre">get_connected_components_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_connected_components_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number a triple with (number of components, number of nodes of the smallest component, number of nodes of the biggest component )</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show a loading bar or not.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_connected_nodes_number">
<span class="sig-name descname"><span class="pre">get_connected_nodes_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_connected_nodes_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of connected nodes in the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_cumulative_node_degrees">
<span class="sig-name descname"><span class="pre">get_cumulative_node_degrees</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_cumulative_node_degrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector with node cumulative_node_degrees, that is the comulative node degree</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_degree_centrality">
<span class="sig-name descname"><span class="pre">get_degree_centrality</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_degree_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector of unweighted degree centrality for all nodes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_dense_binary_adjacency_matrix">
<span class="sig-name descname"><span class="pre">get_dense_binary_adjacency_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_dense_binary_adjacency_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns binary dense adjacency matrix.</p>
<p>Beware of using this method on big graphs!
It’ll use all of your RAM!</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_dense_nodes_mapping">
<span class="sig-name descname"><span class="pre">get_dense_nodes_mapping</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_dense_nodes_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mapping from instance not trap nodes to dense nodes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_dense_weighted_adjacency_matrix">
<span class="sig-name descname"><span class="pre">get_dense_weighted_adjacency_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weight</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_dense_weighted_adjacency_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns binary weighted adjacency matrix.</p>
<p>Beware of using this method on big graphs!
It’ll use all of your RAM!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>weight</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – The weight value to use for absent edges. By default, <cite>0.0</cite>.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the graph does not have edge weights.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_density">
<span class="sig-name descname"><span class="pre">get_density</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns density of the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_destination_names">
<span class="sig-name descname"><span class="pre">get_destination_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">directed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_destination_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector of the non-unique destination nodes names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>directed</strong> (<em>bool</em><em>,</em>) – Whether to filter out the undirected edges.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_destination_node_id_from_edge_id">
<span class="sig-name descname"><span class="pre">get_destination_node_id_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_destination_node_id_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns destination node ID corresponding to given edge ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – The edge ID whose destination node ID is to be retrieved.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the given edge ID does not exist in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_destination_node_ids">
<span class="sig-name descname"><span class="pre">get_destination_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">directed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_destination_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector on the (non unique) destination nodes of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>directed</strong> (<em>bool</em><em>,</em>) – Whether to filter out the undirected edges.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_destination_node_name_from_edge_id">
<span class="sig-name descname"><span class="pre">get_destination_node_name_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_destination_node_name_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns destination node name corresponding to given edge ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – The edge ID whose destination node name is to be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_diameter">
<span class="sig-name descname"><span class="pre">get_diameter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ignore_infinity</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_diameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns diameter of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ignore_infinity</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to ignore infinite distances, which are present when in the graph exist multiple components.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show a loading bar.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the graph does not contain nodes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_diameter_naive">
<span class="sig-name descname"><span class="pre">get_diameter_naive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ignore_infinity</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_diameter_naive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns diameter of the graph using naive method.</p>
<p>Note that there exists the non-naive method for undirected graphs
and it is possible to implement a faster method for directed graphs
but we still need to get to it, as it will require an updated
succinct data structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ignore_infinity</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to ignore infinite distances, which are present when in the graph exist multiple components.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show a loading bar.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the graph does not contain nodes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_dijkstra_from_node_ids">
<span class="sig-name descname"><span class="pre">get_dijkstra_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maybe_dst_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maybe_dst_node_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_predecessors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximal_depth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_weights_as_probabilities</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_dijkstra_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector of minimum paths distances and vector of nodes predecessors from given source node ID and optional destination node ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_id</strong> (<em>int</em><em>,</em>) – Node ID root of the tree of minimum paths.</p></li>
<li><p><strong>maybe_dst_node_id</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Optional target destination. If provided, Dijkstra will stop upon reaching this node.</p></li>
<li><p><strong>maybe_dst_node_ids</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em><em>,</em>) – Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.</p></li>
<li><p><strong>compute_predecessors</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to compute the vector of predecessors.</p></li>
<li><p><strong>maximal_depth</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximal depth to execute the DFS for.</p></li>
<li><p><strong>use_edge_weights_as_probabilities</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to treat the edge weights as probabilities.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the weights are to be used and the graph does not have weights.</p></li>
<li><p><strong>ValueError</strong> – If the given source node ID does not exist in the current graph.</p></li>
<li><p><strong>ValueError</strong> – If the given optional destination node ID does not exist in the current graph.</p></li>
<li><p><strong>ValueError</strong> – If weights are requested to be treated as probabilities but are not between 0 and 1.</p></li>
<li><p><strong>ValueError</strong> – If the graph contains negative weights.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_dijkstra_from_node_names">
<span class="sig-name descname"><span class="pre">get_dijkstra_from_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maybe_dst_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maybe_dst_node_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_predecessors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximal_depth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_weights_as_probabilities</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_dijkstra_from_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector of minimum paths distances and vector of nodes predecessors from given source node name and optional destination node name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_name</strong> (<em>str</em><em>,</em>) – Node name root of the tree of minimum paths.</p></li>
<li><p><strong>maybe_dst_node_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – Optional target destination node name. If provided, Dijkstra will stop upon reaching this node.</p></li>
<li><p><strong>maybe_dst_node_names</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – Optional target destination node names. If provided, Dijkstra will stop upon reaching all of these nodes.</p></li>
<li><p><strong>compute_predecessors</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to compute the vector of predecessors.</p></li>
<li><p><strong>maximal_depth</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximal depth to execute the DFS for.</p></li>
<li><p><strong>use_edge_weights_as_probabilities</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to treat the edge weights as probabilities.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the weights are to be used and the graph does not have weights.</p></li>
<li><p><strong>ValueError</strong> – If the given source node name does not exist in the current graph.</p></li>
<li><p><strong>ValueError</strong> – If the given optional destination node name does not exist in the current graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_directed_destination_node_ids">
<span class="sig-name descname"><span class="pre">get_directed_destination_node_ids</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_directed_destination_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector on the (non unique) directed destination nodes of the graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_directed_edge_node_ids">
<span class="sig-name descname"><span class="pre">get_directed_edge_node_ids</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_directed_edge_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector with the sorted directed edge Ids</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_directed_edge_node_names">
<span class="sig-name descname"><span class="pre">get_directed_edge_node_names</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_directed_edge_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector with the sorted directed edge names</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_directed_edges_number">
<span class="sig-name descname"><span class="pre">get_directed_edges_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_directed_edges_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of directed edges in the graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_directed_modularity_from_node_community_memberships">
<span class="sig-name descname"><span class="pre">get_directed_modularity_from_node_community_memberships</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_community_memberships</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_directed_modularity_from_node_community_memberships" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the directed modularity of the graph from the given memberships.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the number of provided memberships does not match the number of nodes of the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_directed_source_node_ids">
<span class="sig-name descname"><span class="pre">get_directed_source_node_ids</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_directed_source_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector on the (non unique) directed source nodes of the graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_disconnected_nodes_number">
<span class="sig-name descname"><span class="pre">get_disconnected_nodes_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_disconnected_nodes_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of disconnected nodes within the graph.
A Disconnected node is a node which is nor a singleton nor a singleton
with selfloops.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_eccentricity_from_node_id">
<span class="sig-name descname"><span class="pre">get_eccentricity_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_eccentricity_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unweighted eccentricity of the given node ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_id</strong> (<em>int</em><em>,</em>) – Node for which to compute the eccentricity.</p></li>
<li><p><strong>use_edge_weights_as_probabilities</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to treat the edge weights as probabilities.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the given node ID does not exist in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_eccentricity_from_node_name">
<span class="sig-name descname"><span class="pre">get_eccentricity_from_node_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_eccentricity_from_node_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unweighted eccentricity of the given node name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_name</strong> (<em>str</em><em>,</em>) – Node for which to compute the eccentricity.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the given node name does not exist in the current graph instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_count_from_edge_type_id">
<span class="sig-name descname"><span class="pre">get_edge_count_from_edge_type_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_count_from_edge_type_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of edges with given edge type ID.</p>
<p>If None is given as an edge type ID, the unknown edge type IDs
will be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_type_id</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The edge type ID to count the edges of.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_count_from_edge_type_name">
<span class="sig-name descname"><span class="pre">get_edge_count_from_edge_type_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_count_from_edge_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of edges with given edge type name.</p>
<p>If None is given as an edge type name, the unknown edge types
will be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_type_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The edge type name to count the edges of.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_id_from_node_ids">
<span class="sig-name descname"><span class="pre">get_edge_id_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_id_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns edge ID corresponding to given source and destination node IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> (<em>int</em><em>,</em>) – The source node ID.</p></li>
<li><p><strong>dst</strong> (<em>int</em><em>,</em>) – The destination node ID.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_id_from_node_ids_and_edge_type_id">
<span class="sig-name descname"><span class="pre">get_edge_id_from_node_ids_and_edge_type_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_id_from_node_ids_and_edge_type_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return edge ID for given tuple of nodes and edge type.</p>
<p>This method will return an error if the graph does not contain the
requested edge with edge type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> (<em>int</em><em>,</em>) – Source node of the edge.</p></li>
<li><p><strong>dst</strong> (<em>int</em><em>,</em>) – Destination node of the edge.</p></li>
<li><p><strong>edge_type</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Edge Type of the edge.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_id_from_node_names">
<span class="sig-name descname"><span class="pre">get_edge_id_from_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_id_from_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return edge ID for given tuple of node names.</p>
<p>This method will return an error if the graph does not contain the
requested edge with edge type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_name</strong> (<em>str</em><em>,</em>) – Source node name of the edge.</p></li>
<li><p><strong>dst_name</strong> (<em>str</em><em>,</em>) – Destination node name of the edge.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_id_from_node_names_and_edge_type_name">
<span class="sig-name descname"><span class="pre">get_edge_id_from_node_names_and_edge_type_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_id_from_node_names_and_edge_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return edge ID for given tuple of node names and edge type name.</p>
<p>This method will return an error if the graph does not contain the
requested edge with edge type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_name</strong> (<em>str</em><em>,</em>) – Source node name of the edge.</p></li>
<li><p><strong>dst_name</strong> (<em>str</em><em>,</em>) – Destination node name of the edge.</p></li>
<li><p><strong>edge_type_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – Edge type name.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_ids_with_known_edge_types">
<span class="sig-name descname"><span class="pre">get_edge_ids_with_known_edge_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_ids_with_known_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns edge IDs of the edges with known edge types</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no edge types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_ids_with_known_edge_types_mask">
<span class="sig-name descname"><span class="pre">get_edge_ids_with_known_edge_types_mask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_ids_with_known_edge_types_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean vector that for each node contains whether it has an
unknown edge type.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no edge types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_ids_with_unknown_edge_types">
<span class="sig-name descname"><span class="pre">get_edge_ids_with_unknown_edge_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_ids_with_unknown_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns edge IDs of the edges with unknown edge types</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no edge types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_ids_with_unknown_edge_types_mask">
<span class="sig-name descname"><span class="pre">get_edge_ids_with_unknown_edge_types_mask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_ids_with_unknown_edge_types_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean vector that for each node contains whether it has an
unknown node type.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no edge types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_label_holdout_graphs">
<span class="sig-name descname"><span class="pre">get_edge_label_holdout_graphs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_stratification</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_label_holdout_graphs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns edge-label holdout for training ML algorithms on the graph edge labels.
This is commonly used for edge type prediction tasks.</p>
<p>This method returns two graphs, the train and the test one.
The edges of the graph will be splitted in the train and test graphs according
to the <cite>train_size</cite> argument.</p>
<p>If stratification is enabled, the train and test will have the same ratios of
edge types.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_size</strong> (<em>float</em><em>,</em>) – rate target to reserve for training,</p></li>
<li><p><strong>use_stratification</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to use edge-label stratification,</p></li>
<li><p><strong>random_state</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The random_state to use for the holdout,</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have edge types.</p></li>
<li><p><strong>ValueError</strong> – If stratification is required but the graph has singleton edge types.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_label_kfold">
<span class="sig-name descname"><span class="pre">get_edge_label_kfold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_stratification</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_label_kfold" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns edge-label kfold for training ML algorithms on the graph edge labels.
This is commonly used for edge type prediction tasks.</p>
<p>This method returns two graphs, the train and the test one.
The edges of the graph will be splitted in the train and test graphs according
to the <cite>train_size</cite> argument.</p>
<p>If stratification is enabled, the train and test will have the same ratios of
edge types.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<em>int</em><em>,</em>) – The number of folds.</p></li>
<li><p><strong>k_index</strong> (<em>int</em><em>,</em>) – Which fold to use for the validation.</p></li>
<li><p><strong>use_stratification</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to use edge-label stratification,</p></li>
<li><p><strong>random_state</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The random_state to use for the holdout,</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have edge types.</p></li>
<li><p><strong>ValueError</strong> – If stratification is required but the graph has singleton edge types.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_label_random_holdout">
<span class="sig-name descname"><span class="pre">get_edge_label_random_holdout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_stratification</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_label_random_holdout" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns edge-label holdout for training ML algorithms on the graph edge labels.
This is commonly used for edge type prediction tasks.</p>
<p>This method returns two graphs, the train and the test one.
The edges of the graph will be splitted in the train and test graphs according
to the <cite>train_size</cite> argument.</p>
<p>If stratification is enabled, the train and test will have the same ratios of
edge types.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_size</strong> (<em>float</em><em>,</em>) – rate target to reserve for training,</p></li>
<li><p><strong>use_stratification</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to use edge-label stratification,</p></li>
<li><p><strong>random_state</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The random_state to use for the holdout,</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have edge types.</p></li>
<li><p><strong>ValueError</strong> – If stratification is required but the graph has singleton edge types.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_node_ids">
<span class="sig-name descname"><span class="pre">get_edge_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">directed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector with the sorted edge Ids.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>directed</strong> (<em>bool</em><em>,</em>) – Whether to filter out the undirected edges.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_node_ids_from_edge_node_names">
<span class="sig-name descname"><span class="pre">get_edge_node_ids_from_edge_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_node_names</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_node_ids_from_edge_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns result with the edge node IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_node_names</strong> (<em>List</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em><em>,</em>) – The node names whose node IDs is to be returned.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – When any of the given node name does not exists in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_node_ids_with_known_edge_types">
<span class="sig-name descname"><span class="pre">get_edge_node_ids_with_known_edge_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">directed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_node_ids_with_known_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns edge node IDs of the edges with known edge types</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>directed</strong> (<em>bool</em><em>,</em>) – Whether to iterated the edges as a directed or undirected edge list.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If there are no edge types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_node_ids_with_unknown_edge_types">
<span class="sig-name descname"><span class="pre">get_edge_node_ids_with_unknown_edge_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">directed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_node_ids_with_unknown_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns edge node IDs of the edges with unknown edge types</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>directed</strong> (<em>bool</em><em>,</em>) – Whether to iterated the edges as a directed or undirected edge list.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If there are no edge types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_node_names">
<span class="sig-name descname"><span class="pre">get_edge_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">directed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector with the sorted edge names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>directed</strong> (<em>bool</em><em>,</em>) – Whether to filter out the undirected edges.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_node_names_from_edge_node_ids">
<span class="sig-name descname"><span class="pre">get_edge_node_names_from_edge_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_node_ids</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_node_names_from_edge_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns result with the edge node names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_node_ids</strong> (<em>List</em><em>[</em><em>Tuple</em><em>[</em><em>int</em><em>, </em><em>int</em><em>]</em><em>]</em><em>,</em>) – The node names whose node names is to be returned.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – When any of the given node IDs does not exists in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_node_names_with_known_edge_types">
<span class="sig-name descname"><span class="pre">get_edge_node_names_with_known_edge_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">directed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_node_names_with_known_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns edge node names of the edges with known edge types</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>directed</strong> (<em>bool</em><em>,</em>) – Whether to iterated the edges as a directed or undirected edge list.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If there are no edge types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_node_names_with_unknown_edge_types">
<span class="sig-name descname"><span class="pre">get_edge_node_names_with_unknown_edge_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">directed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_node_names_with_unknown_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns edge node names of the edges with unknown edge types</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>directed</strong> (<em>bool</em><em>,</em>) – Whether to iterated the edges as a directed or undirected edge list.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If there are no edge types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_prediction_kfold">
<span class="sig-name descname"><span class="pre">get_edge_prediction_kfold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_types</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_prediction_kfold" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns train and test graph following kfold validation scheme.</p>
<p>The edges are splitted into k chunks. The k_index-th chunk is used to build
the validation graph, all the other edges create the training graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<em>int</em><em>,</em>) – The number of folds.</p></li>
<li><p><strong>k_index</strong> (<em>int</em><em>,</em>) – Which fold to use for the validation.</p></li>
<li><p><strong>edge_types</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Optional</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em><em>,</em>) – Edge types to be selected when computing the folds (All the edge types not listed here will be always be used in the training set).</p></li>
<li><p><strong>random_state</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The random_state (seed) to use for the holdout,</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show the loading bar.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the number of requested k folds is one or zero.</p></li>
<li><p><strong>ValueError</strong> – If the given k fold index is greater than the number of k folds.</p></li>
<li><p><strong>ValueError</strong> – If edge types have been specified but it’s an empty list.</p></li>
<li><p><strong>ValueError</strong> – If the number of k folds is higher than the number of edges in the graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_type_id_counts_hashmap">
<span class="sig-name descname"><span class="pre">get_edge_type_id_counts_hashmap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_type_id_counts_hashmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns edge type IDs counts hashmap.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no edge types in the current graph instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_type_id_from_edge_id">
<span class="sig-name descname"><span class="pre">get_edge_type_id_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_type_id_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns edge type of given edge.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – edge whose edge type is to be returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_type_id_from_edge_type_name">
<span class="sig-name descname"><span class="pre">get_edge_type_id_from_edge_type_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_type_id_from_edge_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return edge type ID curresponding to given edge type name.</p>
<p>If None is given as an edge type ID, None is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_type_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The edge type name whose ID is to be returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_type_ids">
<span class="sig-name descname"><span class="pre">get_edge_type_ids</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_type_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the edge types of the edges</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_type_ids_from_edge_type_names">
<span class="sig-name descname"><span class="pre">get_edge_type_ids_from_edge_type_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type_names</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_type_ids_from_edge_type_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return translated edge types from string to internal edge ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_type_names</strong> (<em>List</em><em>[</em><em>Optional</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – Vector of edge types to be converted.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_type_name_from_edge_id">
<span class="sig-name descname"><span class="pre">get_edge_type_name_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_type_name_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns option with the edge type of the given edge id.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – The edge ID whose edge type is to be returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_type_name_from_edge_type_id">
<span class="sig-name descname"><span class="pre">get_edge_type_name_from_edge_type_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_type_name_from_edge_type_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return edge type name of given edge type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_type_id</strong> (<em>int</em><em>,</em>) – Id of the edge type.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_type_names">
<span class="sig-name descname"><span class="pre">get_edge_type_names</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_type_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the edge types names</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_type_names_counts_hashmap">
<span class="sig-name descname"><span class="pre">get_edge_type_names_counts_hashmap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_type_names_counts_hashmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns edge type names counts hashmap.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no edge types in the current graph instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_types_number">
<span class="sig-name descname"><span class="pre">get_edge_types_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_types_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of edge types in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no edge types in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_types_total_memory_requirements">
<span class="sig-name descname"><span class="pre">get_edge_types_total_memory_requirements</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_types_total_memory_requirements" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns how many bytes are currently used to store the edge types</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_types_total_memory_requirements_human_readable">
<span class="sig-name descname"><span class="pre">get_edge_types_total_memory_requirements_human_readable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_types_total_memory_requirements_human_readable" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns human readable amount of how many bytes are currently used to store the edge types</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_weight_from_edge_id">
<span class="sig-name descname"><span class="pre">get_edge_weight_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_weight_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns weight of the given edge id.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – The edge ID whose weight is to be returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_weight_from_node_ids">
<span class="sig-name descname"><span class="pre">get_edge_weight_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_weight_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns weight of the given node ids.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> (<em>int</em><em>,</em>) – The node ID of the source node.</p></li>
<li><p><strong>dst</strong> (<em>int</em><em>,</em>) – The node ID of the destination node.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_weight_from_node_ids_and_edge_type_id">
<span class="sig-name descname"><span class="pre">get_edge_weight_from_node_ids_and_edge_type_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_weight_from_node_ids_and_edge_type_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns weight of the given node ids and edge type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> (<em>int</em><em>,</em>) – The node ID of the source node.</p></li>
<li><p><strong>dst</strong> (<em>int</em><em>,</em>) – The node ID of the destination node.</p></li>
<li><p><strong>edge_type</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The edge type ID of the edge.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_weight_from_node_names">
<span class="sig-name descname"><span class="pre">get_edge_weight_from_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_weight_from_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns weight of the given node names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_name</strong> (<em>str</em><em>,</em>) – The node name of the source node.</p></li>
<li><p><strong>dst_name</strong> (<em>str</em><em>,</em>) – The node name of the destination node.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_weight_from_node_names_and_edge_type_name">
<span class="sig-name descname"><span class="pre">get_edge_weight_from_node_names_and_edge_type_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_weight_from_node_names_and_edge_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns weight of the given node names and edge type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> (<em>str</em><em>,</em>) – The node name of the source node.</p></li>
<li><p><strong>dst</strong> (<em>str</em><em>,</em>) – The node name of the destination node.</p></li>
<li><p><strong>edge_type</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The edge type name of the edge.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_weighting_methods">
<span class="sig-name descname"><span class="pre">get_edge_weighting_methods</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_weighting_methods" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of the supported edge weighting methods</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_weights">
<span class="sig-name descname"><span class="pre">get_edge_weights</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the weights of the graph edges.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_weights_total_memory_requirements">
<span class="sig-name descname"><span class="pre">get_edge_weights_total_memory_requirements</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_weights_total_memory_requirements" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns how many bytes are currently used to store the edge weights</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edge_weights_total_memory_requirements_human_readable">
<span class="sig-name descname"><span class="pre">get_edge_weights_total_memory_requirements_human_readable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edge_weights_total_memory_requirements_human_readable" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns human readable amount of how many bytes are currently used to store the edge weights</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edges_number">
<span class="sig-name descname"><span class="pre">get_edges_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edges_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of edges of the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edges_total_memory_requirement">
<span class="sig-name descname"><span class="pre">get_edges_total_memory_requirement</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edges_total_memory_requirement" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns how many bytes are currently used to store the edges</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_edges_total_memory_requirement_human_readable">
<span class="sig-name descname"><span class="pre">get_edges_total_memory_requirement_human_readable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_edges_total_memory_requirement_human_readable" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns human readable amount of how many bytes are currently used to store the edges</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_eigenvector_centrality">
<span class="sig-name descname"><span class="pre">get_eigenvector_centrality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">maximum_iterations_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tollerance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_eigenvector_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector with unweighted eigenvector centrality.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maximum_iterations_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximum number of iterations to consider.</p></li>
<li><p><strong>tollerance</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – The maximum error tollerance for convergence.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_harmonic_centrality">
<span class="sig-name descname"><span class="pre">get_harmonic_centrality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_harmonic_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Return harmonic centrality for all nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show an indicative progress bar.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_jaccard_coefficient_from_node_ids">
<span class="sig-name descname"><span class="pre">get_jaccard_coefficient_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination_node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_jaccard_coefficient_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Jaccard index for the two given nodes from the given node IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the first node.</p></li>
<li><p><strong>destination_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the second node.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If either of the node IDs are higher than the number of nodes in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_jaccard_coefficient_from_node_names">
<span class="sig-name descname"><span class="pre">get_jaccard_coefficient_from_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second_node_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_jaccard_coefficient_from_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Jaccard index for the two given nodes from the given node names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>first_node_name</strong> (<em>str</em><em>,</em>) – Node name of the first node.</p></li>
<li><p><strong>second_node_name</strong> (<em>str</em><em>,</em>) – Node name of the second node.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If either of the given node names do not exist in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_k_shortest_path_node_ids_from_node_ids">
<span class="sig-name descname"><span class="pre">get_k_shortest_path_node_ids_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_k_shortest_path_node_ids_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector of the k minimum paths node IDs between given source node and destination node ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_id</strong> (<em>int</em><em>,</em>) – Source node ID.</p></li>
<li><p><strong>dst_node_id</strong> (<em>int</em><em>,</em>) – Destination node ID.</p></li>
<li><p><strong>maximal_depth</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximal depth to execute the BFS for.</p></li>
<li><p><strong>k</strong> (<em>int</em><em>,</em>) – Number of paths to find.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If any of the given node IDs does not exist in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_k_shortest_path_node_ids_from_node_names">
<span class="sig-name descname"><span class="pre">get_k_shortest_path_node_ids_from_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_k_shortest_path_node_ids_from_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector of the k minimum paths node IDs between given source node and destination node name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_name</strong> (<em>str</em><em>,</em>) – Source node name.</p></li>
<li><p><strong>dst_node_name</strong> (<em>str</em><em>,</em>) – Destination node name.</p></li>
<li><p><strong>k</strong> (<em>int</em><em>,</em>) – Number of paths to find.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If any of the given node names does not exist in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_k_shortest_path_node_names_from_node_names">
<span class="sig-name descname"><span class="pre">get_k_shortest_path_node_names_from_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_k_shortest_path_node_names_from_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector of the k minimum paths node names between given source node and destination node name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_name</strong> (<em>str</em><em>,</em>) – Source node name.</p></li>
<li><p><strong>dst_node_name</strong> (<em>str</em><em>,</em>) – Destination node name.</p></li>
<li><p><strong>k</strong> (<em>int</em><em>,</em>) – Number of paths to find.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If any of the given node names does not exist in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_known_edge_types_number">
<span class="sig-name descname"><span class="pre">get_known_edge_types_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_known_edge_types_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of edge with known edge type.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no edge types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_known_edge_types_rate">
<span class="sig-name descname"><span class="pre">get_known_edge_types_rate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_known_edge_types_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns rate of known edge types over total edges number.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no edge types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_known_node_types_mask">
<span class="sig-name descname"><span class="pre">get_known_node_types_mask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_known_node_types_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean mask of known node types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_known_node_types_number">
<span class="sig-name descname"><span class="pre">get_known_node_types_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_known_node_types_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of node with known node type.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no node types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_known_node_types_rate">
<span class="sig-name descname"><span class="pre">get_known_node_types_rate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_known_node_types_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns rate of known node types over total nodes number.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no node types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_laplacian_coo_matrix_edges_number">
<span class="sig-name descname"><span class="pre">get_laplacian_coo_matrix_edges_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_laplacian_coo_matrix_edges_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of edges in the laplacian COO matrix representation of the graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_laplacian_transformed_graph">
<span class="sig-name descname"><span class="pre">get_laplacian_transformed_graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_laplacian_transformed_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unweighted laplacian transformation of the graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_max_encodable_edge_number">
<span class="sig-name descname"><span class="pre">get_max_encodable_edge_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_max_encodable_edge_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return maximum encodable edge number</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_maximum_edge_weight">
<span class="sig-name descname"><span class="pre">get_maximum_edge_weight</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_maximum_edge_weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum weight, if graph has weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not contain edge weights.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_maximum_multilabel_count">
<span class="sig-name descname"><span class="pre">get_maximum_multilabel_count</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_maximum_multilabel_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of maximum multilabel count.</p>
<p>This value is the maximum number of multilabel counts
that appear in any given node in the graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_maximum_node_degree">
<span class="sig-name descname"><span class="pre">get_maximum_node_degree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_maximum_node_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns maximum node degree of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not contain any node (is an empty graph).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_maximum_node_types_number">
<span class="sig-name descname"><span class="pre">get_maximum_node_types_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_maximum_node_types_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns maximum number of node types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no node types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_memory_stats">
<span class="sig-name descname"><span class="pre">get_memory_stats</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_memory_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string describing the memory usage of all the fields of all the
structures used to store the current graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_minimum_edge_types_number">
<span class="sig-name descname"><span class="pre">get_minimum_edge_types_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_minimum_edge_types_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns minimum number of edge types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no edge types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_minimum_node_degree">
<span class="sig-name descname"><span class="pre">get_minimum_node_degree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_minimum_node_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns minimum node degree of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not contain any node (is an empty graph).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_minimum_node_types_number">
<span class="sig-name descname"><span class="pre">get_minimum_node_types_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_minimum_node_types_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns minimum number of node types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no node types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_mininum_edge_weight">
<span class="sig-name descname"><span class="pre">get_mininum_edge_weight</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_mininum_edge_weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum weight, if graph has weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not contain edge weights.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_minmax_edge_ids_from_node_ids">
<span class="sig-name descname"><span class="pre">get_minmax_edge_ids_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_minmax_edge_ids_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return range of outbound edges IDs for all the edges bewteen the given
source and destination nodes.
This operation is meaningfull only in a multigraph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> (<em>int</em><em>,</em>) – Source node.</p></li>
<li><p><strong>dst</strong> (<em>int</em><em>,</em>) – Destination node.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_minmax_edge_ids_from_source_node_id">
<span class="sig-name descname"><span class="pre">get_minmax_edge_ids_from_source_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_minmax_edge_ids_from_source_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return range of outbound edges IDs which have as source the given Node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>src</strong> (<em>int</em><em>,</em>) – Node for which we need to compute the cumulative_node_degrees range.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_most_central_node_id">
<span class="sig-name descname"><span class="pre">get_most_central_node_id</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_most_central_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns maximum node degree of the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_multiple_node_type_ids_from_node_type_names">
<span class="sig-name descname"><span class="pre">get_multiple_node_type_ids_from_node_type_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_type_names</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_multiple_node_type_ids_from_node_type_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return translated node types from string to internal node ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_type_names</strong> (<em>List</em><em>[</em><em>Optional</em><em>[</em><em>List</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em><em>,</em>) – Vector of node types to be converted.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have node types.</p></li>
<li><p><strong>ValueError</strong> – If any of the given node type names do not exists in the graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_name">
<span class="sig-name descname"><span class="pre">get_name</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return name of the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_neighbour_node_ids_from_node_id">
<span class="sig-name descname"><span class="pre">get_neighbour_node_ids_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_neighbour_node_ids_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector of destinations for the given source node ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – Node ID whose neighbours are to be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_neighbour_node_ids_from_node_name">
<span class="sig-name descname"><span class="pre">get_neighbour_node_ids_from_node_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_neighbour_node_ids_from_node_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector of destinations for the given source node name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_name</strong> (<em>str</em><em>,</em>) – Node ID whose neighbours are to be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_neighbour_node_names_from_node_name">
<span class="sig-name descname"><span class="pre">get_neighbour_node_names_from_node_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_neighbour_node_names_from_node_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector of destination names for the given source node name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_name</strong> (<em>str</em><em>,</em>) – Node name whose neighbours are to be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_connected_component_ids">
<span class="sig-name descname"><span class="pre">get_node_connected_component_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_connected_component_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a vector with the components each node belongs to.</p>
<p>E.g. If we have two components <cite>[0, 2, 3]</cite> and <cite>[1, 4, 5]</cite> the result will look like
<cite>[0, 1, 0, 0, 1, 1]</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show the loading bar.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_count_from_node_type_id">
<span class="sig-name descname"><span class="pre">get_node_count_from_node_type_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_type_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_count_from_node_type_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of nodes with given node type ID.</p>
<p>If None is given as an node type ID, the unknown node types
will be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_type_id</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The node type ID to count the nodes of.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_count_from_node_type_name">
<span class="sig-name descname"><span class="pre">get_node_count_from_node_type_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_type_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_count_from_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of nodes with given node type name.</p>
<p>If None is given as an node type name, the unknown node types
will be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_type_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node type name to count the nodes of.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_degree_from_node_id">
<span class="sig-name descname"><span class="pre">get_node_degree_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_degree_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of outbound neighbours of given node ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – Integer ID of the node.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_degree_from_node_name">
<span class="sig-name descname"><span class="pre">get_node_degree_from_node_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_degree_from_node_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of outbound neighbours of given node name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_name</strong> (<em>str</em><em>,</em>) – Integer ID of the node.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the given node name does not exist in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_degrees">
<span class="sig-name descname"><span class="pre">get_node_degrees</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_degrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unweighted degree of every node in the graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_degrees_mean">
<span class="sig-name descname"><span class="pre">get_node_degrees_mean</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_degrees_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unweighted mean node degree of the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_degrees_median">
<span class="sig-name descname"><span class="pre">get_node_degrees_median</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_degrees_median" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unweighted median node degree of the graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_degrees_mode">
<span class="sig-name descname"><span class="pre">get_node_degrees_mode</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_degrees_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns mode node degree of the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_id_from_node_name">
<span class="sig-name descname"><span class="pre">get_node_id_from_node_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_id_from_node_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns result with the node ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_name</strong> (<em>str</em><em>,</em>) – The node name whose node ID is to be returned.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – When the given node name does not exists in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_ids">
<span class="sig-name descname"><span class="pre">get_node_ids</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector with the sorted nodes Ids</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id">
<span class="sig-name descname"><span class="pre">get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the src, dst, edge type and weight of a given edge ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – The edge ID whose source, destination, edge type and weight are to be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_ids_and_edge_type_id_from_edge_id">
<span class="sig-name descname"><span class="pre">get_node_ids_and_edge_type_id_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_ids_and_edge_type_id_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the src, dst, edge type of a given edge ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – The edge ID whose source, destination and edge type are to be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_ids_from_edge_id">
<span class="sig-name descname"><span class="pre">get_node_ids_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_ids_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns node names corresponding to given edge ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – The edge ID whose source and destination node IDs are to e retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_ids_from_node_names">
<span class="sig-name descname"><span class="pre">get_node_ids_from_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_names</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_ids_from_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns result with the node IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_names</strong> (<em>List</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node names whose node IDs is to be returned.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – When any of the given node name does not exists in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_ids_with_known_node_types">
<span class="sig-name descname"><span class="pre">get_node_ids_with_known_node_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_ids_with_known_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns node IDs of the nodes with known node types</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no node types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_ids_with_known_node_types_mask">
<span class="sig-name descname"><span class="pre">get_node_ids_with_known_node_types_mask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_ids_with_known_node_types_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean vector that for each node contains whether it has an
known node type.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no node types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_ids_with_unknown_node_types">
<span class="sig-name descname"><span class="pre">get_node_ids_with_unknown_node_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_ids_with_unknown_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns node IDs of the nodes with unknown node types</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no node types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_ids_with_unknown_node_types_mask">
<span class="sig-name descname"><span class="pre">get_node_ids_with_unknown_node_types_mask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_ids_with_unknown_node_types_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean vector that for each node contains whether it has an
unknown node type.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no node types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_indegrees">
<span class="sig-name descname"><span class="pre">get_node_indegrees</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_indegrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indegree for each node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_label_holdout_graphs">
<span class="sig-name descname"><span class="pre">get_node_label_holdout_graphs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_stratification</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_label_holdout_graphs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns node-label holdout for training ML algorithms on the graph node labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_size</strong> (<em>float</em><em>,</em>) – rate target to reserve for training,</p></li>
<li><p><strong>use_stratification</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to use node-label stratification,</p></li>
<li><p><strong>random_state</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The random_state to use for the holdout,</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have node types.</p></li>
<li><p><strong>ValueError</strong> – If stratification is requested but the graph has a single node type.</p></li>
<li><p><strong>ValueError</strong> – If stratification is requested but the graph has a multilabel node types.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_label_holdout_indices">
<span class="sig-name descname"><span class="pre">get_node_label_holdout_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_stratification</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_label_holdout_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns node-label holdout indices for training ML algorithms on the graph node labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_size</strong> (<em>float</em><em>,</em>) – rate target to reserve for training,</p></li>
<li><p><strong>use_stratification</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to use node-label stratification,</p></li>
<li><p><strong>random_state</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The random_state to use for the holdout,</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have node types.</p></li>
<li><p><strong>ValueError</strong> – If stratification is requested but the graph has a single node type.</p></li>
<li><p><strong>ValueError</strong> – If stratification is requested but the graph has a multilabel node types.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_label_holdout_labels">
<span class="sig-name descname"><span class="pre">get_node_label_holdout_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_stratification</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_label_holdout_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns node-label holdout indices for training ML algorithms on the graph node labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_size</strong> (<em>float</em><em>,</em>) – rate target to reserve for training,</p></li>
<li><p><strong>use_stratification</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to use node-label stratification,</p></li>
<li><p><strong>random_state</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The random_state to use for the holdout,</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have node types.</p></li>
<li><p><strong>ValueError</strong> – If stratification is requested but the graph has a single node type.</p></li>
<li><p><strong>ValueError</strong> – If stratification is requested but the graph has a multilabel node types.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_label_kfold">
<span class="sig-name descname"><span class="pre">get_node_label_kfold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_stratification</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_label_kfold" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns node-label fold for training ML algorithms on the graph node labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<em>int</em><em>,</em>) – The number of folds.</p></li>
<li><p><strong>k_index</strong> (<em>int</em><em>,</em>) – Which fold to use for the validation.</p></li>
<li><p><strong>use_stratification</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to use node-label stratification,</p></li>
<li><p><strong>random_state</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The random_state to use for the holdout,</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have node types.</p></li>
<li><p><strong>ValueError</strong> – If stratification is requested but the graph has a single node type.</p></li>
<li><p><strong>ValueError</strong> – If stratification is requested but the graph has a multilabel node types.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_label_random_holdout">
<span class="sig-name descname"><span class="pre">get_node_label_random_holdout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_stratification</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_label_random_holdout" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns node-label holdout for training ML algorithms on the graph node labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_size</strong> (<em>float</em><em>,</em>) – rate target to reserve for training,</p></li>
<li><p><strong>use_stratification</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to use node-label stratification,</p></li>
<li><p><strong>random_state</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The random_state to use for the holdout,</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have node types.</p></li>
<li><p><strong>ValueError</strong> – If stratification is requested but the graph has a single node type.</p></li>
<li><p><strong>ValueError</strong> – If stratification is requested but the graph has a multilabel node types.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_name_from_node_id">
<span class="sig-name descname"><span class="pre">get_node_name_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_name_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns result with the node name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – The node ID whose name is to be returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_names">
<span class="sig-name descname"><span class="pre">get_node_names</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector with the sorted nodes names</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_names_from_edge_id">
<span class="sig-name descname"><span class="pre">get_node_names_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_names_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns node names corresponding to given edge ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – The edge ID whose source and destination node IDs are to e retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_names_with_known_node_types">
<span class="sig-name descname"><span class="pre">get_node_names_with_known_node_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_names_with_known_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns node names of the nodes with known node types</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no node types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_names_with_unknown_node_types">
<span class="sig-name descname"><span class="pre">get_node_names_with_unknown_node_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_names_with_unknown_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns node names of the nodes with unknown node types</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no node types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_ontologies">
<span class="sig-name descname"><span class="pre">get_node_ontologies</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_ontologies" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector with the node predicted ontology.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_report_from_node_id">
<span class="sig-name descname"><span class="pre">get_node_report_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_report_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return human-readable html report of the given node.</p>
<p>The report, by default, is rendered using html.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – Whether to show a loading bar in graph operations.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_report_from_node_name">
<span class="sig-name descname"><span class="pre">get_node_report_from_node_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_report_from_node_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return human-readable html report of the given node.</p>
<p>The report, by default, is rendered using html.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_name</strong> (<em>str</em><em>,</em>) – Whether to show a loading bar in graph operations.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_sampling_methods">
<span class="sig-name descname"><span class="pre">get_node_sampling_methods</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_sampling_methods" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of the supported node sampling methods</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_type_id_counts_hashmap">
<span class="sig-name descname"><span class="pre">get_node_type_id_counts_hashmap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_type_id_counts_hashmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns node type IDs counts hashmap.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no node types in the current graph instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_type_id_from_node_type_name">
<span class="sig-name descname"><span class="pre">get_node_type_id_from_node_type_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_type_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_type_id_from_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return node type ID curresponding to given node type name.</p>
<p>If None is given as an node type ID, None is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_type_name</strong> (<em>str</em><em>,</em>) – The node type name whose ID is to be returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_type_ids">
<span class="sig-name descname"><span class="pre">get_node_type_ids</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_type_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the node types of the graph nodes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_type_ids_from_node_id">
<span class="sig-name descname"><span class="pre">get_node_type_ids_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_type_ids_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns node type of given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – node whose node type is to be returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_type_ids_from_node_name">
<span class="sig-name descname"><span class="pre">get_node_type_ids_from_node_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_type_ids_from_node_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return node type ID for the given node name if available.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_name</strong> (<em>str</em><em>,</em>) – Name of the node.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_type_ids_from_node_type_names">
<span class="sig-name descname"><span class="pre">get_node_type_ids_from_node_type_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_type_names</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_type_ids_from_node_type_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return translated node types from string to internal node ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_type_names</strong> (<em>List</em><em>[</em><em>Optional</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – Vector of node types to be converted.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_type_name_from_node_name">
<span class="sig-name descname"><span class="pre">get_node_type_name_from_node_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_type_name_from_node_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return node type name for the given node name if available.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_name</strong> (<em>str</em><em>,</em>) – Name of the node.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_type_name_from_node_type_id">
<span class="sig-name descname"><span class="pre">get_node_type_name_from_node_type_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_type_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_type_name_from_node_type_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return node type name of given node type.</p>
<p>There is no need for a unchecked version since we will have to map
on the note_types anyway.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_type_id</strong> (<em>int</em><em>,</em>) – Id of the node type.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_type_names">
<span class="sig-name descname"><span class="pre">get_node_type_names</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_type_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the node types names.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_type_names_counts_hashmap">
<span class="sig-name descname"><span class="pre">get_node_type_names_counts_hashmap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_type_names_counts_hashmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns node type names counts hashmap.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no node types in the current graph instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_type_names_from_node_id">
<span class="sig-name descname"><span class="pre">get_node_type_names_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_type_names_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns result of option with the node type of the given node id.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – The node ID whose node types are to be returned.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the node types are not available for the current graph instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_type_names_from_node_name">
<span class="sig-name descname"><span class="pre">get_node_type_names_from_node_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_type_names_from_node_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns result of option with the node type of the given node name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_name</strong> (<em>str</em><em>,</em>) – The node name whose node types are to be returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_types_number">
<span class="sig-name descname"><span class="pre">get_node_types_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_types_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of node types in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no node types in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_types_total_memory_requirements">
<span class="sig-name descname"><span class="pre">get_node_types_total_memory_requirements</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_types_total_memory_requirements" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns how many bytes are currently used to store the node types</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_types_total_memory_requirements_human_readable">
<span class="sig-name descname"><span class="pre">get_node_types_total_memory_requirements_human_readable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_types_total_memory_requirements_human_readable" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns human readable amount of how many bytes are currently used to store the node types</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_node_urls">
<span class="sig-name descname"><span class="pre">get_node_urls</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_node_urls" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector with the node URLs.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_nodes_mapping">
<span class="sig-name descname"><span class="pre">get_nodes_mapping</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_nodes_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the nodes mapping</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_nodes_number">
<span class="sig-name descname"><span class="pre">get_nodes_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_nodes_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of nodes in the graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_nodes_total_memory_requirement">
<span class="sig-name descname"><span class="pre">get_nodes_total_memory_requirement</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_nodes_total_memory_requirement" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns how many bytes are currently used to store the nodes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_nodes_total_memory_requirement_human_readable">
<span class="sig-name descname"><span class="pre">get_nodes_total_memory_requirement_human_readable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_nodes_total_memory_requirement_human_readable" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns human readable amount of how many bytes are currently used to store the nodes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_not_singletons_node_ids">
<span class="sig-name descname"><span class="pre">get_not_singletons_node_ids</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_not_singletons_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return set of nodes that are not singletons</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_number_of_triangles">
<span class="sig-name descname"><span class="pre">get_number_of_triangles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normalize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_centrality</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_number_of_triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns total number of triangles ignoring the weights.</p>
<p>The method dispatches the fastest method according to the current
graph instance. Specifically:
- For directed graphs it will use the naive algorithm.
- For undirected graphs it will use Bader’s version.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>normalize</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to normalize the number of triangles.</p></li>
<li><p><strong>low_centrality</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The threshold over which to switch to parallel matryoshka. By default 50.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show a loading bar.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_number_of_triangles_per_node">
<span class="sig-name descname"><span class="pre">get_number_of_triangles_per_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normalize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_centrality</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_number_of_triangles_per_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of triangles in the graph without taking into account the weights.</p>
<p>The method dispatches the fastest method according to the current
graph instance. Specifically:
- For directed graphs it will use the naive algorithm.
- For undirected graphs it will use Bader’s version.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>normalize</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to normalize the number of triangles.</p></li>
<li><p><strong>low_centrality</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The threshold over which to switch to parallel matryoshka. By default 50.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show a loading bar.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_okapi_bm25_node_feature_propagation">
<span class="sig-name descname"><span class="pre">get_okapi_bm25_node_feature_propagation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">features</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximal_distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_central_node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_okapi_bm25_node_feature_propagation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns okapi node features propagation within given maximal distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>features</strong> (<em>List</em><em>[</em><em>Optional</em><em>[</em><em>List</em><em>[</em><em>float</em><em>]</em><em>]</em><em>]</em><em>,</em>) – The features to propagate. Use None to represent eventual unknown features.</p></li>
<li><p><strong>iterations</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The number of iterations to execute. By default one.</p></li>
<li><p><strong>maximal_distance</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The distance to consider for the cooccurrences. The default value is 3.</p></li>
<li><p><strong>k1</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – The k1 parameter from okapi. Tipicaly between 1.2 and 2.0. It can be seen as a smoothing.</p></li>
<li><p><strong>b</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – The b parameter from okapi. Tipicaly 0.75.</p></li>
<li><p><strong>include_central_node</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to include the central node. By default true.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show loading bar.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_okapi_bm25_node_label_propagation">
<span class="sig-name descname"><span class="pre">get_okapi_bm25_node_label_propagation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximal_distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_okapi_bm25_node_label_propagation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns okapi node label propagation within given maximal distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The number of iterations to execute. By default one.</p></li>
<li><p><strong>maximal_distance</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The distance to consider for the cooccurrences. The default value is 3.</p></li>
<li><p><strong>k1</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – The k1 parameter from okapi. Tipicaly between 1.2 and 2.0. It can be seen as a smoothing.</p></li>
<li><p><strong>b</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – The b parameter from okapi. Tipicaly 0.75.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show loading bar.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_one_hot_encoded_edge_types">
<span class="sig-name descname"><span class="pre">get_one_hot_encoded_edge_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_one_hot_encoded_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns one-hot encoded edge types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have edge types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_one_hot_encoded_known_edge_types">
<span class="sig-name descname"><span class="pre">get_one_hot_encoded_known_edge_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_one_hot_encoded_known_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns one-hot encoded known edge types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have edge types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_one_hot_encoded_known_node_types">
<span class="sig-name descname"><span class="pre">get_one_hot_encoded_known_node_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_one_hot_encoded_known_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns one-hot encoded known node types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_one_hot_encoded_node_types">
<span class="sig-name descname"><span class="pre">get_one_hot_encoded_node_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_one_hot_encoded_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns one-hot encoded node types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_parallel_edges_number">
<span class="sig-name descname"><span class="pre">get_parallel_edges_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_parallel_edges_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of edges that have multigraph syblings</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_preferential_attachment_from_node_ids">
<span class="sig-name descname"><span class="pre">get_preferential_attachment_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_preferential_attachment_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unweighted preferential attachment from the given node IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the first node.</p></li>
<li><p><strong>destination_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the second node.</p></li>
<li><p><strong>normalize</strong> (<em>bool</em><em>,</em>) – Whether to normalize by the square of maximum degree.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If either of the node IDs are higher than the number of nodes in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_preferential_attachment_from_node_names">
<span class="sig-name descname"><span class="pre">get_preferential_attachment_from_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_preferential_attachment_from_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unweighted preferential attachment from the given node names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>first_node_name</strong> (<em>str</em><em>,</em>) – Node name of the first node.</p></li>
<li><p><strong>second_node_name</strong> (<em>str</em><em>,</em>) – Node name of the second node.</p></li>
<li><p><strong>normalize</strong> (<em>bool</em><em>,</em>) – Whether to normalize by the square of maximum degree.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If either of the given node names do not exist in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_random_nodes">
<span class="sig-name descname"><span class="pre">get_random_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_of_nodes_to_sample</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_random_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return random unique sorted numbers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>number_of_nodes_to_sample</strong> (<em>int</em><em>,</em>) – The number of nodes to sample.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>,</em>) – The random state to use to reproduce the sampling.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_random_subgraph">
<span class="sig-name descname"><span class="pre">get_random_subgraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_random_subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns subgraph with given number of nodes.</p>
<p><strong>This method creates a subset of the graph starting from a random node
sampled using given random_state and includes all neighbouring nodes until
the required number of nodes is reached</strong>. All the edges connecting any
of the selected nodes are then inserted into this graph.</p>
<p>This is meant to execute distributed node embeddings.
It may also sample singleton nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nodes_number</strong> (<em>int</em><em>,</em>) – Number of nodes to extract.</p></li>
<li><p><strong>random_state</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Random random_state to use.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show the loading bar.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the requested number of nodes is one or less.</p></li>
<li><p><strong>ValueError</strong> – If the graph has less than the requested number of nodes.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_random_walk_normalized_laplacian_transformed_graph">
<span class="sig-name descname"><span class="pre">get_random_walk_normalized_laplacian_transformed_graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_random_walk_normalized_laplacian_transformed_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unweighted random walk normalized laplacian transformation of the graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_resource_allocation_index_from_node_ids">
<span class="sig-name descname"><span class="pre">get_resource_allocation_index_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination_node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_resource_allocation_index_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the first node.</p></li>
<li><p><strong>destination_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the second node.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If either of the node IDs are higher than the number of nodes in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_resource_allocation_index_from_node_names">
<span class="sig-name descname"><span class="pre">get_resource_allocation_index_from_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second_node_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_resource_allocation_index_from_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>first_node_name</strong> (<em>str</em><em>,</em>) – Node name of the first node.</p></li>
<li><p><strong>second_node_name</strong> (<em>str</em><em>,</em>) – Node name of the second node.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If either of the given node names do not exist in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_reversed_bfs_topological_sorting_from_node_id">
<span class="sig-name descname"><span class="pre">get_reversed_bfs_topological_sorting_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root_node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_reversed_bfs_topological_sorting_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns topological sorting reversed map using breadth-first search from the given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>root_node_id</strong> (<em>int</em><em>,</em>) – Node ID of node to be used as root of BFS</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the given root node ID does not exist in the graph</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_selfloop_nodes_rate">
<span class="sig-name descname"><span class="pre">get_selfloop_nodes_rate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_selfloop_nodes_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns rate of self-loops.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_selfloops_number">
<span class="sig-name descname"><span class="pre">get_selfloops_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_selfloops_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of self-loops, including also those in eventual multi-edges.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_shortest_path_node_ids_from_node_ids">
<span class="sig-name descname"><span class="pre">get_shortest_path_node_ids_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximal_depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_shortest_path_node_ids_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns minimum path node names from given node ids.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_id</strong> (<em>int</em><em>,</em>) – Source node ID.</p></li>
<li><p><strong>dst_node_id</strong> (<em>int</em><em>,</em>) – Destination node ID.</p></li>
<li><p><strong>maximal_depth</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximal depth to execute the BFS for.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If any of the given node IDs do not exist in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_shortest_path_node_ids_from_node_names">
<span class="sig-name descname"><span class="pre">get_shortest_path_node_ids_from_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximal_depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_shortest_path_node_ids_from_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns minimum path node names from given node names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_name</strong> (<em>str</em><em>,</em>) – Source node name.</p></li>
<li><p><strong>dst_node_name</strong> (<em>str</em><em>,</em>) – Destination node name.</p></li>
<li><p><strong>maximal_depth</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximal depth to execute the BFS for.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If any of the given node names do not exist in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_shortest_path_node_names_from_node_names">
<span class="sig-name descname"><span class="pre">get_shortest_path_node_names_from_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximal_depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_shortest_path_node_names_from_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns minimum path node names from given node names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_name</strong> (<em>str</em><em>,</em>) – Source node name.</p></li>
<li><p><strong>dst_node_name</strong> (<em>str</em><em>,</em>) – Destination node name.</p></li>
<li><p><strong>maximal_depth</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximal depth to execute the BFS for.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If any of the given node names do not exist in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_singleton_edge_type_ids">
<span class="sig-name descname"><span class="pre">get_singleton_edge_type_ids</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_singleton_edge_type_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector of singleton edge types IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have edge types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_singleton_edge_type_names">
<span class="sig-name descname"><span class="pre">get_singleton_edge_type_names</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_singleton_edge_type_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector of singleton edge types names.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have edge types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_singleton_edge_types_number">
<span class="sig-name descname"><span class="pre">get_singleton_edge_types_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_singleton_edge_types_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of singleton edge types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have edge types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_singleton_node_ids">
<span class="sig-name descname"><span class="pre">get_singleton_node_ids</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_singleton_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector of singleton node IDs of the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_singleton_node_names">
<span class="sig-name descname"><span class="pre">get_singleton_node_names</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_singleton_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector of singleton node names of the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_singleton_node_type_ids">
<span class="sig-name descname"><span class="pre">get_singleton_node_type_ids</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_singleton_node_type_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector of singleton node types IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_singleton_node_type_names">
<span class="sig-name descname"><span class="pre">get_singleton_node_type_names</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_singleton_node_type_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector of singleton node types names.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_singleton_node_types_number">
<span class="sig-name descname"><span class="pre">get_singleton_node_types_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_singleton_node_types_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of singleton node types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_singleton_nodes_number">
<span class="sig-name descname"><span class="pre">get_singleton_nodes_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_singleton_nodes_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of singleton nodes within the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_singleton_nodes_with_selfloops_number">
<span class="sig-name descname"><span class="pre">get_singleton_nodes_with_selfloops_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_singleton_nodes_with_selfloops_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of singleton nodes with selfloops within the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_singleton_with_selfloops_node_ids">
<span class="sig-name descname"><span class="pre">get_singleton_with_selfloops_node_ids</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_singleton_with_selfloops_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector of singleton_with_selfloops node IDs of the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_singleton_with_selfloops_node_names">
<span class="sig-name descname"><span class="pre">get_singleton_with_selfloops_node_names</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_singleton_with_selfloops_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector of singleton_with_selfloops node names of the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_source_names">
<span class="sig-name descname"><span class="pre">get_source_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">directed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_source_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector of the non-unique source nodes names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>directed</strong> (<em>bool</em><em>,</em>) – Whether to filter out the undirected edges.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_source_node_id_from_edge_id">
<span class="sig-name descname"><span class="pre">get_source_node_id_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_source_node_id_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns source node ID corresponding to given edge ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – The edge ID whose source node ID is to be retrieved.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the given edge ID does not exist in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_source_node_ids">
<span class="sig-name descname"><span class="pre">get_source_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">directed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_source_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector of the non-unique source nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>directed</strong> (<em>bool</em><em>,</em>) – Whether to filter out the undirected edges.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_source_node_name_from_edge_id">
<span class="sig-name descname"><span class="pre">get_source_node_name_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_source_node_name_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns source node name corresponding to given edge ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – The edge ID whose source node name is to be retrieved.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_sparse_edge_weighting_methods">
<span class="sig-name descname"><span class="pre">get_sparse_edge_weighting_methods</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_sparse_edge_weighting_methods" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of the supported sparse edge weighting methods</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_star_edge_names">
<span class="sig-name descname"><span class="pre">get_star_edge_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">central_node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">removed_existing_edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">star_points_nodes_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">star_points_node_types_set</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_star_edge_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector of tuple of Node names that form the edges of the required star.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>central_node</strong> (<em>str</em><em>,</em>) – Name of the node to use as center of the star.</p></li>
<li><p><strong>removed_existing_edges</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to filter out the existing edges. By default, true.</p></li>
<li><p><strong>star_points_nodes_set</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – Optional set of nodes to use to create the set of star points.</p></li>
<li><p><strong>star_points_node_types_set</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – Optional set of node types to create the set of star points.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_star_edges">
<span class="sig-name descname"><span class="pre">get_star_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">central_node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">removed_existing_edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">star_points_nodes_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">star_points_node_types_set</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_star_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector of tuple of Node IDs that form the edges of the required star.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>central_node</strong> (<em>str</em><em>,</em>) – Name of the node to use as center of the star.</p></li>
<li><p><strong>removed_existing_edges</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to filter out the existing edges. By default, true.</p></li>
<li><p><strong>star_points_nodes_set</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – Optional set of nodes to use to create the set of star points.</p></li>
<li><p><strong>star_points_node_types_set</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – Optional set of node types to create the set of star points.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_stress_centrality">
<span class="sig-name descname"><span class="pre">get_stress_centrality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normalize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_stress_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector of stress centrality for all nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>normalize</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to normalize the values. By default, it is false.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show a loading bar. By default, it is true.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_subsampled_nodes">
<span class="sig-name descname"><span class="pre">get_subsampled_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_of_nodes_to_sample</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_sampling_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unique</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_subsampled_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return subsampled nodes according to the given method and parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>number_of_nodes_to_sample</strong> (<em>int</em><em>,</em>) – The number of nodes to sample.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>,</em>) – The random state to reproduce the sampling.</p></li>
<li><p><strong>root_node</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The (optional) root node to use to sample. In not provided, a random one is sampled.</p></li>
<li><p><strong>node_sampling_method</strong> (<em>str</em><em>,</em>) – The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</p></li>
<li><p><strong>unique</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to make the sampled nodes unique.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the given node sampling method is not supported.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_symmetric_normalized_laplacian_transformed_graph">
<span class="sig-name descname"><span class="pre">get_symmetric_normalized_laplacian_transformed_graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_symmetric_normalized_laplacian_transformed_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unweighted symmetric normalized laplacian transformation of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – The graph must be undirected, as we do not currently support this transformation for directed graphs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_symmetric_normalized_transformed_graph">
<span class="sig-name descname"><span class="pre">get_symmetric_normalized_transformed_graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_symmetric_normalized_transformed_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unweighted symmetric normalized transformation of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – The graph must be undirected, as we do not currently support this transformation for directed graphs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_top_k_central_node_ids">
<span class="sig-name descname"><span class="pre">get_top_k_central_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_top_k_central_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector with unweighted top k central node Ids.</p>
<p>If the k passed is bigger than the number of nodes this method will return
all the nodes in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>k</strong> (<em>int</em><em>,</em>) – Number of central nodes to extract.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the given value k is zero.</p></li>
<li><p><strong>ValueError</strong> – If the graph has no nodes.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_top_k_central_node_names">
<span class="sig-name descname"><span class="pre">get_top_k_central_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_top_k_central_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector with top k central node names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>k</strong> (<em>int</em><em>,</em>) – Number of central nodes to extract.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_total_edge_weights">
<span class="sig-name descname"><span class="pre">get_total_edge_weights</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_total_edge_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Return total edge weights, if graph has weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not contain edge weights.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_total_memory_used">
<span class="sig-name descname"><span class="pre">get_total_memory_used</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_total_memory_used" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns how many bytes are currently used to store the given graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_transitive_closure">
<span class="sig-name descname"><span class="pre">get_transitive_closure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_transitive_closure" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns graph to the i-th transitivity closure iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show a loading bar while building the graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_transitivity">
<span class="sig-name descname"><span class="pre">get_transitivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">low_centrality</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_transitivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns transitivity of the graph without taking into account weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>low_centrality</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The threshold over which to switch to parallel matryoshka. By default 50.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show a loading bar.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_trap_nodes_number">
<span class="sig-name descname"><span class="pre">get_trap_nodes_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_trap_nodes_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of traps (nodes without any outgoing edges that are not singletons)
This also includes nodes with only a self-loops, therefore singletons with
only a self-loops are not considered traps because you could make a walk on them.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_trap_nodes_rate">
<span class="sig-name descname"><span class="pre">get_trap_nodes_rate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_trap_nodes_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the traps rate of the graph.</p>
<p>THIS IS EXPERIMENTAL AND MUST BE PROVEN!</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_triads_number">
<span class="sig-name descname"><span class="pre">get_triads_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_triads_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns total number of triads in the graph without taking into account weights</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_adamic_adar_index_from_node_ids">
<span class="sig-name descname"><span class="pre">get_unchecked_adamic_adar_index_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination_node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_adamic_adar_index_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Adamic/Adar Index for the given pair of nodes from the given node IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the first node.</p></li>
<li><p><strong>destination_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the second node.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>If either of the provided one and two node IDs are higher than the</dt><dd><p>number of nodes in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_all_edge_metrics_from_node_ids">
<span class="sig-name descname"><span class="pre">get_unchecked_all_edge_metrics_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_all_edge_metrics_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all the implemented edge metrics for the two given node IDs.</p>
<p>Specifically, the returned values are:
* Adamic Adar
* Jaccard coefficient
* Resource allocation index
* Preferential attachment</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the first node.</p></li>
<li><p><strong>destination_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the second node.</p></li>
<li><p><strong>normalize</strong> (<em>bool</em><em>,</em>) – Whether to normalize within 0 to 1.</p></li>
</ul>
</dd>
</dl>
<p>If the given node IDs do not exist in the graph this method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_breadth_first_search_from_node_ids">
<span class="sig-name descname"><span class="pre">get_unchecked_breadth_first_search_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_predecessors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximal_depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_breadth_first_search_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector of minimum paths distances and vector of nodes predecessors, if requested.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_id</strong> (<em>int</em><em>,</em>) – Root of the tree of minimum paths.</p></li>
<li><p><strong>maybe_dst_node_id</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Optional target destination. If provided, Dijkstra will stop upon reaching this node.</p></li>
<li><p><strong>maybe_dst_node_ids</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em><em>,</em>) – Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.</p></li>
<li><p><strong>compute_distances</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to compute the vector of distances.</p></li>
<li><p><strong>compute_predecessors</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to compute the vector of predecessors.</p></li>
<li><p><strong>compute_visited</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to compute the vector of visited nodes.</p></li>
<li><p><strong>maximal_depth</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximal depth to execute the DFS for.</p></li>
</ul>
</dd>
</dl>
<p>If any of the given node IDs does not exist in the graph the method will panic.</p>
<blockquote>
<div><p>TODO! Explore chains accelerations!</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_closeness_centrality_from_node_id">
<span class="sig-name descname"><span class="pre">get_unchecked_closeness_centrality_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_closeness_centrality_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return closeness centrality of the requested node.</p>
<p>If the given node ID does not exist in the current graph the method
will panic.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_id</strong> (<em>int</em><em>,</em>) – The node ID whose closeness centrality is to be computed.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show an indicative progress bar.</p></li>
</ul>
</dd>
</dl>
<p>If the given node ID does not exist in the graph the method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_comulative_node_degree_from_node_id">
<span class="sig-name descname"><span class="pre">get_unchecked_comulative_node_degree_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_comulative_node_degree_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the comulative node degree up to the given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – Integer ID of the node.</p>
</dd>
</dl>
<p>If the given node ID does not exist in the current graph the method will raise a panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_destination_node_id_from_edge_id">
<span class="sig-name descname"><span class="pre">get_unchecked_destination_node_id_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_destination_node_id_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the destination of given edge id without making any boundary check.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – The edge ID whose destination is to be retrieved.</p>
</dd>
</dl>
<p>If the given edge ID does not exist in the current graph the method will cause an out of bounds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_destination_node_name_from_edge_id">
<span class="sig-name descname"><span class="pre">get_unchecked_destination_node_name_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_destination_node_name_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns destination node name corresponding to given edge ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – The edge ID whose destination node name is to be retrieved.</p>
</dd>
</dl>
<p>If the given edge ID does not exist in the current graph the method will raise a panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_dijkstra_from_node_ids">
<span class="sig-name descname"><span class="pre">get_unchecked_dijkstra_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maybe_dst_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maybe_dst_node_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_predecessors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximal_depth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_weights_as_probabilities</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_dijkstra_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector of minimum paths distances and vector of nodes predecessors, if requested.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_id</strong> (<em>int</em><em>,</em>) – Root of the tree of minimum paths.</p></li>
<li><p><strong>maybe_dst_node_id</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Optional target destination. If provided, Dijkstra will stop upon reaching this node.</p></li>
<li><p><strong>maybe_dst_node_ids</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em><em>,</em>) – Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.</p></li>
<li><p><strong>compute_predecessors</strong> (<em>bool</em><em>,</em>) – Whether to compute the vector of predecessors.</p></li>
<li><p><strong>maximal_depth</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximal number of iterations to execute Dijkstra for.</p></li>
<li><p><strong>use_edge_weights_as_probabilities</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to treat the edge weights as probabilities.</p></li>
</ul>
</dd>
</dl>
<p>If any of the given node IDs does not exist in the graph the method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_eccentricity_from_node_id">
<span class="sig-name descname"><span class="pre">get_unchecked_eccentricity_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_eccentricity_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unweighted eccentricity of the given node.</p>
<p>This method will panic if the given node ID does not exists in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – Node for which to compute the eccentricity.</p>
</dd>
</dl>
<p>If any of the given node IDs does not exist in the graph the method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_edge_count_from_edge_type_id">
<span class="sig-name descname"><span class="pre">get_unchecked_edge_count_from_edge_type_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_edge_count_from_edge_type_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of edges of the given edge type without checks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_type</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The edge type to retrieve count of.</p>
</dd>
</dl>
<p>If the given edge type ID does not exist in the graph the method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_edge_id_from_node_ids">
<span class="sig-name descname"><span class="pre">get_unchecked_edge_id_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_edge_id_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns edge ID corresponding to given source and destination node IDs.</p>
<p>The method will panic if the given source and destination node IDs do
not correspond to an edge in this graph instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> (<em>int</em><em>,</em>) – The source node ID.</p></li>
<li><p><strong>dst</strong> (<em>int</em><em>,</em>) – The destination node ID.</p></li>
</ul>
</dd>
</dl>
<p>If any of the given node IDs do not exist in the graph the method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_edge_id_from_node_ids_and_edge_type_id">
<span class="sig-name descname"><span class="pre">get_unchecked_edge_id_from_node_ids_and_edge_type_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_edge_id_from_node_ids_and_edge_type_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return edge ID without any checks for given tuple of nodes and edge type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> (<em>int</em><em>,</em>) – Source node of the edge.</p></li>
<li><p><strong>dst</strong> (<em>int</em><em>,</em>) – Destination node of the edge.</p></li>
<li><p><strong>edge_type</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Edge Type of the edge.</p></li>
</ul>
</dd>
</dl>
<p>If the given node IDs or edge type does not exists in the graph this method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_edge_type_id_from_edge_id">
<span class="sig-name descname"><span class="pre">get_unchecked_edge_type_id_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_edge_type_id_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns edge type of given edge.</p>
<p>This method will panic if the given edge ID is greater than
the number of edges in the graph.
Furthermore, if the graph does NOT have edge types, it will NOT
return neither an error or a panic.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – edge whose edge type is to be returned.</p>
</dd>
</dl>
<p>If the given edge ID does not exist in the current graph the method will raise a panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_edge_type_id_from_edge_type_name">
<span class="sig-name descname"><span class="pre">get_unchecked_edge_type_id_from_edge_type_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_edge_type_id_from_edge_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return edge type ID corresponding to the given edge type name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_type_name</strong> (<em>str</em><em>,</em>) – The edge type name whose edge type ID is to be returned.</p>
</dd>
</dl>
<p>If the given edge type name does not exists in the considered graph the method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_edge_type_name_from_edge_type_id">
<span class="sig-name descname"><span class="pre">get_unchecked_edge_type_name_from_edge_type_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_edge_type_name_from_edge_type_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return edge type ID corresponding to the given edge type name
raising panic if edge type ID does not exists in current graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_type_id</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The edge type naIDme whose edge type name is to be returned.</p>
</dd>
</dl>
<p>If the given edge type ID does not exist in the graph the method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_edge_weight_from_edge_id">
<span class="sig-name descname"><span class="pre">get_unchecked_edge_weight_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_edge_weight_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns option with the weight of the given edge id.</p>
<p>This method will raise a panic if the given edge ID is higher than
the number of edges in the graph. Additionally, it will simply
return None if there are no graph weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – The edge whose edge weight is to be returned.</p>
</dd>
</dl>
<p>If the given edge ID does not exists in the graph this method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_edge_weight_from_node_ids">
<span class="sig-name descname"><span class="pre">get_unchecked_edge_weight_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_edge_weight_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns option with the weight of the given node ids.</p>
<p>This method will raise a panic if the given node IDs are higher than
the number of nodes in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> (<em>int</em><em>,</em>) – The source node ID.</p></li>
<li><p><strong>dst</strong> (<em>int</em><em>,</em>) – The destination node ID.</p></li>
</ul>
</dd>
</dl>
<p>If either of the two given node IDs does not exists in the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_harmonic_centrality_from_node_id">
<span class="sig-name descname"><span class="pre">get_unchecked_harmonic_centrality_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_harmonic_centrality_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return harmonic centrality of the requested node.</p>
<p>If the given node ID does not exist in the current graph the method
will panic.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – The node ID whose harmonic centrality is to be computed.</p>
</dd>
</dl>
<p>If the given node ID does not exist in the graph the method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_jaccard_coefficient_from_node_ids">
<span class="sig-name descname"><span class="pre">get_unchecked_jaccard_coefficient_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination_node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_jaccard_coefficient_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Jaccard index for the two given nodes from the given node IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the first node.</p></li>
<li><p><strong>destination_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the second node.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>If either of the provided one and two node IDs are higher than the</dt><dd><p>number of nodes in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_k_shortest_path_node_ids_from_node_ids">
<span class="sig-name descname"><span class="pre">get_unchecked_k_shortest_path_node_ids_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_k_shortest_path_node_ids_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector of the k minimum paths node IDs between given source node and destination node ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_id</strong> (<em>int</em><em>,</em>) – Source node ID.</p></li>
<li><p><strong>dst_node_id</strong> (<em>int</em><em>,</em>) – Destination node ID.</p></li>
<li><p><strong>k</strong> (<em>int</em><em>,</em>) – Number of paths to find.</p></li>
</ul>
</dd>
</dl>
<p>If any of the given node IDs does not exist in the graph the method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_maximum_node_degree">
<span class="sig-name descname"><span class="pre">get_unchecked_maximum_node_degree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_maximum_node_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum node degree.</p>
<p>The method will return an undefined value (0) when the graph
does not contain nodes. In those cases the value is not properly
defined.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_maximum_preferential_attachment">
<span class="sig-name descname"><span class="pre">get_unchecked_maximum_preferential_attachment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_maximum_preferential_attachment" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum unweighted preferential attachment score.</p>
<p>If the graph does not contain nodes, the return value will be undefined.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_minimum_node_degree">
<span class="sig-name descname"><span class="pre">get_unchecked_minimum_node_degree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_minimum_node_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum node degree.</p>
<p>The method will return an undefined value (0) when the graph
does not contain nodes. In those cases the value is not properly
defined.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_minimum_preferential_attachment">
<span class="sig-name descname"><span class="pre">get_unchecked_minimum_preferential_attachment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_minimum_preferential_attachment" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the minumum unweighted preferential attachment score.</p>
<p>If the graph does not contain nodes, the return value will be undefined.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_minmax_edge_ids_from_node_ids">
<span class="sig-name descname"><span class="pre">get_unchecked_minmax_edge_ids_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_minmax_edge_ids_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return range of outbound edges IDs for all the edges bewteen the given
source and destination nodes.
This operation is meaningfull only in a multigraph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> (<em>int</em><em>,</em>) – Source node.</p></li>
<li><p><strong>dst</strong> (<em>int</em><em>,</em>) – Destination node.</p></li>
</ul>
</dd>
</dl>
<p>If the given node type IDs do not exist in the graph this method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_minmax_edge_ids_from_source_node_id">
<span class="sig-name descname"><span class="pre">get_unchecked_minmax_edge_ids_from_source_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_minmax_edge_ids_from_source_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return range of outbound edges IDs which have as source the given Node.</p>
<p>The method will panic if the given source node ID is higher than
the number of nodes in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>src</strong> (<em>int</em><em>,</em>) – Node for which we need to compute the cumulative_node_degrees range.</p>
</dd>
</dl>
<p>If the given node ID does not exist in the current graph the method will raise a panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_most_central_node_id">
<span class="sig-name descname"><span class="pre">get_unchecked_most_central_node_id</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_most_central_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns maximum node degree of the graph.</p>
<p>This method fails with a panic if the graph does not have any node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_node_degree_from_node_id">
<span class="sig-name descname"><span class="pre">get_unchecked_node_degree_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_node_degree_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of outbound neighbours of given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – Integer ID of the node.</p>
</dd>
</dl>
<p>If the given node ID does not exist in the current graph the method will raise a panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_node_id_from_node_name">
<span class="sig-name descname"><span class="pre">get_unchecked_node_id_from_node_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_node_id_from_node_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns node id from given node name raising a panic if used unproperly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_name</strong> (<em>str</em><em>,</em>) – The node name whose node ID is to be returned.</p>
</dd>
</dl>
<p>If the given node name does not exists in the considered graph the method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id">
<span class="sig-name descname"><span class="pre">get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the src, dst, edge type and weight of a given edge ID.</p>
<p>This method will raise a panic when an improper configuration is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – The edge ID whose source, destination, edge type and weight are to be retrieved.</p>
</dd>
</dl>
<p>If the given edge ID does not exist in the current graph the method will raise a panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_node_ids_and_edge_type_id_from_edge_id">
<span class="sig-name descname"><span class="pre">get_unchecked_node_ids_and_edge_type_id_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_node_ids_and_edge_type_id_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the src, dst, edge type of a given edge ID.</p>
<p>This method will raise a panic when an improper configuration is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – The edge ID whose source, destination and edge type are to be retrieved.</p>
</dd>
</dl>
<p>If the given edge ID does not exist in the current graph the method will raise a panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_node_ids_from_edge_id">
<span class="sig-name descname"><span class="pre">get_unchecked_node_ids_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_node_ids_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns node IDs corresponding to given edge ID.</p>
<p>The method will panic if the given edge ID does not exists in the
current graph instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – The edge ID whose source and destination node IDs are to e retrieved.</p>
</dd>
</dl>
<p>If the given edge ID does not exist in the current graph the method will raise a panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_node_name_from_node_id">
<span class="sig-name descname"><span class="pre">get_unchecked_node_name_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_node_name_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns result with the node name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – The node ID whose name is to be returned.</p>
</dd>
</dl>
<p>If the given node ID does not exist in the current graph the method will raise a panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_node_names_from_edge_id">
<span class="sig-name descname"><span class="pre">get_unchecked_node_names_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_node_names_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns node names corresponding to given edge ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – The edge ID whose source and destination node IDs are to e retrieved.</p>
</dd>
</dl>
<p>If the given edge ID does not exist in the current graph the method will raise a panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_node_type_id_from_node_id">
<span class="sig-name descname"><span class="pre">get_unchecked_node_type_id_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_node_type_id_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns option with vector of node types of given node.</p>
<p>This method will panic if the given node ID is greater than
the number of nodes in the graph.
Furthermore, if the graph does NOT have node types, it will NOT
return neither an error or a panic.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – node whose node type is to be returned.</p>
</dd>
</dl>
<dl class="simple">
<dt>Even though the method will return an option when the node types are</dt><dd><p>not available for the current graph, the behaviour is undefined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_node_type_names_from_node_id">
<span class="sig-name descname"><span class="pre">get_unchecked_node_type_names_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_node_type_names_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns result of option with the node type of the given node id.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – The node ID whose node types are to be returned.</p>
</dd>
</dl>
<dl class="simple">
<dt>This method will return an iterator of None values when the graph</dt><dd><p>does not contain node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_node_type_names_from_node_type_ids">
<span class="sig-name descname"><span class="pre">get_unchecked_node_type_names_from_node_type_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_type_ids</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_node_type_names_from_node_type_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return node type name of given node type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_type_ids</strong> (<em>List</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Id of the node type.</p>
</dd>
</dl>
<p>The method will panic if the graph does not contain node types.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_preferential_attachment_from_node_ids">
<span class="sig-name descname"><span class="pre">get_unchecked_preferential_attachment_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_preferential_attachment_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unweighted preferential attachment from the given node IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the first node.</p></li>
<li><p><strong>destination_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the second node.</p></li>
<li><p><strong>normalize</strong> (<em>bool</em><em>,</em>) – Whether to normalize within 0 to 1.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>If either of the provided one and two node IDs are higher than the</dt><dd><p>number of nodes in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_resource_allocation_index_from_node_ids">
<span class="sig-name descname"><span class="pre">get_unchecked_resource_allocation_index_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination_node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_resource_allocation_index_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the first node.</p></li>
<li><p><strong>destination_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the second node.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>If either of the provided one and two node IDs are higher than the</dt><dd><p>number of nodes in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_shortest_path_node_ids_from_node_ids">
<span class="sig-name descname"><span class="pre">get_unchecked_shortest_path_node_ids_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximal_depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_shortest_path_node_ids_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns minimum path node IDs and distance from given node ids.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_id</strong> (<em>int</em><em>,</em>) – Source node ID.</p></li>
<li><p><strong>dst_node_id</strong> (<em>int</em><em>,</em>) – Destination node ID.</p></li>
<li><p><strong>maximal_depth</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximal depth to execute the BFS for.</p></li>
</ul>
</dd>
</dl>
<p>If any of the given node IDs does not exist in the graph the method will panic.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – If the given node is a selfloop.</p></li>
<li><p><strong>ValueError</strong> – If there is no path between the two given nodes.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_shortest_path_node_names_from_node_ids">
<span class="sig-name descname"><span class="pre">get_unchecked_shortest_path_node_names_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximal_depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_shortest_path_node_names_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns minimum path node names from given node ids.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_id</strong> (<em>int</em><em>,</em>) – Source node ID.</p></li>
<li><p><strong>dst_node_id</strong> (<em>int</em><em>,</em>) – Destination node ID.</p></li>
<li><p><strong>maximal_depth</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximal depth to execute the BFS for.</p></li>
</ul>
</dd>
</dl>
<p>If any of the given node IDs does not exist in the graph the method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_source_node_id_from_edge_id">
<span class="sig-name descname"><span class="pre">get_unchecked_source_node_id_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_source_node_id_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the source of given edge id without making any boundary check.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – The edge ID whose source is to be retrieved.</p>
</dd>
</dl>
<p>If the given edge ID does not exist in the current graph the method will cause an out of bounds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_source_node_name_from_edge_id">
<span class="sig-name descname"><span class="pre">get_unchecked_source_node_name_from_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_source_node_name_from_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns source node name corresponding to given edge ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – The edge ID whose source node name is to be retrieved.</p>
</dd>
</dl>
<p>If the given edge ID does not exist in the current graph the method will raise a panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_unique_source_node_id">
<span class="sig-name descname"><span class="pre">get_unchecked_unique_source_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_unique_source_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns edge ID corresponding to given source and destination node IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>source_id</strong> (<em>int</em><em>,</em>) – The source node ID.</p>
</dd>
</dl>
<p>If the given source node ID does not exist in the current graph the method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_weighted_closeness_centrality_from_node_id">
<span class="sig-name descname"><span class="pre">get_unchecked_weighted_closeness_centrality_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_weights_as_probabilities</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_weighted_closeness_centrality_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return closeness centrality of the requested node.</p>
<p>If the given node ID does not exist in the current graph the method
will panic.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_id</strong> (<em>int</em><em>,</em>) – The node ID whose closeness centrality is to be computed.</p></li>
<li><p><strong>use_edge_weights_as_probabilities</strong> (<em>bool</em><em>,</em>) – Whether to treat the edge weights as probabilities.</p></li>
</ul>
</dd>
</dl>
<p>If the given node ID does not exist in the graph the method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_weighted_eccentricity_from_node_id">
<span class="sig-name descname"><span class="pre">get_unchecked_weighted_eccentricity_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_weights_as_probabilities</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_weighted_eccentricity_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns weighted eccentricity of the given node.</p>
<p>This method will panic if the given node ID does not exists in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_id</strong> (<em>int</em><em>,</em>) – Node for which to compute the eccentricity.</p></li>
<li><p><strong>use_edge_weights_as_probabilities</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to treat the edge weights as probabilities.</p></li>
</ul>
</dd>
</dl>
<p>If any of the given node IDs does not exist in the graph the method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_weighted_harmonic_centrality_from_node_id">
<span class="sig-name descname"><span class="pre">get_unchecked_weighted_harmonic_centrality_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_weights_as_probabilities</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_weighted_harmonic_centrality_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return harmonic centrality of the requested node.</p>
<p>If the given node ID does not exist in the current graph the method
will panic.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_id</strong> (<em>int</em><em>,</em>) – The node ID whose harmonic centrality is to be computed.</p></li>
<li><p><strong>use_edge_weights_as_probabilities</strong> (<em>bool</em><em>,</em>) – Whether to treat the edge weights as probabilities.</p></li>
</ul>
</dd>
</dl>
<p>If the given node ID does not exist in the graph the method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_weighted_maximum_preferential_attachment">
<span class="sig-name descname"><span class="pre">get_unchecked_weighted_maximum_preferential_attachment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_weighted_maximum_preferential_attachment" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum weighted preferential attachment score.</p>
<p>If the graph does not contain nodes, the return value will be undefined.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_weighted_minimum_preferential_attachment">
<span class="sig-name descname"><span class="pre">get_unchecked_weighted_minimum_preferential_attachment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_weighted_minimum_preferential_attachment" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the minumum weighted preferential attachment score.</p>
<p>If the graph does not contain nodes, the return value will be undefined.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_weighted_node_degree_from_node_id">
<span class="sig-name descname"><span class="pre">get_unchecked_weighted_node_degree_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_weighted_node_degree_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the weighted sum of outbound neighbours of given node.</p>
<p>The method will panic if the given node id is higher than the number of
nodes in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – Integer ID of the node.</p>
</dd>
</dl>
<p>If the given node ID does not exist in the current graph the method will raise a panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_weighted_preferential_attachment_from_node_ids">
<span class="sig-name descname"><span class="pre">get_unchecked_weighted_preferential_attachment_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_weighted_preferential_attachment_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the weighted preferential attachment from the given node IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the first node.</p></li>
<li><p><strong>destination_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the second node.</p></li>
<li><p><strong>normalize</strong> (<em>bool</em><em>,</em>) – Whether to normalize within 0 to 1.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>If either of the provided one and two node IDs are higher than the</dt><dd><p>number of nodes in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_weighted_resource_allocation_index_from_node_ids">
<span class="sig-name descname"><span class="pre">get_unchecked_weighted_resource_allocation_index_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination_node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_weighted_resource_allocation_index_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the weighted Resource Allocation Index for the given pair of nodes from the given node IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the first node.</p></li>
<li><p><strong>destination_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the second node.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>If either of the provided one and two node IDs are higher than the</dt><dd><p>number of nodes in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_weighted_shortest_path_node_ids_from_node_ids">
<span class="sig-name descname"><span class="pre">get_unchecked_weighted_shortest_path_node_ids_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_weights_as_probabilities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximal_depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_weighted_shortest_path_node_ids_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns minimum path node IDs and distance from given node ids.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_id</strong> (<em>int</em><em>,</em>) – Source node ID.</p></li>
<li><p><strong>dst_node_id</strong> (<em>int</em><em>,</em>) – Destination node ID.</p></li>
<li><p><strong>maximal_depth</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximal depth to execute the BFS for.</p></li>
<li><p><strong>use_edge_weights_as_probabilities</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to treat the edge weights as probabilities.</p></li>
<li><p><strong>maximal_depth</strong> – The maximal number of iterations to execute Dijkstra for.</p></li>
</ul>
</dd>
</dl>
<p>If any of the given node IDs does not exist in the graph the method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unchecked_weighted_shortest_path_node_names_from_node_ids">
<span class="sig-name descname"><span class="pre">get_unchecked_weighted_shortest_path_node_names_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_weights_as_probabilities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximal_depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unchecked_weighted_shortest_path_node_names_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns minimum path node names from given node ids.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_id</strong> (<em>int</em><em>,</em>) – Source node ID.</p></li>
<li><p><strong>dst_node_id</strong> (<em>int</em><em>,</em>) – Destination node ID.</p></li>
<li><p><strong>maximal_depth</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximal depth to execute the BFS for.</p></li>
<li><p><strong>use_edge_weights_as_probabilities</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to treat the edge weights as probabilities.</p></li>
<li><p><strong>maximal_depth</strong> – The maximal number of iterations to execute Dijkstra for.</p></li>
</ul>
</dd>
</dl>
<p>If any of the given node IDs does not exist in the graph the method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_undirected_edges_number">
<span class="sig-name descname"><span class="pre">get_undirected_edges_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_undirected_edges_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of undirected edges of the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_undirected_louvain_community_detection">
<span class="sig-name descname"><span class="pre">get_undirected_louvain_community_detection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">recursion_minimum_improvement</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_phase_minimum_improvement</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patience</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_undirected_louvain_community_detection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector of vectors of communities for each layer of hierarchy minimizing undirected modularity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>recursion_minimum_improvement</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – The minimum improvement to warrant another resursion round. By default, zero.</p></li>
<li><p><strong>first_phase_minimum_improvement</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – The minimum improvement to warrant another first phase iteration. By default, <cite>0.00001</cite> (not zero because of numerical instability).</p></li>
<li><p><strong>patience</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – How many iterations of the first phase to wait for before stopping. By default, <cite>5</cite>.</p></li>
<li><p><strong>random_state</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The random state to use to reproduce this modularity computation. By default, 42.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph is not directed.</p></li>
<li><p><strong>ValueError</strong> – If the <cite>recursion_minimum_improvement</cite> has an invalid value, i.e. NaN or infinity.</p></li>
<li><p><strong>ValueError</strong> – If the <cite>first_phase_minimum_improvement</cite> has an invalid value, i.e. NaN or infinity.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_undirected_modularity_from_node_community_memberships">
<span class="sig-name descname"><span class="pre">get_undirected_modularity_from_node_community_memberships</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_community_memberships</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_undirected_modularity_from_node_community_memberships" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the undirected modularity of the graph from the given memberships.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the number of provided memberships does not match the number of nodes of the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_uniform_random_walk_random_nodes">
<span class="sig-name descname"><span class="pre">get_uniform_random_walk_random_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">walk_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unique</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_uniform_random_walk_random_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unique nodes sampled from uniform random walk.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<em>int</em><em>,</em>) – Node from where to start the random walks.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>,</em>) – the random_state to use for extracting the nodes and edges.</p></li>
<li><p><strong>walk_length</strong> (<em>int</em><em>,</em>) – Length of the random walk.</p></li>
<li><p><strong>unique</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to make the sampled nodes unique.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the given node does not exist in the current slack.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unique_directed_edges_number">
<span class="sig-name descname"><span class="pre">get_unique_directed_edges_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unique_directed_edges_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of the unique edges in the graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unique_edge_type_ids">
<span class="sig-name descname"><span class="pre">get_unique_edge_type_ids</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unique_edge_type_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unique edge type IDs of the graph edges.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unique_edge_type_names">
<span class="sig-name descname"><span class="pre">get_unique_edge_type_names</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unique_edge_type_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the edge types names</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unique_edges_number">
<span class="sig-name descname"><span class="pre">get_unique_edges_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unique_edges_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of unique edges of the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unique_node_type_ids">
<span class="sig-name descname"><span class="pre">get_unique_node_type_ids</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unique_node_type_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unique node type IDs of the graph nodes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unique_node_type_names">
<span class="sig-name descname"><span class="pre">get_unique_node_type_names</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unique_node_type_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unique node types names.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unique_selfloops_number">
<span class="sig-name descname"><span class="pre">get_unique_selfloops_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unique_selfloops_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of unique self-loops, excluding those in eventual multi-edges.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unique_source_nodes_number">
<span class="sig-name descname"><span class="pre">get_unique_source_nodes_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unique_source_nodes_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of the source nodes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unique_undirected_edges_number">
<span class="sig-name descname"><span class="pre">get_unique_undirected_edges_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unique_undirected_edges_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of undirected edges of the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unknown_edge_types_number">
<span class="sig-name descname"><span class="pre">get_unknown_edge_types_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unknown_edge_types_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of unknown edge types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no edge types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unknown_edge_types_rate">
<span class="sig-name descname"><span class="pre">get_unknown_edge_types_rate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unknown_edge_types_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns rate of unknown edge types over total edges number.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no edge types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unknown_node_types_mask">
<span class="sig-name descname"><span class="pre">get_unknown_node_types_mask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unknown_node_types_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean mask of unknown node types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unknown_node_types_number">
<span class="sig-name descname"><span class="pre">get_unknown_node_types_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unknown_node_types_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of nodes with unknown node type.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no node types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_unknown_node_types_rate">
<span class="sig-name descname"><span class="pre">get_unknown_node_types_rate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_unknown_node_types_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns rate of unknown node types over total nodes number.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If there are no node types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_all_shortest_paths">
<span class="sig-name descname"><span class="pre">get_weighted_all_shortest_paths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_weights_as_probabilities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_all_shortest_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns graph with weighted shortest paths computed up to the given depth.</p>
<p>The returned graph will have no selfloops.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.</p></li>
<li><p><strong>use_edge_weights_as_probabilities</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to treat the edge weights as probabilities.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show a loading bar while building the graph.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have weights.</p></li>
<li><p><strong>ValueError</strong> – If the graph contains negative weights.</p></li>
<li><p><strong>ValueError</strong> – If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_closeness_centrality">
<span class="sig-name descname"><span class="pre">get_weighted_closeness_centrality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">use_edge_weights_as_probabilities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_closeness_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Return closeness centrality for all nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>use_edge_weights_as_probabilities</strong> (<em>bool</em><em>,</em>) – Whether to treat the edge weights as probabilities.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show an indicative progress bar.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have weights.</p></li>
<li><p><strong>ValueError</strong> – If the graph contains negative weights.</p></li>
<li><p><strong>ValueError</strong> – If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_degree_centrality">
<span class="sig-name descname"><span class="pre">get_weighted_degree_centrality</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_degree_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector of weighted degree centrality for all nodes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_diameter_naive">
<span class="sig-name descname"><span class="pre">get_weighted_diameter_naive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ignore_infinity</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_weights_as_probabilities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_diameter_naive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns diameter of the graph using naive method.</p>
<p>Note that there exists the non-naive method for undirected graphs
and it is possible to implement a faster method for directed graphs
but we still need to get to it, as it will require an updated
succinct data structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ignore_infinity</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to ignore infinite distances, which are present when in the graph exist multiple components.</p></li>
<li><p><strong>use_edge_weights_as_probabilities</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to treat the edge weights as probabilities.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show a loading bar.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not contain nodes.</p></li>
<li><p><strong>ValueError</strong> – If the graph does not have weights.</p></li>
<li><p><strong>ValueError</strong> – If the graph contains negative weights.</p></li>
<li><p><strong>ValueError</strong> – If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_eccentricity_from_node_id">
<span class="sig-name descname"><span class="pre">get_weighted_eccentricity_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_weights_as_probabilities</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_eccentricity_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns weighted eccentricity of the given node ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_id</strong> (<em>int</em><em>,</em>) – Node for which to compute the eccentricity.</p></li>
<li><p><strong>use_edge_weights_as_probabilities</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to treat the edge weights as probabilities.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the given node ID does not exist in the graph.</p></li>
<li><p><strong>ValueError</strong> – If weights are requested to be treated as probabilities but are not between 0 and 1.</p></li>
<li><p><strong>ValueError</strong> – If the graph contains negative weights.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_eccentricity_from_node_name">
<span class="sig-name descname"><span class="pre">get_weighted_eccentricity_from_node_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_weights_as_probabilities</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_eccentricity_from_node_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns weighted eccentricity of the given node name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_name</strong> (<em>str</em><em>,</em>) – Node for which to compute the eccentricity.</p></li>
<li><p><strong>use_edge_weights_as_probabilities</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to treat the edge weights as probabilities.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the given node name does not exist in the graph.</p></li>
<li><p><strong>ValueError</strong> – If weights are requested to be treated as probabilities but are not between 0 and 1.</p></li>
<li><p><strong>ValueError</strong> – If the graph contains negative weights.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_eigenvector_centrality">
<span class="sig-name descname"><span class="pre">get_weighted_eigenvector_centrality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">maximum_iterations_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tollerance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_eigenvector_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns vector with unweighted eigenvector centrality.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maximum_iterations_number</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximum number of iterations to consider.</p></li>
<li><p><strong>tollerance</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em><em>,</em>) – The maximum error tollerance for convergence.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_harmonic_centrality">
<span class="sig-name descname"><span class="pre">get_weighted_harmonic_centrality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">use_edge_weights_as_probabilities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_harmonic_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Return harmonic centrality for all nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>use_edge_weights_as_probabilities</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to treat the edge weights as probabilities.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show an indicative progress bar.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_maximum_node_degree">
<span class="sig-name descname"><span class="pre">get_weighted_maximum_node_degree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_maximum_node_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum weighted node degree</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_minimum_node_degree">
<span class="sig-name descname"><span class="pre">get_weighted_minimum_node_degree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_minimum_node_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum weighted node degree</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_node_degree_from_node_id">
<span class="sig-name descname"><span class="pre">get_weighted_node_degree_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_node_degree_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the weighted sum of outbound neighbours of given node ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – Integer ID of the node.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_node_degrees">
<span class="sig-name descname"><span class="pre">get_weighted_node_degrees</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_node_degrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the weighted degree of every node in the graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_node_degrees_mean">
<span class="sig-name descname"><span class="pre">get_weighted_node_degrees_mean</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_node_degrees_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns weighted mean node degree of the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_node_degrees_median">
<span class="sig-name descname"><span class="pre">get_weighted_node_degrees_median</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_node_degrees_median" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns weighted median node degree of the graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_node_indegrees">
<span class="sig-name descname"><span class="pre">get_weighted_node_indegrees</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_node_indegrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the weighted indegree (total weighted inbound edge weights) for each node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_preferential_attachment_from_node_ids">
<span class="sig-name descname"><span class="pre">get_weighted_preferential_attachment_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_preferential_attachment_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the weighted preferential attachment from the given node IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the first node.</p></li>
<li><p><strong>destination_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the second node.</p></li>
<li><p><strong>normalize</strong> (<em>bool</em><em>,</em>) – Whether to normalize by the square of maximum degree.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If either of the node IDs are higher than the number of nodes in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_preferential_attachment_from_node_names">
<span class="sig-name descname"><span class="pre">get_weighted_preferential_attachment_from_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_preferential_attachment_from_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the weighted preferential attachment from the given node names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>first_node_name</strong> (<em>str</em><em>,</em>) – Node name of the first node.</p></li>
<li><p><strong>second_node_name</strong> (<em>str</em><em>,</em>) – Node name of the second node.</p></li>
<li><p><strong>normalize</strong> (<em>bool</em><em>,</em>) – Whether to normalize by the square of maximum degree.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If either of the given node names do not exist in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_resource_allocation_index_from_node_ids">
<span class="sig-name descname"><span class="pre">get_weighted_resource_allocation_index_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination_node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_resource_allocation_index_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the weighted Resource Allocation Index for the given pair of nodes from the given node IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the first node.</p></li>
<li><p><strong>destination_node_id</strong> (<em>int</em><em>,</em>) – Node ID of the second node.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If either of the node IDs are higher than the number of nodes in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_resource_allocation_index_from_node_names">
<span class="sig-name descname"><span class="pre">get_weighted_resource_allocation_index_from_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second_node_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_resource_allocation_index_from_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the weighted Resource Allocation Index for the given pair of nodes from the given node names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>first_node_name</strong> (<em>str</em><em>,</em>) – Node name of the first node.</p></li>
<li><p><strong>second_node_name</strong> (<em>str</em><em>,</em>) – Node name of the second node.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If either of the given node names do not exist in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_shortest_path_node_ids_from_node_ids">
<span class="sig-name descname"><span class="pre">get_weighted_shortest_path_node_ids_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_node_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_weights_as_probabilities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximal_depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_shortest_path_node_ids_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns minimum path node names from given node ids.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_id</strong> (<em>int</em><em>,</em>) – Source node ID.</p></li>
<li><p><strong>dst_node_id</strong> (<em>int</em><em>,</em>) – Destination node ID.</p></li>
<li><p><strong>maximal_depth</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximal depth to execute the BFS for.</p></li>
<li><p><strong>use_edge_weights_as_probabilities</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to treat the edge weights as probabilities.</p></li>
<li><p><strong>maximal_depth</strong> – The maximal number of iterations to execute Dijkstra for.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If any of the given node IDs do not exist in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_shortest_path_node_ids_from_node_names">
<span class="sig-name descname"><span class="pre">get_weighted_shortest_path_node_ids_from_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_weights_as_probabilities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximal_depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_shortest_path_node_ids_from_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns minimum path node names from given node names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_name</strong> (<em>str</em><em>,</em>) – Source node name.</p></li>
<li><p><strong>dst_node_name</strong> (<em>str</em><em>,</em>) – Destination node name.</p></li>
<li><p><strong>use_edge_weights_as_probabilities</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to treat the edge weights as probabilities.</p></li>
<li><p><strong>maximal_depth</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximal number of iterations to execute Dijkstra for.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If any of the given node names do not exist in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_shortest_path_node_names_from_node_names">
<span class="sig-name descname"><span class="pre">get_weighted_shortest_path_node_names_from_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_edge_weights_as_probabilities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximal_depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_shortest_path_node_names_from_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns minimum path node names from given node names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_name</strong> (<em>str</em><em>,</em>) – Source node name.</p></li>
<li><p><strong>dst_node_name</strong> (<em>str</em><em>,</em>) – Destination node name.</p></li>
<li><p><strong>use_edge_weights_as_probabilities</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to treat the edge weights as probabilities.</p></li>
<li><p><strong>maximal_depth</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The maximal number of iterations to execute Dijkstra for.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If any of the given node names do not exist in the current graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_singleton_nodes_number">
<span class="sig-name descname"><span class="pre">get_weighted_singleton_nodes_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_singleton_nodes_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of weighted singleton nodes, i.e. nodes with weighted node degree equal to zero</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_top_k_central_node_ids">
<span class="sig-name descname"><span class="pre">get_weighted_top_k_central_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_top_k_central_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return vector with weighted top k central node Ids.</p>
<p>If the k passed is bigger than the number of nodes this method will return
all the nodes in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>k</strong> (<em>int</em><em>,</em>) – Number of central nodes to extract.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the current graph instance does not contain edge weights.</p></li>
<li><p><strong>ValueError</strong> – If the given value k is zero.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.get_weighted_triads_number">
<span class="sig-name descname"><span class="pre">get_weighted_triads_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.get_weighted_triads_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns total number of triads in the weighted graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_constant_edge_weights">
<span class="sig-name descname"><span class="pre">has_constant_edge_weights</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_constant_edge_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the graph has constant weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not contain edge weights.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_default_graph_name">
<span class="sig-name descname"><span class="pre">has_default_graph_name</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_default_graph_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if graph has name that is not the default one.</p>
<p>TODO: use a default for the default graph name</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_disconnected_nodes">
<span class="sig-name descname"><span class="pre">has_disconnected_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_disconnected_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing if nodes which are nor singletons nor
singletons with selfloops.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_edge_from_node_ids">
<span class="sig-name descname"><span class="pre">has_edge_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_edge_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether edge passing between given node ids exists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> (<em>int</em><em>,</em>) – Source node id.</p></li>
<li><p><strong>dst</strong> (<em>int</em><em>,</em>) – Destination node id.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_edge_from_node_ids_and_edge_type_id">
<span class="sig-name descname"><span class="pre">has_edge_from_node_ids_and_edge_type_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_edge_from_node_ids_and_edge_type_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether edge with the given type passing between given nodes exists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src</strong> (<em>int</em><em>,</em>) – The source node of the edge.</p></li>
<li><p><strong>dst</strong> (<em>int</em><em>,</em>) – The destination node of the edge.</p></li>
<li><p><strong>edge_type</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The (optional) edge type.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_edge_from_node_names">
<span class="sig-name descname"><span class="pre">has_edge_from_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_edge_from_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether if edge passing between given nodes exists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_name</strong> (<em>str</em><em>,</em>) – The source node name of the edge.</p></li>
<li><p><strong>dst_name</strong> (<em>str</em><em>,</em>) – The destination node name of the edge.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_edge_from_node_names_and_edge_type_name">
<span class="sig-name descname"><span class="pre">has_edge_from_node_names_and_edge_type_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_edge_from_node_names_and_edge_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether if edge with type passing between given nodes exists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_name</strong> (<em>str</em><em>,</em>) – The source node name of the edge.</p></li>
<li><p><strong>dst_name</strong> (<em>str</em><em>,</em>) – The destination node name of the edge.</p></li>
<li><p><strong>edge_type_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The (optional) edge type name.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_edge_type_id">
<span class="sig-name descname"><span class="pre">has_edge_type_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_edge_type_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the graph has the given edge type id.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_type_id</strong> (<em>int</em><em>,</em>) – id of the edge.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_edge_type_name">
<span class="sig-name descname"><span class="pre">has_edge_type_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_edge_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the graph has the given edge type name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_type_name</strong> (<em>str</em><em>,</em>) – Name of the edge.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_edge_types">
<span class="sig-name descname"><span class="pre">has_edge_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing whether graph has edge types.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_edge_types_oddities">
<span class="sig-name descname"><span class="pre">has_edge_types_oddities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_edge_types_oddities" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the graph has any known edge type-related graph oddities.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have edge types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_edge_weights">
<span class="sig-name descname"><span class="pre">has_edge_weights</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_edge_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing whether graph has weights.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_edge_weights_representing_probabilities">
<span class="sig-name descname"><span class="pre">has_edge_weights_representing_probabilities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_edge_weights_representing_probabilities" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether graph has weights that can represent probabilities</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_edges">
<span class="sig-name descname"><span class="pre">has_edges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if the graph has any edges.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_homogeneous_edge_types">
<span class="sig-name descname"><span class="pre">has_homogeneous_edge_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_homogeneous_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the edges have an homogenous edge type.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have edge types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_homogeneous_node_types">
<span class="sig-name descname"><span class="pre">has_homogeneous_node_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_homogeneous_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the nodes have an homogenous node type.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_known_edge_types">
<span class="sig-name descname"><span class="pre">has_known_edge_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_known_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether there are known edge types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have edge types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_known_node_types">
<span class="sig-name descname"><span class="pre">has_known_node_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_known_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether there are known node types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_multilabel_node_types">
<span class="sig-name descname"><span class="pre">has_multilabel_node_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_multilabel_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing if graph has multilabel node types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_negative_edge_weights">
<span class="sig-name descname"><span class="pre">has_negative_edge_weights</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_negative_edge_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing whether graph has negative weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not contain weights.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_node_name">
<span class="sig-name descname"><span class="pre">has_node_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_node_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the graph has the given node name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_name</strong> (<em>str</em><em>,</em>) – Name of the node.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_node_name_and_node_type_name">
<span class="sig-name descname"><span class="pre">has_node_name_and_node_type_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_node_name_and_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the given node name and node type name exist in current graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_name</strong> (<em>str</em><em>,</em>) – The node name.</p></li>
<li><p><strong>node_type_name</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – The node types name.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_node_oddities">
<span class="sig-name descname"><span class="pre">has_node_oddities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_node_oddities" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the graph has any known node-related graph oddities</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_node_type_id">
<span class="sig-name descname"><span class="pre">has_node_type_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_type_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_node_type_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the graph has the given node type id.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_type_id</strong> (<em>int</em><em>,</em>) – id of the node.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_node_type_name">
<span class="sig-name descname"><span class="pre">has_node_type_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_type_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the graph has the given node type name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_type_name</strong> (<em>str</em><em>,</em>) – Name of the node.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_node_types">
<span class="sig-name descname"><span class="pre">has_node_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing if graph has node types</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_node_types_oddities">
<span class="sig-name descname"><span class="pre">has_node_types_oddities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_node_types_oddities" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the graph has any known node type-related graph oddities.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_nodes">
<span class="sig-name descname"><span class="pre">has_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if the graph has any nodes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_nodes_sorted_by_decreasing_outbound_node_degree">
<span class="sig-name descname"><span class="pre">has_nodes_sorted_by_decreasing_outbound_node_degree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_nodes_sorted_by_decreasing_outbound_node_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the node IDs are sorted by decreasing outbound node degree.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_nodes_sorted_by_increasing_outbound_node_degree">
<span class="sig-name descname"><span class="pre">has_nodes_sorted_by_increasing_outbound_node_degree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_nodes_sorted_by_increasing_outbound_node_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the node IDs are sorted by increasing outbound node degree.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_nodes_sorted_by_lexicographic_order">
<span class="sig-name descname"><span class="pre">has_nodes_sorted_by_lexicographic_order</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_nodes_sorted_by_lexicographic_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the node IDs are sorted by decreasing outbound node degree.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_same_adjacency_matrix">
<span class="sig-name descname"><span class="pre">has_same_adjacency_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_same_adjacency_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if the graphs share the same adjacency matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#grape.ensmallen.Graph" title="grape.ensmallen.Graph"><em>Graph</em></a><em>,</em>) – The other graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_selfloop_from_node_id">
<span class="sig-name descname"><span class="pre">has_selfloop_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_selfloop_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the given node ID has a selfloop.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – Source node id.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_selfloops">
<span class="sig-name descname"><span class="pre">has_selfloops</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_selfloops" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing if graph has self-loops.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_singleton_edge_types">
<span class="sig-name descname"><span class="pre">has_singleton_edge_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_singleton_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether there is at least singleton edge type, that is a edge type that only appears once.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have edge types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_singleton_node_types">
<span class="sig-name descname"><span class="pre">has_singleton_node_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_singleton_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether there is at least singleton node type, that is a node type that only appears once.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_singleton_nodes">
<span class="sig-name descname"><span class="pre">has_singleton_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_singleton_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing if graph has singletons.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_singleton_nodes_with_selfloops">
<span class="sig-name descname"><span class="pre">has_singleton_nodes_with_selfloops</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_singleton_nodes_with_selfloops" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing if graph has singletons</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_trap_nodes">
<span class="sig-name descname"><span class="pre">has_trap_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_trap_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the graph has trap nodes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_unknown_edge_types">
<span class="sig-name descname"><span class="pre">has_unknown_edge_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_unknown_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether there are unknown edge types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_unknown_node_types">
<span class="sig-name descname"><span class="pre">has_unknown_node_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_unknown_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether there are unknown node types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.has_weighted_singleton_nodes">
<span class="sig-name descname"><span class="pre">has_weighted_singleton_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.has_weighted_singleton_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether a graph has one or more weighted singleton nodes.</p>
<p>A weighted singleton node is a node whose weighted node degree is 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not contain edge weights.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.is_compatible">
<span class="sig-name descname"><span class="pre">is_compatible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.is_compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if the graphs are compatible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#grape.ensmallen.Graph" title="grape.ensmallen.Graph"><em>Graph</em></a><em>,</em>) – The other graph.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If a graph is directed and the other is undirected.</p></li>
<li><p><strong>ValueError</strong> – If one of the two graphs has edge weights and the other does not.</p></li>
<li><p><strong>ValueError</strong> – If one of the two graphs has node types and the other does not.</p></li>
<li><p><strong>ValueError</strong> – If one of the two graphs has edge types and the other does not.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.is_connected">
<span class="sig-name descname"><span class="pre">is_connected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.is_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the graph is connected.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show the loading bar while computing the connected components, if necessary.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.is_directed">
<span class="sig-name descname"><span class="pre">is_directed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.is_directed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing if graph is directed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.is_multigraph">
<span class="sig-name descname"><span class="pre">is_multigraph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.is_multigraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if there are multiple edges between two node</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.is_singleton_from_node_id">
<span class="sig-name descname"><span class="pre">is_singleton_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.is_singleton_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing if given node is a singleton.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – The node to be checked for.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.is_singleton_from_node_name">
<span class="sig-name descname"><span class="pre">is_singleton_from_node_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.is_singleton_from_node_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing if given node is a singleton.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_name</strong> (<em>str</em><em>,</em>) – The node name to be checked for.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.is_singleton_with_selfloops_from_node_id">
<span class="sig-name descname"><span class="pre">is_singleton_with_selfloops_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.is_singleton_with_selfloops_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing if given node is a singleton with self-loops.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – The node to be checked for.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.is_trap_node_from_node_id">
<span class="sig-name descname"><span class="pre">is_trap_node_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.is_trap_node_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing if given node is a trap.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – Integer ID of the node, if this is bigger that the number of nodes it will panic.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.is_unchecked_connected_from_node_id">
<span class="sig-name descname"><span class="pre">is_unchecked_connected_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.is_unchecked_connected_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing if given node is not a singleton nor a singleton with selfloop.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – The node to be checked for.</p>
</dd>
</dl>
<p>If the given node ID does not exists in the graph this method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.is_unchecked_disconnected_node_from_node_id">
<span class="sig-name descname"><span class="pre">is_unchecked_disconnected_node_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.is_unchecked_disconnected_node_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing if given node is a singleton or a singleton with selfloop.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – The node to be checked for.</p>
</dd>
</dl>
<p>If the given node ID does not exists in the graph this method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.is_unchecked_singleton_from_node_id">
<span class="sig-name descname"><span class="pre">is_unchecked_singleton_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.is_unchecked_singleton_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing if given node is a singleton.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – The node to be checked for.</p>
</dd>
</dl>
<p>If the given node ID does not exists in the graph this method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.is_unchecked_singleton_from_node_name">
<span class="sig-name descname"><span class="pre">is_unchecked_singleton_from_node_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.is_unchecked_singleton_from_node_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing if given node is a singleton.</p>
<p>Nota that this method will raise a panic if caled with unproper
parametrization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_name</strong> (<em>str</em><em>,</em>) – The node name to be checked for.</p>
</dd>
</dl>
<p>If the given node name does not exist in the graph this method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.is_unchecked_singleton_with_selfloops_from_node_id">
<span class="sig-name descname"><span class="pre">is_unchecked_singleton_with_selfloops_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.is_unchecked_singleton_with_selfloops_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing if given node is a singleton with self-loops.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – The node to be checked for.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.is_unchecked_trap_node_from_node_id">
<span class="sig-name descname"><span class="pre">is_unchecked_trap_node_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.is_unchecked_trap_node_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns boolean representing if given node is a trap.</p>
<p>If the provided node_id is higher than the number of nodes in the graph,
the method will panic.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – Integer ID of the node, if this is bigger that the number of nodes it will panic.</p>
</dd>
</dl>
<p>If the given node ID does not exists in the graph this method will panic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.must_be_connected">
<span class="sig-name descname"><span class="pre">must_be_connected</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.must_be_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises an error if the graph is not connected.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph is not connected.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.must_be_multigraph">
<span class="sig-name descname"><span class="pre">must_be_multigraph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.must_be_multigraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises an error if the graph does not have edge types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph is not a multigraph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.must_be_undirected">
<span class="sig-name descname"><span class="pre">must_be_undirected</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.must_be_undirected" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises an error if the graph does not have edge types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph is directed.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.must_have_edges">
<span class="sig-name descname"><span class="pre">must_have_edges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.must_have_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises an error if the graph has a maximal weighted</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have edges.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.must_have_nodes">
<span class="sig-name descname"><span class="pre">must_have_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.must_have_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises an error if the graph does not have any node.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have nodes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.must_not_be_multigraph">
<span class="sig-name descname"><span class="pre">must_not_be_multigraph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.must_not_be_multigraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises an error if the graph does not have edge types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph is a multigraph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.must_not_contain_unknown_edge_types">
<span class="sig-name descname"><span class="pre">must_not_contain_unknown_edge_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.must_not_contain_unknown_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises an error if the graph contains unknown edge types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not contain edge types.</p></li>
<li><p><strong>ValueError</strong> – If the graph contains unknown edge types.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.must_not_contain_unknown_node_types">
<span class="sig-name descname"><span class="pre">must_not_contain_unknown_node_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.must_not_contain_unknown_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises an error if the graph contains unknown node types.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not contain node types.</p></li>
<li><p><strong>ValueError</strong> – If the graph contains unknown node types.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.must_not_contain_weighted_singleton_nodes">
<span class="sig-name descname"><span class="pre">must_not_contain_weighted_singleton_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.must_not_contain_weighted_singleton_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises an error if the graph contains zero weighted degree.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have edges.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.overlap_textual_report">
<span class="sig-name descname"><span class="pre">overlap_textual_report</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.overlap_textual_report" title="Permalink to this definition">¶</a></dt>
<dd><p>Return rendered textual report about the graph overlaps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<a class="reference internal" href="#grape.ensmallen.Graph" title="grape.ensmallen.Graph"><em>Graph</em></a><em>,</em>) – graph to create overlap report with.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to shor the loading bars.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.overlaps">
<span class="sig-name descname"><span class="pre">overlaps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.overlaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether given graph has any edge overlapping with current graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#grape.ensmallen.Graph" title="grape.ensmallen.Graph"><em>Graph</em></a><em>,</em>) – The graph to check against.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If a graph is directed and the other is undirected.</p></li>
<li><p><strong>ValueError</strong> – If one of the two graphs has edge weights and the other does not.</p></li>
<li><p><strong>ValueError</strong> – If one of the two graphs has node types and the other does not.</p></li>
<li><p><strong>ValueError</strong> – If one of the two graphs has edge types and the other does not.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.random_holdout">
<span class="sig-name descname"><span class="pre">random_holdout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_all_edge_types</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_types</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_number_overlaps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.random_holdout" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns random holdout for training ML algorithms on the graph edges.</p>
<p>The holdouts returned are a tuple of graphs. In neither holdouts the
graph connectivity is necessarily preserved. To maintain that, use
the method <cite>connected_holdout</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_size</strong> (<em>float</em><em>,</em>) – rate target to reserve for training</p></li>
<li><p><strong>random_state</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The random_state to use for the holdout,</p></li>
<li><p><strong>include_all_edge_types</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to include all the edges between two nodes.</p></li>
<li><p><strong>edge_types</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Optional</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em><em>,</em>) – The edges to include in validation set.</p></li>
<li><p><strong>min_number_overlaps</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The minimum number of overlaps to include the edge into the validation set.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show the loading bar.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the edge types have been specified but the graph does not have edge types.</p></li>
<li><p><strong>ValueError</strong> – If the minimum number of overlaps have been specified but the graph is not a multigraph.</p></li>
<li><p><strong>ValueError</strong> – If one or more of the given edge type names is not present in the graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.random_spanning_arborescence_kruskal">
<span class="sig-name descname"><span class="pre">random_spanning_arborescence_kruskal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">undesired_edge_types</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.random_spanning_arborescence_kruskal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns set of edges composing a spanning tree and connected components.</p>
<p>The spanning tree is NOT minimal.
The given random_state is NOT the root of the tree.</p>
<p>This method, additionally, allows for undesired edge types to be
used to build the spanning tree only in extremis when it is utterly
necessary in order to complete the spanning arborescence.</p>
<p>The quintuple returned contains:
- Set of the edges used in order to build the spanning arborescence.
- Vector of the connected component of each node.
- Number of connected components.
- Minimum component size.
- Maximum component size.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>random_state</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The random_state to use for the holdout,</p></li>
<li><p><strong>undesired_edge_types</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>Optional</em><em>[</em><em>int</em><em>]</em><em>]</em><em>]</em><em>,</em>) – Which edge types id to try to avoid.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show a loading bar or not.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remap_from_graph">
<span class="sig-name descname"><span class="pre">remap_from_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remap_from_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return graph remapped towards nodes of the given graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#grape.ensmallen.Graph" title="grape.ensmallen.Graph"><em>Graph</em></a><em>,</em>) – The graph to remap towards.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remap_from_node_ids">
<span class="sig-name descname"><span class="pre">remap_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_ids</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remap_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns graph remapped using given node IDs ordering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_ids</strong> (<em>List</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The node Ids to remap the graph to.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the given node IDs are not unique.</p></li>
<li><p><strong>ValueError</strong> – If the given node IDs are not available for all the values in the graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remap_from_node_names">
<span class="sig-name descname"><span class="pre">remap_from_node_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_names</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remap_from_node_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns graph remapped using given node names ordering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_names</strong> (<em>List</em><em>[</em><em>str</em><em>]</em><em>,</em>) – The node names to remap the graph to.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the given node names are not unique.</p></li>
<li><p><strong>ValueError</strong> – If the given node names are not available for all the values in the graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remap_unchecked_from_node_ids">
<span class="sig-name descname"><span class="pre">remap_unchecked_from_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_ids</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remap_unchecked_from_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns graph remapped using given node IDs ordering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_ids</strong> (<em>List</em><em>[</em><em>int</em><em>]</em><em>,</em>) – The node Ids to remap the graph to.</p>
</dd>
</dl>
<dl class="simple">
<dt>This method will cause a panic if the node IDs are either:</dt><dd><ul class="simple">
<li><p>Not unique</p></li>
<li><p>Not available for each of the node IDs of the graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remove_components">
<span class="sig-name descname"><span class="pre">remove_components</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_types</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_types</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimum_component_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top_k_components</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remove_components" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all the components that are not connected to interesting
nodes and edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_names</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>str</em><em>]</em><em>]</em><em>,</em>) – The name of the nodes of which components to keep.</p></li>
<li><p><strong>node_types</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Optional</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em><em>,</em>) – The types of the nodes of which components to keep.</p></li>
<li><p><strong>edge_types</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Optional</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em><em>,</em>) – The types of the edges of which components to keep.</p></li>
<li><p><strong>minimum_component_size</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Optional, Minimum size of the components to keep.</p></li>
<li><p><strong>top_k_components</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Optional, number of components to keep sorted by number of nodes.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show the loading bar.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remove_edge_type_id">
<span class="sig-name descname"><span class="pre">remove_edge_type_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remove_edge_type_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove given edge type ID from all edges.</p>
<p>If any given edge remains with no edge type, that edge is labeled
with edge type None. Note that the modification DOES NOT happen inplace.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_type_id</strong> (<em>int</em><em>,</em>) – The edge type ID to remove.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have edge types.</p></li>
<li><p><strong>ValueError</strong> – If the given edge type ID does not exists in the graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remove_edge_type_name">
<span class="sig-name descname"><span class="pre">remove_edge_type_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remove_edge_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove given edge type name from all edges.</p>
<p>If any given edge remains with no edge type, that edge is labeled
with edge type None. Note that the modification DOES NOT happen inplace.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_type_name</strong> (<em>str</em><em>,</em>) – The edge type ID to remove.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have edge types.</p></li>
<li><p><strong>ValueError</strong> – If the given edge type name does not exists in the graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remove_edge_types">
<span class="sig-name descname"><span class="pre">remove_edge_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remove_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove edge types from the graph.</p>
<p>Note that the modification does not happen inplace.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have edge types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remove_edge_weights">
<span class="sig-name descname"><span class="pre">remove_edge_weights</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remove_edge_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove edge weights from the graph.</p>
<p>Note that the modification does not happen inplace.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have edge weights.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remove_inplace_edge_type_ids">
<span class="sig-name descname"><span class="pre">remove_inplace_edge_type_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type_ids_to_remove</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remove_inplace_edge_type_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove given edge type ID from all edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_type_id</strong> (<em>int</em><em>,</em>) – The edge type ID to remove.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph is a multigraph.</p></li>
<li><p><strong>ValueError</strong> – If the graph does not have edge types.</p></li>
<li><p><strong>ValueError</strong> – If the given edge type ID does not exists in the graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remove_inplace_edge_type_name">
<span class="sig-name descname"><span class="pre">remove_inplace_edge_type_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remove_inplace_edge_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove given edge type name from all edges.</p>
<p>If any given edge remains with no edge type, that edge is labeled
with edge type None. Note that the modification happens inplace.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_type_name</strong> (<em>str</em><em>,</em>) – The edge type ID to remove.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have edge types.</p></li>
<li><p><strong>ValueError</strong> – If the given edge type name does not exists in the graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remove_inplace_edge_types">
<span class="sig-name descname"><span class="pre">remove_inplace_edge_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remove_inplace_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove edge types from the graph.</p>
<p>Note that the modification happens inplace.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have edge types.</p></li>
<li><p><strong>ValueError</strong> – If the graph is a multigraph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remove_inplace_edge_weights">
<span class="sig-name descname"><span class="pre">remove_inplace_edge_weights</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remove_inplace_edge_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove edge weights from the graph.</p>
<p>Note that the modification happens inplace.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have edge weights.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remove_inplace_node_type_ids">
<span class="sig-name descname"><span class="pre">remove_inplace_node_type_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_type_ids_to_remove</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remove_inplace_node_type_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove given node type ID from all nodes.</p>
<p>If any given node remains with no node type, that node is labeled
with node type None. Note that the modification happens inplace.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_type_id_to_remove</strong> (<em>int</em><em>,</em>) – The node type ID to remove.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have node types.</p></li>
<li><p><strong>ValueError</strong> – If the given node type ID does not exists in the graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remove_inplace_node_type_name">
<span class="sig-name descname"><span class="pre">remove_inplace_node_type_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_type_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remove_inplace_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove given node type name from all nodes.</p>
<p>If any given node remains with no node type, that node is labeled
with node type None. Note that the modification happens inplace.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_type_name</strong> (<em>str</em><em>,</em>) – The node type ID to remove.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have node types.</p></li>
<li><p><strong>ValueError</strong> – If the given node type name does not exists in the graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remove_inplace_node_types">
<span class="sig-name descname"><span class="pre">remove_inplace_node_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remove_inplace_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove node types from the graph.</p>
<p>Note that the modification happens inplace.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remove_inplace_singleton_edge_types">
<span class="sig-name descname"><span class="pre">remove_inplace_singleton_edge_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remove_inplace_singleton_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove singleton edge types from all edges.</p>
<p>If any given edge remains with no edge type, that edge is labeled
with edge type None. Note that the modification happens inplace.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have edge types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remove_inplace_singleton_node_types">
<span class="sig-name descname"><span class="pre">remove_inplace_singleton_node_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remove_inplace_singleton_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove singleton node types from all nodes.</p>
<p>If any given node remains with no node type, that node is labeled
with node type None. Note that the modification happens inplace.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remove_node_type_id">
<span class="sig-name descname"><span class="pre">remove_node_type_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_type_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remove_node_type_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove given node type ID from all nodes.</p>
<p>If any given node remains with no node type, that node is labeled
with node type None. Note that the modification DOES NOT happen inplace.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_type_id</strong> (<em>int</em><em>,</em>) – The node type ID to remove.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have node types.</p></li>
<li><p><strong>ValueError</strong> – If the given node type ID does not exists in the graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remove_node_type_name">
<span class="sig-name descname"><span class="pre">remove_node_type_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_type_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remove_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove given node type name from all nodes.</p>
<p>If any given node remains with no node type, that node is labeled
with node type None. Note that the modification DOES NOT happen inplace.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_type_name</strong> (<em>str</em><em>,</em>) – The node type ID to remove.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have node types.</p></li>
<li><p><strong>ValueError</strong> – If the given node type name does not exists in the graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remove_node_types">
<span class="sig-name descname"><span class="pre">remove_node_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remove_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove node types from the graph.</p>
<p>Note that the modification does not happen inplace.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remove_singleton_edge_types">
<span class="sig-name descname"><span class="pre">remove_singleton_edge_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remove_singleton_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove singleton edge types from all edges.</p>
<p>If any given edge remains with no edge type, that edge is labeled
with edge type None. Note that the modification DOES NOT happen inplace.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have edge types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.remove_singleton_node_types">
<span class="sig-name descname"><span class="pre">remove_singleton_node_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.remove_singleton_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove singleton node types from all nodes.</p>
<p>If any given node remains with no node type, that node is labeled
with node type None. Note that the modification DOES NOT happen inplace.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the graph does not have node types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.replace">
<span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_name_mapping</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_type_name_mapping</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_type_name_mapping</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace given node, node type and edge type names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_name_mapping</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em><em>,</em>) – The node names to replace.</p></li>
<li><p><strong>node_type_name_mapping</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em><em>,</em>) – The node type names to replace.</p></li>
<li><p><strong>edge_type_name_mapping</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em><em>,</em>) – The edge type names to replace.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the given node names mapping would lead to nodes duplication.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.report">
<span class="sig-name descname"><span class="pre">report</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.report" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns report relative to the graph metrics</p>
<p>The report includes the following metrics by default:
* Name of the graph
* Whether the graph is directed or undirected
* Number of singleton nodes
* Number of nodes
- If the graph has nodes, we also compute:
* Minimum unweighted node degree
* Maximum unweighted node degree
* Unweighted node degree mean
* Number of edges
* Number of self-loops
* Number of singleton with self-loops
* Whether the graph is a multigraph
* Number of parallel edges
* Number of directed edges
- If the graph has edges, we also compute:
* Rate of self-loops
* Whether the graph has weighted edges
- If the graph has weights, we also compute:
* Minimum weighted node degree
* Maximum weighted node degree
* Weighted node degree mean
* The total edge weights
* Whether the graph has node types
- If the graph has node types, we also compute:
* Whether the graph has singleton node types
* The number of node types
* The number of nodes with unknown node types
* The number of nodes with known node types
* Whether the graph has edge types
- If the graph has edge types, we also compute:
* Whether the graph has singleton edge types
* The number of edge types
* The number of edges with unknown edge types
* The number of edges with known edge types</p>
<p>On request, since it takes more time to compute it, the method also provides:</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.sample_negatives">
<span class="sig-name descname"><span class="pre">sample_negatives</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">negatives_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed_graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">only_from_same_component</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.sample_negatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns Graph with given amount of negative edges as positive edges.</p>
<p>The graph generated may be used as a testing negatives partition to be
fed into the argument “graph_to_avoid” of the link_prediction or the
skipgrams algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>negatives_number</strong> (<em>int</em><em>,</em>) – Number of negatives edges to include.</p></li>
<li><p><strong>random_state</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – random_state to use to reproduce negative edge set.</p></li>
<li><p><strong>seed_graph</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="#grape.ensmallen.Graph" title="grape.ensmallen.Graph"><em>Graph</em></a><em>]</em><em>,</em>) – Optional graph to use to filter the negative edges. The negative edges generated when this variable is provided will always have a node within this graph.</p></li>
<li><p><strong>only_from_same_component</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to sample negative edges only from nodes that are from the same component.</p></li>
<li><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show the loading bar.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.set_all_edge_types">
<span class="sig-name descname"><span class="pre">set_all_edge_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.set_all_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace all edge types (if present) and set all the edge to edge_type.</p>
<p>This DOES NOT happen inplace, but created a new instance of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_type</strong> (<em>str</em><em>,</em>) – The edge type to assing to all the edges.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.set_all_node_types">
<span class="sig-name descname"><span class="pre">set_all_node_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.set_all_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace all node types (if present) and set all the node to node_type.</p>
<p>This DOES NOT happen inplace, but created a new instance of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_type</strong> (<em>str</em><em>,</em>) – The node type to assing to all the nodes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.set_inplace_all_edge_types">
<span class="sig-name descname"><span class="pre">set_inplace_all_edge_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.set_inplace_all_edge_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace all edge types (if present) and set all the edge to edge_type.</p>
<p>This happens INPLACE, that is edits the current graph instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_type</strong> (<em>str</em><em>,</em>) – The edge type to assing to all the edges.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the graph does not have edges.</p></li>
<li><p><strong>ValueError</strong> – If the graph is a multigraph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.set_inplace_all_node_types">
<span class="sig-name descname"><span class="pre">set_inplace_all_node_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.set_inplace_all_node_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace all node types (if present) and set all the node to node_type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_type</strong> (<em>str</em><em>,</em>) – The node type to assing to all the nodes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.set_name">
<span class="sig-name descname"><span class="pre">set_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.set_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the name of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em><em>,</em>) – Name of the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.sort_by_bfs_topological_sorting_from_node_id">
<span class="sig-name descname"><span class="pre">sort_by_bfs_topological_sorting_from_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root_node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.sort_by_bfs_topological_sorting_from_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns graph with node IDs sorted using a BFS</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>root_node_id</strong> (<em>int</em><em>,</em>) – Node ID of node to be used as root of BFS</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the given root node ID does not exist in the graph</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.sort_by_decreasing_outbound_node_degree">
<span class="sig-name descname"><span class="pre">sort_by_decreasing_outbound_node_degree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.sort_by_decreasing_outbound_node_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns graph with node IDs sorted by decreasing outbound node degree</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.sort_by_increasing_outbound_node_degree">
<span class="sig-name descname"><span class="pre">sort_by_increasing_outbound_node_degree</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.sort_by_increasing_outbound_node_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns graph with node IDs sorted by increasing outbound node degree</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.sort_by_node_lexicographic_order">
<span class="sig-name descname"><span class="pre">sort_by_node_lexicographic_order</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.sort_by_node_lexicographic_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns graph with node IDs sorted by lexicographic order</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.spanning_arborescence_kruskal">
<span class="sig-name descname"><span class="pre">spanning_arborescence_kruskal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.spanning_arborescence_kruskal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns consistent spanning arborescence using Kruskal.</p>
<p>The spanning tree is NOT minimal.</p>
<p>The quintuple returned contains:
- Set of the edges used in order to build the spanning arborescence.
- Vector of the connected component of each node.
- Number of connected components.
- Minimum component size.
- Maximum component size.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>verbose</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>,</em>) – Whether to show a loading bar or not.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.strongly_connected_components">
<span class="sig-name descname"><span class="pre">strongly_connected_components</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.strongly_connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns list of nodes of the various strongly connected components.</p>
<p>This is an implementation of Tarjan algorithm.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.textual_report">
<span class="sig-name descname"><span class="pre">textual_report</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.textual_report" title="Permalink to this definition">¶</a></dt>
<dd><p>Return html short textual report of the graph.</p>
<p>TODO! Add reports on triangles
TODO! Add reports on connected components
TODO! Add reports on various node metrics
TODO! Add reports on various edge metrics
NOTE! Most of the above TODOs will require first to implement the
support for the fast computation of the inbound edges in a directed
graphs</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.to_anti_diagonal">
<span class="sig-name descname"><span class="pre">to_anti_diagonal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.to_anti_diagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the graph from the anti-diagonal adjacency matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.to_arrowhead">
<span class="sig-name descname"><span class="pre">to_arrowhead</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.to_arrowhead" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the graph from the arrowhead adjacency matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.to_bidiagonal">
<span class="sig-name descname"><span class="pre">to_bidiagonal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.to_bidiagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the graph from the bidiagonal adjacency matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.to_complementary">
<span class="sig-name descname"><span class="pre">to_complementary</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.to_complementary" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the complementary graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.to_directed">
<span class="sig-name descname"><span class="pre">to_directed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.to_directed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new instance of the current graph as directed</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.to_directed_inplace">
<span class="sig-name descname"><span class="pre">to_directed_inplace</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.to_directed_inplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert inplace the graph to directed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.to_dot">
<span class="sig-name descname"><span class="pre">to_dot</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.to_dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the current graph in a format compatible with Graphviz dot’s format</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.to_lower_triangular">
<span class="sig-name descname"><span class="pre">to_lower_triangular</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.to_lower_triangular" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the directed graph from the lower triangular adjacency matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.to_main_diagonal">
<span class="sig-name descname"><span class="pre">to_main_diagonal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.to_main_diagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the graph from the main diagonal adjacency matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.to_transposed">
<span class="sig-name descname"><span class="pre">to_transposed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.to_transposed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the graph from the transposed adjacency matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.to_upper_triangular">
<span class="sig-name descname"><span class="pre">to_upper_triangular</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.to_upper_triangular" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the directed graph from the upper triangular adjacency matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.validate_edge_id">
<span class="sig-name descname"><span class="pre">validate_edge_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.validate_edge_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Validates provided edge ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_id</strong> (<em>int</em><em>,</em>) – Edge ID to validate.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the given edge ID does not exists in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.validate_edge_ids">
<span class="sig-name descname"><span class="pre">validate_edge_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_ids</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.validate_edge_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Validates provided edge IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_ids</strong> (<em>List</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Edge IDs to validate.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If any of the given edge ID does not exists in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.validate_edge_type_id">
<span class="sig-name descname"><span class="pre">validate_edge_type_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.validate_edge_type_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Validates provided edge type ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_type_id</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – edge type ID to validate.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the given edge type ID does not exists in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.validate_edge_type_ids">
<span class="sig-name descname"><span class="pre">validate_edge_type_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type_ids</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.validate_edge_type_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Validates provided edge type IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edge_type_ids</strong> (<em>List</em><em>[</em><em>Optional</em><em>[</em><em>int</em><em>]</em><em>]</em><em>,</em>) – Vector of edge type IDs to validate.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If there are no edge types in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.validate_node_id">
<span class="sig-name descname"><span class="pre">validate_node_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.validate_node_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Validates provided node ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_id</strong> (<em>int</em><em>,</em>) – node ID to validate.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the given node ID does not exists in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.validate_node_ids">
<span class="sig-name descname"><span class="pre">validate_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_ids</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.validate_node_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Validates all provided node IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_ids</strong> (<em>List</em><em>[</em><em>int</em><em>]</em><em>,</em>) – node IDs to validate.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If any of the given node ID does not exists in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.validate_node_type_id">
<span class="sig-name descname"><span class="pre">validate_node_type_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_type_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.validate_node_type_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Validates provided node type ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_type_id</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>,</em>) – Node type ID to validate.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the given node type ID does not exists in the graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grape.ensmallen.Graph.validate_node_type_ids">
<span class="sig-name descname"><span class="pre">validate_node_type_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_type_ids</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grape.ensmallen.Graph.validate_node_type_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Validates provided node type IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node_type_ids</strong> (<em>List</em><em>[</em><em>Optional</em><em>[</em><em>int</em><em>]</em><em>]</em><em>,</em>) – Vector of node type IDs to validate.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If there are no node types in the graph.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">GraPE</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Cappelleti Luca, Fontana Tommaso.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/grape.ensmallen.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>