<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>grape.ensmallen.graph &mdash; GraPE 1.0.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> GraPE
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">GraPE</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>grape.ensmallen.graph</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for grape.ensmallen.graph</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">tensorflow</span> <span class="kn">import</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">SparseTensor</span>
<span class="kn">from</span> <span class="nn">ensmallen</span> <span class="kn">import</span> <span class="n">Graph</span>

<div class="viewcode-block" id="Graph"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph">[docs]</a><span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;TODO!: document this&quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="Graph.add_selfloops"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.add_selfloops">[docs]</a>    <span class="k">def</span> <span class="nf">add_selfloops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph with added in missing self-loops with given edge type and weight.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the edge type for the new selfloops is provided but the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the edge weight for the new selfloops is provided but the graph does not have edge weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the edge weight for the new selfloops is NOT provided but the graph does have edge weights.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.approximated_vertex_cover_set"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.approximated_vertex_cover_set">[docs]</a>    <span class="k">def</span> <span class="nf">approximated_vertex_cover_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns 2-approximated verted cover set using greedy algorithm.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.are_nodes_remappable"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.are_nodes_remappable">[docs]</a>    <span class="k">def</span> <span class="nf">are_nodes_remappable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether nodes are remappable to those of the given graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph,</span>
<span class="sd">            graph towards remap the nodes to.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.connected_components"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.connected_components">[docs]</a>    <span class="k">def</span> <span class="nf">connected_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Compute the connected components building in parallel a spanning tree using [bader&#39;s algorithm](https://www.sciencedirect.com/science/article/abs/pii/S0743731505000882).</span>
<span class="sd">        </span>
<span class="sd">        **This works only for undirected graphs.**</span>
<span class="sd">        </span>
<span class="sd">        This method is **not thread save and not deterministic** but by design of the algorithm this</span>
<span class="sd">        shouldn&#39;t matter but if we will encounter non-detemristic bugs here is where we want to look.</span>
<span class="sd">        </span>
<span class="sd">        The returned quadruple contains:</span>
<span class="sd">        - Vector of the connected component for each node.</span>
<span class="sd">        - Number of connected components.</span>
<span class="sd">        - Minimum connected component size.</span>
<span class="sd">        - Maximum connected component size.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show a loading bar or not.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given graph is directed.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the system configuration does not allow for the creation of the thread pool.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.connected_holdout"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.connected_holdout">[docs]</a>    <span class="k">def</span> <span class="nf">connected_holdout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">include_all_edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns holdout for training ML algorithms on the graph structure.</span>
<span class="sd">        </span>
<span class="sd">        The holdouts returned are a tuple of graphs. The first one, which</span>
<span class="sd">        is the training graph, is garanteed to have the same number of</span>
<span class="sd">        graph components as the initial graph. The second graph is the graph</span>
<span class="sd">        meant for testing or validation of the algorithm, and has no garantee</span>
<span class="sd">        to be connected. It will have at most (1-train_size) edges,</span>
<span class="sd">        as the bound of connectivity which is required for the training graph</span>
<span class="sd">        may lead to more edges being left into the training partition.</span>
<span class="sd">        </span>
<span class="sd">        In the option where a list of edge types has been provided, these</span>
<span class="sd">        edge types will be those put into the validation set.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float,</span>
<span class="sd">            Rate target to reserve for training.</span>
<span class="sd">        random_state: Optional[int],</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        edge_types: Optional[List[Optional[str]]],</span>
<span class="sd">            Edge types to be selected for in the validation set.</span>
<span class="sd">        include_all_edge_types: Optional[bool],</span>
<span class="sd">            Whether to include all the edges between two nodes.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show the loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the edge types have been specified but the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the required training size is not a real value between 0 and 1.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the current graph does not allow for the creation of a spanning tree for the requested training size.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.contains"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.contains">[docs]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if given graph edges are all contained within current graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph,</span>
<span class="sd">            The graph to check against.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If a graph is directed and the other is undirected.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has edge weights and the other does not.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has node types and the other does not.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has edge types and the other does not.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.decode_edge"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.decode_edge">[docs]</a>    <span class="k">def</span> <span class="nf">decode_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns source and destination nodes corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge: int,</span>
<span class="sd">            The edge value to decode.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.disable_all"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.disable_all">[docs]</a>    <span class="k">def</span> <span class="nf">disable_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Disable all extra perks, reducing memory impact but incresing time requirements&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.drop_disconnected_nodes"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.drop_disconnected_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">drop_disconnected_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without disconnected nodes.</span>
<span class="sd">        </span>
<span class="sd">        A disconnected node is a node with no connection to any other node.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.drop_parallel_edges"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.drop_parallel_edges">[docs]</a>    <span class="k">def</span> <span class="nf">drop_parallel_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without parallel edges&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.drop_selfloops"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.drop_selfloops">[docs]</a>    <span class="k">def</span> <span class="nf">drop_selfloops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without selfloops.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.drop_singleton_nodes"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.drop_singleton_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">drop_singleton_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without singleton nodes.</span>
<span class="sd">        </span>
<span class="sd">        A node is singleton when does not have neither incoming or outgoing edges.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.drop_singleton_nodes_with_selfloops"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.drop_singleton_nodes_with_selfloops">[docs]</a>    <span class="k">def</span> <span class="nf">drop_singleton_nodes_with_selfloops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without singleton nodes with selfloops.</span>
<span class="sd">        </span>
<span class="sd">        A node is singleton with selfloop when does not have neither incoming or outgoing edges.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.drop_unknown_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.drop_unknown_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">drop_unknown_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without unknown edge types and relative edges.</span>
<span class="sd">        </span>
<span class="sd">        Note that this method will remove ALL edges labeled with unknown edge</span>
<span class="sd">        type!&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.drop_unknown_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.drop_unknown_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">drop_unknown_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns new graph without unknown node types and relative nodes.</span>
<span class="sd">        </span>
<span class="sd">        Note that this method will remove ALL nodes labeled with unknown node</span>
<span class="sd">        type!&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.enable"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.enable">[docs]</a>    <span class="k">def</span> <span class="nf">enable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector_sources</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">vector_destinations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">vector_cumulative_node_degrees</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Enable extra perks that buys you time as you accept to spend more memory.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector_sources: Optional[bool],</span>
<span class="sd">            Whether to cache sources into a vector for faster walks.</span>
<span class="sd">        vector_destinations: Optional[bool],</span>
<span class="sd">            Whether to cache destinations into a vector for faster walks.</span>
<span class="sd">        vector_cumulative_node_degrees: Optional[bool],</span>
<span class="sd">            Whether to cache cumulative_node_degrees into a vector for faster walks.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.encode_edge"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.encode_edge">[docs]</a>    <span class="k">def</span> <span class="nf">encode_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return edge value corresponding to given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int,</span>
<span class="sd">            The source node ID.</span>
<span class="sd">        dst: int,</span>
<span class="sd">            The destination node ID.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.filter_from_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.filter_from_ids">[docs]</a>    <span class="k">def</span> <span class="nf">filter_from_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_ids_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">node_ids_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">node_type_ids_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]],</span> <span class="n">node_type_ids_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]],</span> <span class="n">node_type_id_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span> <span class="n">node_type_id_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span> <span class="n">edge_ids_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">edge_ids_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">edge_node_ids_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span> <span class="n">edge_node_ids_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span> <span class="n">edge_type_ids_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span> <span class="n">edge_type_ids_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span> <span class="n">min_edge_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">max_edge_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">filter_singleton_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">filter_singleton_nodes_with_selfloop</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">filter_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">filter_parallel_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns a **NEW** Graph that does not have the required attributes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_ids_to_keep: Optional[List[int]],</span>
<span class="sd">            List of node IDs to keep during filtering.</span>
<span class="sd">        node_ids_to_filter: Optional[List[int]],</span>
<span class="sd">            List of node IDs to remove during filtering.</span>
<span class="sd">        node_type_ids_to_keep: Optional[List[Optional[List[int]]]],</span>
<span class="sd">            List of node type IDs to keep during filtering. The node types must match entirely the given node types vector provided.</span>
<span class="sd">        node_type_ids_to_filter: Optional[List[Optional[List[int]]]],</span>
<span class="sd">            List of node type IDs to remove during filtering. The node types must match entirely the given node types vector provided.</span>
<span class="sd">        node_type_id_to_keep: Optional[List[Optional[int]]],</span>
<span class="sd">            List of node type IDs to keep during filtering. Any of node types must match with one of the node types given.</span>
<span class="sd">        node_type_id_to_filter: Optional[List[Optional[int]]],</span>
<span class="sd">            List of node type IDs to remove during filtering. Any of node types must match with one of the node types given.</span>
<span class="sd">        edge_ids_to_keep: Optional[List[int]],</span>
<span class="sd">            List of edge IDs to keep during filtering.</span>
<span class="sd">        edge_ids_to_filter: Optional[List[int]],</span>
<span class="sd">            List of edge IDs to remove during filtering.</span>
<span class="sd">        edge_node_ids_to_keep: Optional[List[Tuple[int, int]]],</span>
<span class="sd">            List of tuple of node IDs to keep during filtering.</span>
<span class="sd">        edge_node_ids_to_filter: Optional[List[Tuple[int, int]]],</span>
<span class="sd">            List of tuple of node IDs to remove during filtering.</span>
<span class="sd">        edge_type_ids_to_keep: Optional[List[Optional[int]]],</span>
<span class="sd">            List of edge type IDs to keep during filtering.</span>
<span class="sd">        edge_type_ids_to_filter: Optional[List[Optional[int]]],</span>
<span class="sd">            List of edge type IDs to remove during filtering.</span>
<span class="sd">        min_edge_weight: Optional[float],</span>
<span class="sd">            Minimum edge weight. Values lower than this are removed.</span>
<span class="sd">        max_edge_weight: Optional[float],</span>
<span class="sd">            Maximum edge weight. Values higher than this are removed.</span>
<span class="sd">        filter_singleton_nodes: Optional[bool],</span>
<span class="sd">            Whether to filter out singleton nodes.</span>
<span class="sd">        filter_singleton_nodes_with_selfloop: Optional[bool],</span>
<span class="sd">            Whether to filter out singleton nodes with selfloops.</span>
<span class="sd">        filter_selfloops: Optional[bool],</span>
<span class="sd">            Whether to filter out selfloops.</span>
<span class="sd">        filter_parallel_edges: Optional[bool],</span>
<span class="sd">            Whether to filter out parallel edges.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show loading bar while building the graphs.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.filter_from_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.filter_from_names">[docs]</a>    <span class="k">def</span> <span class="nf">filter_from_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_names_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">node_names_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">node_type_names_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]],</span> <span class="n">node_type_names_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]],</span> <span class="n">node_type_name_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">node_type_name_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">edge_node_names_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]],</span> <span class="n">edge_node_names_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]],</span> <span class="n">edge_type_names_to_keep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">edge_type_names_to_filter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">min_edge_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">max_edge_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">filter_singleton_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">filter_singleton_nodes_with_selfloop</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">filter_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">filter_parallel_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns a **NEW** Graph that does not have the required attributes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_names_to_keep: Optional[List[str]],</span>
<span class="sd">            List of node names to keep during filtering.</span>
<span class="sd">        node_names_to_filter: Optional[List[str]],</span>
<span class="sd">            List of node names to remove during filtering.</span>
<span class="sd">        node_type_names_to_keep: Optional[List[Optional[List[str]]]],</span>
<span class="sd">            List of node type names to keep during filtering. The node types must match entirely the given node types vector provided.</span>
<span class="sd">        node_type_names_to_filter: Optional[List[Optional[List[str]]]],</span>
<span class="sd">            List of node type names to remove during filtering. The node types must match entirely the given node types vector provided.</span>
<span class="sd">        node_type_name_to_keep: Optional[List[Optional[str]]],</span>
<span class="sd">            List of node type name to keep during filtering. Any of node types must match with one of the node types given.</span>
<span class="sd">        node_type_name_to_filter: Optional[List[Optional[str]]],</span>
<span class="sd">            List of node type name to remove during filtering. Any of node types must match with one of the node types given.</span>
<span class="sd">        edge_node_names_to_keep: Optional[List[Tuple[str, str]]],</span>
<span class="sd">            List of tuple of node names to keep during filtering.</span>
<span class="sd">        edge_node_names_to_filter: Optional[List[Tuple[str, str]]],</span>
<span class="sd">            List of tuple of node names to remove during filtering.</span>
<span class="sd">        edge_type_names_to_keep: Optional[List[Optional[str]]],</span>
<span class="sd">            List of edge type names to keep during filtering.</span>
<span class="sd">        edge_type_names_to_filter: Optional[List[Optional[str]]],</span>
<span class="sd">            List of edge type names to remove during filtering.</span>
<span class="sd">        min_edge_weight: Optional[float],</span>
<span class="sd">            Minimum edge weight. Values lower than this are removed.</span>
<span class="sd">        max_edge_weight: Optional[float],</span>
<span class="sd">            Maximum edge weight. Values higher than this are removed.</span>
<span class="sd">        filter_singleton_nodes: Optional[bool],</span>
<span class="sd">            Whether to filter out singletons.</span>
<span class="sd">        filter_singleton_nodes_with_selfloop: Optional[bool],</span>
<span class="sd">            Whether to filter out singleton nodes with selfloops.</span>
<span class="sd">        filter_selfloops: Optional[bool],</span>
<span class="sd">            Whether to filter out selfloops.</span>
<span class="sd">        filter_parallel_edges: Optional[bool],</span>
<span class="sd">            Whether to filter out parallel edges.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show loading bar while building the graphs.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.from_csv"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.from_csv">[docs]</a>    <span class="k">def</span> <span class="nf">from_csv</span><span class="p">(</span><span class="n">node_type_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_type_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_types_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">numeric_node_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">minimum_node_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_type_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_type_list_is_correct</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_type_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">load_node_type_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_list_is_correct</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">nodes_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nodes_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_types_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_list_node_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_list_node_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_ids_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_ids_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nodes_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">numeric_node_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_list_numeric_node_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">skip_node_types_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">load_node_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_type_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_types_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">numeric_edge_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">minimum_edge_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_type_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_type_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_type_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_type_list_is_correct</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_type_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_type_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">load_edge_type_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_list_separator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_list_header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_rows_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">sources_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">sources_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">destinations_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">destinations_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_list_edge_types_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_list_edge_types_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weights_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">weights_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">default_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">edge_ids_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_ids_column_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_list_numeric_edge_type_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_numeric_node_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">skip_weights_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">skip_edge_types_if_unavailable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_is_complete</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_may_contain_duplicates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_is_sorted</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_is_correct</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_list_max_rows_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">edge_list_comment_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edges_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">load_edge_list_in_parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">may_have_singletons</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">may_have_singleton_with_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Return graph renderized from given CSVs or TSVs-like files.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_path: Optional[str],</span>
<span class="sd">            The path to the file with the unique node type names.</span>
<span class="sd">        node_type_list_separator: Optional[str],</span>
<span class="sd">            The separator to use for the node types file. Note that if this is not provided, one will be automatically detected among the following`: comma, semi-column, tab and space.</span>
<span class="sd">        node_types_column_number: Optional[int],</span>
<span class="sd">            The number of the column of the node types file from where to load the node types.</span>
<span class="sd">        node_types_column: Optional[str],</span>
<span class="sd">            The name of the column of the node types file from where to load the node types.</span>
<span class="sd">        node_types_number: Optional[int],</span>
<span class="sd">            The number of the unique node types. This will be used in order to allocate the correct size for the data structure.</span>
<span class="sd">        numeric_node_type_ids: Optional[bool],</span>
<span class="sd">            Whether the node type names should be loaded as numeric values, i.e. casted from string to a numeric representation.</span>
<span class="sd">        minimum_node_type_id: Optional[int],</span>
<span class="sd">            The minimum node type ID to be used when using numeric node type IDs.</span>
<span class="sd">        node_type_list_header: Optional[bool],</span>
<span class="sd">            Whether the node type file has an header.</span>
<span class="sd">        node_type_list_rows_to_skip: Optional[int],</span>
<span class="sd">            The number of lines to skip in the node types file`: the header is already skipped if it has been specified that the file has an header.</span>
<span class="sd">        node_type_list_is_correct: Optional[bool],</span>
<span class="sd">            Whether the node types file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</span>
<span class="sd">        node_type_list_max_rows_number: Optional[int],</span>
<span class="sd">            The maximum number of lines to be loaded from the node types file.</span>
<span class="sd">        node_type_list_comment_symbol: Optional[str],</span>
<span class="sd">            The comment symbol to skip lines in the node types file. Lines starting with this symbol will be skipped.</span>
<span class="sd">        load_node_type_list_in_parallel: Optional[bool],</span>
<span class="sd">            Whether to load the node type list in parallel. Note that when loading in parallel, the internal order of the node type IDs may result changed across different iterations. We are working to get this to be stable.</span>
<span class="sd">        node_path: Optional[str],</span>
<span class="sd">            The path to the file with the unique node names.</span>
<span class="sd">        node_list_separator: Optional[str],</span>
<span class="sd">            The separator to use for the nodes file. Note that if this is not provided, one will be automatically detected among the following`: comma, semi-column, tab and space.</span>
<span class="sd">        node_list_header: Optional[bool],</span>
<span class="sd">            Whether the nodes file has an header.</span>
<span class="sd">        node_list_rows_to_skip: Optional[int],</span>
<span class="sd">            Number of rows to skip in the node list file.</span>
<span class="sd">        node_list_is_correct: Optional[bool],</span>
<span class="sd">            Whether the nodes file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</span>
<span class="sd">        node_list_max_rows_number: Optional[int],</span>
<span class="sd">            The maximum number of lines to be loaded from the nodes file.</span>
<span class="sd">        node_list_comment_symbol: Optional[str],</span>
<span class="sd">            The comment symbol to skip lines in the nodes file. Lines starting with this symbol will be skipped.</span>
<span class="sd">        default_node_type: Optional[str],</span>
<span class="sd">            The node type to be used when the node type for a given node in the node file is None.</span>
<span class="sd">        nodes_column_number: Optional[int],</span>
<span class="sd">            The number of the column of the node file from where to load the node names.</span>
<span class="sd">        nodes_column: Optional[str],</span>
<span class="sd">            The name of the column of the node file from where to load the node names.</span>
<span class="sd">        node_types_separator: Optional[str],</span>
<span class="sd">            The node types separator.</span>
<span class="sd">        node_list_node_types_column_number: Optional[int],</span>
<span class="sd">            The number of the column of the node file from where to load the node types.</span>
<span class="sd">        node_list_node_types_column: Optional[str],</span>
<span class="sd">            The name of the column of the node file from where to load the node types.</span>
<span class="sd">        node_ids_column: Optional[str],</span>
<span class="sd">            The name of the column of the node file from where to load the node IDs.</span>
<span class="sd">        node_ids_column_number: Optional[int],</span>
<span class="sd">            The number of the column of the node file from where to load the node IDs</span>
<span class="sd">        nodes_number: Optional[int],</span>
<span class="sd">            The expected number of nodes. Note that this must be the EXACT number of nodes in the graph.</span>
<span class="sd">        minimum_node_id: Optional[int],</span>
<span class="sd">            The minimum node ID to be used, when loading the node IDs as numerical.</span>
<span class="sd">        numeric_node_ids: Optional[bool],</span>
<span class="sd">            Whether to load the numeric node IDs as numeric.</span>
<span class="sd">        node_list_numeric_node_type_ids: Optional[bool],</span>
<span class="sd">            Whether to load the node types IDs in the node file to be numeric.</span>
<span class="sd">        skip_node_types_if_unavailable: Optional[bool],</span>
<span class="sd">            Whether to skip the node types without raising an error if these are unavailable.</span>
<span class="sd">        load_node_list_in_parallel: Optional[bool],</span>
<span class="sd">            Whether to load the node list in parallel. When loading in parallel, without node IDs, the nodes may not be loaded in a deterministic order.</span>
<span class="sd">        edge_type_path: Optional[str],</span>
<span class="sd">            The path to the file with the unique edge type names.</span>
<span class="sd">        edge_types_column_number: Optional[int],</span>
<span class="sd">            The number of the column of the edge types file from where to load the edge types.</span>
<span class="sd">        edge_types_column: Optional[str],</span>
<span class="sd">            The name of the column of the edge types file from where to load the edge types.</span>
<span class="sd">        edge_types_number: Optional[int],</span>
<span class="sd">            The number of the unique edge types. This will be used in order to allocate the correct size for the data structure.</span>
<span class="sd">        numeric_edge_type_ids: Optional[bool],</span>
<span class="sd">            Whether the edge type names should be loaded as numeric values, i.e. casted from string to a numeric representation.</span>
<span class="sd">        minimum_edge_type_id: Optional[int],</span>
<span class="sd">            The minimum edge type ID to be used when using numeric edge type IDs.</span>
<span class="sd">        edge_type_list_separator: Optional[str],</span>
<span class="sd">            The separator to use for the edge type list. Note that, if None is provided, one will be attempted to be detected automatically between &#39;;&#39;, &#39;,&#39;, tab or space.</span>
<span class="sd">        edge_type_list_header: Optional[bool],</span>
<span class="sd">            Whether the edge type file has an header.</span>
<span class="sd">        edge_type_list_rows_to_skip: Optional[int],</span>
<span class="sd">            Number of rows to skip in the edge type list file.</span>
<span class="sd">        edge_type_list_is_correct: Optional[bool],</span>
<span class="sd">            Whether the edge types file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</span>
<span class="sd">        edge_type_list_max_rows_number: Optional[int],</span>
<span class="sd">            The maximum number of lines to be loaded from the edge types file.</span>
<span class="sd">        edge_type_list_comment_symbol: Optional[str],</span>
<span class="sd">            The comment symbol to skip lines in the edge types file. Lines starting with this symbol will be skipped.</span>
<span class="sd">        load_edge_type_list_in_parallel: Optional[bool],</span>
<span class="sd">            Whether to load the edge type list in parallel. When loading in parallel, without edge type IDs, the edge types may not be loaded in a deterministic order.</span>
<span class="sd">        edge_path: Optional[str],</span>
<span class="sd">            The path to the file with the edge list.</span>
<span class="sd">        edge_list_separator: Optional[str],</span>
<span class="sd">            The separator to use for the edge list. Note that, if None is provided, one will be attempted to be detected automatically between &#39;;&#39;, &#39;,&#39;, tab or space.</span>
<span class="sd">        edge_list_header: Optional[bool],</span>
<span class="sd">            Whether the edges file has an header.</span>
<span class="sd">        edge_list_rows_to_skip: Optional[int],</span>
<span class="sd">            Number of rows to skip in the edge list file.</span>
<span class="sd">        sources_column_number: Optional[int],</span>
<span class="sd">            The number of the column of the edges file from where to load the source nodes.</span>
<span class="sd">        sources_column: Optional[str],</span>
<span class="sd">            The name of the column of the edges file from where to load the source nodes.</span>
<span class="sd">        destinations_column_number: Optional[int],</span>
<span class="sd">            The number of the column of the edges file from where to load the destinaton nodes.</span>
<span class="sd">        destinations_column: Optional[str],</span>
<span class="sd">            The name of the column of the edges file from where to load the destinaton nodes.</span>
<span class="sd">        edge_list_edge_types_column_number: Optional[int],</span>
<span class="sd">            The number of the column of the edges file from where to load the edge types.</span>
<span class="sd">        edge_list_edge_types_column: Optional[str],</span>
<span class="sd">            The name of the column of the edges file from where to load the edge types.</span>
<span class="sd">        default_edge_type: Optional[str],</span>
<span class="sd">            The edge type to be used when the edge type for a given edge in the edge file is None.</span>
<span class="sd">        weights_column_number: Optional[int],</span>
<span class="sd">            The number of the column of the edges file from where to load the edge weights.</span>
<span class="sd">        weights_column: Optional[str],</span>
<span class="sd">            The name of the column of the edges file from where to load the edge weights.</span>
<span class="sd">        default_weight: Optional[float],</span>
<span class="sd">            The edge weight to be used when the edge weight for a given edge in the edge file is None.</span>
<span class="sd">        edge_ids_column: Optional[str],</span>
<span class="sd">            The name of the column of the edges file from where to load the edge IDs.</span>
<span class="sd">        edge_ids_column_number: Optional[int],</span>
<span class="sd">            The number of the column of the edges file from where to load the edge IDs.</span>
<span class="sd">        edge_list_numeric_edge_type_ids: Optional[bool],</span>
<span class="sd">            Whether to load the edge type IDs as numeric from the edge list.</span>
<span class="sd">        edge_list_numeric_node_ids: Optional[bool],</span>
<span class="sd">            Whether to load the edge node IDs as numeric from the edge list.</span>
<span class="sd">        skip_weights_if_unavailable: Optional[bool],</span>
<span class="sd">            Whether to skip the weights without raising an error if these are unavailable.</span>
<span class="sd">        skip_edge_types_if_unavailable: Optional[bool],</span>
<span class="sd">            Whether to skip the edge types without raising an error if these are unavailable.</span>
<span class="sd">        edge_list_is_complete: Optional[bool],</span>
<span class="sd">            Whether to consider the edge list as complete, i.e. the edges are presented in both directions when loading an undirected graph.</span>
<span class="sd">        edge_list_may_contain_duplicates: Optional[bool],</span>
<span class="sd">            Whether the edge list may contain duplicates. If the edge list surely DOES NOT contain duplicates, a validation step may be skipped. By default, it is assumed that the edge list may contain duplicates.</span>
<span class="sd">        edge_list_is_sorted: Optional[bool],</span>
<span class="sd">            Whether the edge list is sorted. Note that a sorted edge list has the minimal memory peak, but requires the nodes number and the edges number.</span>
<span class="sd">        edge_list_is_correct: Optional[bool],</span>
<span class="sd">            Whether the edges file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.</span>
<span class="sd">        edge_list_max_rows_number: Optional[int],</span>
<span class="sd">            The maximum number of lines to be loaded from the edges file.</span>
<span class="sd">        edge_list_comment_symbol: Optional[str],</span>
<span class="sd">            The comment symbol to skip lines in the edges file. Lines starting with this symbol will be skipped.</span>
<span class="sd">        edges_number: Optional[int],</span>
<span class="sd">            The expected number of edges. Note that this must be the EXACT number of edges in the graph.</span>
<span class="sd">        load_edge_list_in_parallel: Optional[bool],</span>
<span class="sd">            Whether to load the edge list in parallel. Note that, if the edge IDs indices are not given, it is NOT possible to load a sorted edge list. Similarly, when loading in parallel, without edge IDs, the edges may not be loaded in a deterministic order.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show a loading bar while reading the files. Note that, if parallel loading is enabled, loading bars will not be showed because they are a synchronization bottleneck.</span>
<span class="sd">        may_have_singletons: Optional[bool],</span>
<span class="sd">            Whether the graph may be expected to have singleton nodes. If it is said that it surely DOES NOT have any, it will allow for some speedups and lower mempry peaks.</span>
<span class="sd">        may_have_singleton_with_selfloops: Optional[bool],</span>
<span class="sd">            Whether the graph may be expected to have singleton nodes with selfloops. If it is said that it surely DOES NOT have any, it will allow for some speedups and lower mempry peaks.</span>
<span class="sd">        directed: bool,</span>
<span class="sd">            Whether to load the graph as directed or undirected.</span>
<span class="sd">        name: Optional[str],</span>
<span class="sd">            The name of the graph to be loaded.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.generate_barbell_graph"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.generate_barbell_graph">[docs]</a>    <span class="k">def</span> <span class="nf">generate_barbell_graph</span><span class="p">(</span><span class="n">minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">left_clique_nodes_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">right_clique_nodes_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">chain_nodes_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">left_clique_node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">right_clique_node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">chain_node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">left_clique_edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">right_clique_edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">chain_edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">left_clique_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">right_clique_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">chain_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Creates new barbell graph with given sizes and types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        minimum_node_id: Optional[int],</span>
<span class="sd">            Minimum node ID to start with. May be needed when chaining graphs. By default 0.</span>
<span class="sd">        left_clique_nodes_number: Optional[int],</span>
<span class="sd">            Number of nodes in the left clique. By default 10.</span>
<span class="sd">        right_clique_nodes_number: Optional[int],</span>
<span class="sd">             Number of nodes in the right clique. By default equal to the left clique.</span>
<span class="sd">        chain_nodes_number: Optional[int],</span>
<span class="sd">            Number of nodes in the chain. By default 10.</span>
<span class="sd">        include_selfloops: Optional[bool],</span>
<span class="sd">            Whether to include selfloops.</span>
<span class="sd">        left_clique_node_type: Optional[str],</span>
<span class="sd">            The node type to use for the left clique. By default &#39;left_clique&#39;.</span>
<span class="sd">        right_clique_node_type: Optional[str],</span>
<span class="sd">            The node type to use for the right clique. By default &#39;right_clique&#39;.</span>
<span class="sd">        chain_node_type: Optional[str],</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        left_clique_edge_type: Optional[str],</span>
<span class="sd">            The node type to use for the left clique. By default &#39;left_clique&#39;.</span>
<span class="sd">        right_clique_edge_type: Optional[str],</span>
<span class="sd">            The node type to use for the right clique. By default &#39;right_clique&#39;.</span>
<span class="sd">        chain_edge_type: Optional[str],</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        left_clique_weight: Optional[float],</span>
<span class="sd">            The weight to use for the edges in the left clique. By default None.</span>
<span class="sd">        right_clique_weight: Optional[float],</span>
<span class="sd">            The weight to use for the edges in the right clique. By default None.</span>
<span class="sd">        chain_weight: Optional[float],</span>
<span class="sd">            The weight to use for the edges in the chain. By default None.</span>
<span class="sd">        directed: Optional[bool],</span>
<span class="sd">            Whether the graph is to built as directed. By default false.</span>
<span class="sd">        name: Optional[str],</span>
<span class="sd">            Name of the graph. By default &#39;Barbell&#39;.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the edge weights are provided only for a subset.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.generate_chain_graph"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.generate_chain_graph">[docs]</a>    <span class="k">def</span> <span class="nf">generate_chain_graph</span><span class="p">(</span><span class="n">minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nodes_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Creates new chain graph with given sizes and types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        minimum_node_id: Optional[int],</span>
<span class="sd">            Minimum node ID to start with. May be needed when chaining graphs. By default 0.</span>
<span class="sd">        nodes_number: Optional[int],</span>
<span class="sd">            Number of nodes in the chain. By default 10.</span>
<span class="sd">        include_selfloops: Optional[bool],</span>
<span class="sd">            Whether to include selfloops.</span>
<span class="sd">        node_type: Optional[str],</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        edge_type: Optional[str],</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        weight: Optional[float],</span>
<span class="sd">            The weight to use for the edges in the chain. By default None.</span>
<span class="sd">        directed: Optional[bool],</span>
<span class="sd">            Whether the graph is to built as directed. By default false.</span>
<span class="sd">        name: Optional[str],</span>
<span class="sd">            Name of the graph. By default &#39;Chain&#39;.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.generate_circle_graph"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.generate_circle_graph">[docs]</a>    <span class="k">def</span> <span class="nf">generate_circle_graph</span><span class="p">(</span><span class="n">minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nodes_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Creates new circle graph with given sizes and types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        minimum_node_id: Optional[int],</span>
<span class="sd">            Minimum node ID to start with. May be needed when circleing graphs. By default 0.</span>
<span class="sd">        nodes_number: Optional[int],</span>
<span class="sd">            Number of nodes in the circle. By default 10.</span>
<span class="sd">        include_selfloops: Optional[bool],</span>
<span class="sd">            Whether to include selfloops.</span>
<span class="sd">        node_type: Optional[str],</span>
<span class="sd">            The node type to use for the circle. By default &#39;circle&#39;.</span>
<span class="sd">        edge_type: Optional[str],</span>
<span class="sd">            The node type to use for the circle. By default &#39;circle&#39;.</span>
<span class="sd">        weight: Optional[float],</span>
<span class="sd">            The weight to use for the edges in the circle. By default None.</span>
<span class="sd">        directed: Optional[bool],</span>
<span class="sd">            Whether the graph is to built as directed. By default false.</span>
<span class="sd">        name: Optional[str],</span>
<span class="sd">            Name of the graph. By default &#39;Circle&#39;.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.generate_complete_graph"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.generate_complete_graph">[docs]</a>    <span class="k">def</span> <span class="nf">generate_complete_graph</span><span class="p">(</span><span class="n">minimum_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nodes_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Creates new complete graph with given sizes and types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        minimum_node_id: Optional[int],</span>
<span class="sd">            Minimum node ID to start with. May be needed when combining graphs. By default 0.</span>
<span class="sd">        nodes_number: Optional[int],</span>
<span class="sd">            Number of nodes in the chain. By default 10.</span>
<span class="sd">        include_selfloops: Optional[bool],</span>
<span class="sd">            Whether to include selfloops.</span>
<span class="sd">        node_type: Optional[str],</span>
<span class="sd">            The node type to use. By default &#39;complete&#39;.</span>
<span class="sd">        edge_type: Optional[str],</span>
<span class="sd">            The node type to use. By default &#39;complete&#39;.</span>
<span class="sd">        weight: Optional[float],</span>
<span class="sd">            The weight to use for the edges. By default None.</span>
<span class="sd">        directed: Optional[bool],</span>
<span class="sd">            Whether the graph is to built as directed. By default false.</span>
<span class="sd">        name: Optional[str],</span>
<span class="sd">            Name of the graph. By default &#39;Complete&#39;.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.generate_new_edges_from_node_features"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.generate_new_edges_from_node_features">[docs]</a>    <span class="k">def</span> <span class="nf">generate_new_edges_from_node_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">neighbours_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">max_degree</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">distance_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with edges added extracted from given node_features.</span>
<span class="sd">        </span>
<span class="sd">        This operation might distrupt the graph topology.</span>
<span class="sd">        Proceed with caution!</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        features: List[List[float]],</span>
<span class="sd">            node_features to use to identify the new neighbours.</span>
<span class="sd">        neighbours_number: Optional[int],</span>
<span class="sd">            Number of neighbours to add.</span>
<span class="sd">        max_degree: Optional[int],</span>
<span class="sd">            The maximum degree a node can have its neighbours augmented. By default 0, that is, only singletons are augmented.</span>
<span class="sd">        distance_name: Optional[str],</span>
<span class="sd">            Name of distance to use. Can either be L2 or COSINE. By default COSINE.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show loading bars.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have nodes.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node_features are not provided exactly for each node.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the node_features do not have a consistent shape.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the provided number of neighbours is zero.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.generate_random_connected_graph"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.generate_random_connected_graph">[docs]</a>    <span class="k">def</span> <span class="nf">generate_random_connected_graph</span><span class="p">(</span><span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">minimum_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">minimum_node_sampling</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maximum_node_sampling</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">nodes_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Creates new random connected graph with given sizes and types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        random_state: int,</span>
<span class="sd">            The random state to use to reproduce the sampling.</span>
<span class="sd">        minimum_node_id: int,</span>
<span class="sd">            The minimum node ID for the connected graph.</span>
<span class="sd">        minimum_node_sampling: int,</span>
<span class="sd">            The minimum amount of nodes to sample per node.</span>
<span class="sd">        maximum_node_sampling: int,</span>
<span class="sd">            The maximum amount of nodes to sample per node.</span>
<span class="sd">        nodes_number: Optional[int],</span>
<span class="sd">            Number of nodes in the chain. By default 10.</span>
<span class="sd">        include_selfloops: Optional[bool],</span>
<span class="sd">            Whether to include selfloops.</span>
<span class="sd">        node_type: Optional[str],</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        edge_type: Optional[str],</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        weight: Optional[float],</span>
<span class="sd">            The weight to use for the edges in the chain. By default None.</span>
<span class="sd">        directed: Optional[bool],</span>
<span class="sd">            Whether the graph is to built as directed. By default false.</span>
<span class="sd">        name: Optional[str],</span>
<span class="sd">            Name of the graph. By default &#39;Chain&#39;.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.generate_random_spanning_tree"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.generate_random_spanning_tree">[docs]</a>    <span class="k">def</span> <span class="nf">generate_random_spanning_tree</span><span class="p">(</span><span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">minimum_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">nodes_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">node_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Creates new random connected graph with given sizes and types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        random_state: int,</span>
<span class="sd">            The random state to use to reproduce the sampling.</span>
<span class="sd">        minimum_node_id: int,</span>
<span class="sd">            The minimum node ID for the connected graph.</span>
<span class="sd">        minimum_node_sampling: int,</span>
<span class="sd">            The minimum amount of nodes to sample per node.</span>
<span class="sd">        maximum_node_sampling: int,</span>
<span class="sd">            The maximum amount of nodes to sample per node.</span>
<span class="sd">        nodes_number: Optional[int],</span>
<span class="sd">            Number of nodes in the chain. By default 10.</span>
<span class="sd">        include_selfloops: Optional[bool],</span>
<span class="sd">            Whether to include selfloops.</span>
<span class="sd">        node_type: Optional[str],</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        edge_type: Optional[str],</span>
<span class="sd">            The node type to use for the chain. By default &#39;chain&#39;.</span>
<span class="sd">        weight: Optional[float],</span>
<span class="sd">            The weight to use for the edges in the chain. By default None.</span>
<span class="sd">        directed: Optional[bool],</span>
<span class="sd">            Whether the graph is to built as directed. By default false.</span>
<span class="sd">        name: Optional[str],</span>
<span class="sd">            Name of the graph. By default &#39;Chain&#39;.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_adamic_adar_index_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_adamic_adar_index_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_adamic_adar_index_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the Adamic/Adar Index for the given pair of nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int,</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int,</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the node IDs are higher than the number of nodes in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_adamic_adar_index_from_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_adamic_adar_index_from_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_adamic_adar_index_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">second_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the Adamic/Adar Index for the given pair of nodes from the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_node_name: str,</span>
<span class="sd">            Node name of the first node.</span>
<span class="sd">        second_node_name: str,</span>
<span class="sd">            Node name of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the given node names do not exist in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_all_shortest_paths"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_all_shortest_paths">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_shortest_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with unweighted shortest paths computed up to the given depth.</span>
<span class="sd">        </span>
<span class="sd">        The returned graph will have no selfloops.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterations: Optional[int],</span>
<span class="sd">            The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show a loading bar while building the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_average_clustering_coefficient"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_average_clustering_coefficient">[docs]</a>    <span class="k">def</span> <span class="nf">get_average_clustering_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low_centrality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns the graph average clustering coefficient.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low_centrality: Optional[int],</span>
<span class="sd">            The threshold over which to switch to parallel matryoshka. By default 50.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show a loading bar.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_betweenness_centrality"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_betweenness_centrality">[docs]</a>    <span class="k">def</span> <span class="nf">get_betweenness_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of betweenness centrality for all nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normalize: Optional[bool],</span>
<span class="sd">            Whether to normalize the values. By default, it is false.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show a loading bar. By default, it is true.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_bfs_topological_sorting_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_bfs_topological_sorting_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_bfs_topological_sorting_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns topological sorting map using breadth-first search from the given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        root_node_id: int,</span>
<span class="sd">            Node ID of node to be used as root of BFS</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given root node ID does not exist in the graph&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_bipartite_edge_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_bipartite_edge_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_bipartite_edge_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">removed_existing_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">first_nodes_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">second_nodes_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">first_node_types_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">second_node_types_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;Return vector of tuple of Node IDs that form the edges of the required bipartite graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        removed_existing_edges: Optional[bool],</span>
<span class="sd">            Whether to filter out the existing edges. By default, true.</span>
<span class="sd">        first_nodes_set: Optional[Set[str]],</span>
<span class="sd">            Optional set of nodes to use to create the first set of nodes of the graph.</span>
<span class="sd">        second_nodes_set: Optional[Set[str]],</span>
<span class="sd">            Optional set of nodes to use to create the second set of nodes of the graph.</span>
<span class="sd">        first_node_types_set: Optional[Set[str]],</span>
<span class="sd">            Optional set of node types to create the first set of nodes of the graph.</span>
<span class="sd">        second_node_types_set: Optional[Set[str]],</span>
<span class="sd">            Optional set of node types to create the second set of nodes of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_bipartite_edges"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_bipartite_edges">[docs]</a>    <span class="k">def</span> <span class="nf">get_bipartite_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">removed_existing_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">first_nodes_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">second_nodes_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">first_node_types_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">second_node_types_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;Return vector of tuple of Node IDs that form the edges of the required bipartite graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        removed_existing_edges: Optional[bool],</span>
<span class="sd">            Whether to filter out the existing edges. By default, true.</span>
<span class="sd">        first_nodes_set: Optional[Set[str]],</span>
<span class="sd">            Optional set of nodes to use to create the first set of nodes of the graph.</span>
<span class="sd">        second_nodes_set: Optional[Set[str]],</span>
<span class="sd">            Optional set of nodes to use to create the second set of nodes of the graph.</span>
<span class="sd">        first_node_types_set: Optional[Set[str]],</span>
<span class="sd">            Optional set of node types to create the first set of nodes of the graph.</span>
<span class="sd">        second_node_types_set: Optional[Set[str]],</span>
<span class="sd">            Optional set of node types to create the second set of nodes of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_breadth_first_search_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_breadth_first_search_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_breadth_first_search_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">compute_predecessors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of minimum paths distances and vector of nodes predecessors from given source node ID and optional destination node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int,</span>
<span class="sd">            Node ID root of the tree of minimum paths.</span>
<span class="sd">        compute_predecessors: Optional[bool],</span>
<span class="sd">            Whether to compute the vector of predecessors.</span>
<span class="sd">        maximal_depth: Optional[int],</span>
<span class="sd">            The maximal number of iterations to execute the DFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given source node ID does not exist in the current graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given optional destination node ID does not exist in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_breadth_first_search_from_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_breadth_first_search_from_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_breadth_first_search_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">compute_predecessors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of minimum paths distances and vector of nodes predecessors from given source node name and optional destination node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str,</span>
<span class="sd">            Node name root of the tree of minimum paths.</span>
<span class="sd">        dst_node_name: Optional[str],</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        compute_predecessors: Optional[bool],</span>
<span class="sd">            Whether to compute the vector of predecessors.</span>
<span class="sd">        maximal_depth: Optional[int],</span>
<span class="sd">            The maximal depth to execute the DFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the weights are to be used and the graph does not have weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given source node name does not exist in the current graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given optional destination node name does not exist in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_breadth_first_search_random_nodes"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_breadth_first_search_random_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">get_breadth_first_search_random_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes_to_sample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">root_node</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return nodes sampled from the neighbourhood of given root nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_nodes_to_sample: int,</span>
<span class="sd">            The number of nodes to sample.</span>
<span class="sd">        root_node: int,</span>
<span class="sd">            The root node from .</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of requested nodes is higher than the number of nodes in the graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given root node does not exist in the curret graph instance.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_clique_edge_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_clique_edge_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_clique_edge_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">allow_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">removed_existing_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">allow_node_type_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">allow_node_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;Return vector of tuple of Node names that form the edges of the required clique.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: Optional[bool],</span>
<span class="sd">            Whether to return the edges as directed or undirected. By default, equal to the graph.</span>
<span class="sd">        allow_selfloops: Optional[bool],</span>
<span class="sd">            Whether to allow self-loops in the clique. By default, equal to the graph.</span>
<span class="sd">        removed_existing_edges: Optional[bool],</span>
<span class="sd">            Whether to filter out the existing edges. By default, true.</span>
<span class="sd">        allow_node_type_set: Optional[Set[str]],</span>
<span class="sd">            Node types to include in the clique.</span>
<span class="sd">        allow_node_set: Optional[Set[str]],</span>
<span class="sd">            Nodes to include i the clique.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_clique_edges"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_clique_edges">[docs]</a>    <span class="k">def</span> <span class="nf">get_clique_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">allow_selfloops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">removed_existing_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">allow_node_type_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">allow_node_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;Return vector of tuple of Node IDs that form the edges of the required clique.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: Optional[bool],</span>
<span class="sd">            Whether to return the edges as directed or undirected. By default, equal to the graph.</span>
<span class="sd">        allow_selfloops: Optional[bool],</span>
<span class="sd">            Whether to allow self-loops in the clique. By default, equal to the graph.</span>
<span class="sd">        removed_existing_edges: Optional[bool],</span>
<span class="sd">            Whether to filter out the existing edges. By default, true.</span>
<span class="sd">        allow_node_type_set: Optional[Set[str]],</span>
<span class="sd">            Node types to include in the clique.</span>
<span class="sd">        allow_node_set: Optional[Set[str]],</span>
<span class="sd">            Nodes to include i the clique.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_closeness_centrality"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_closeness_centrality">[docs]</a>    <span class="k">def</span> <span class="nf">get_closeness_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Return closeness centrality for all nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show an indicative progress bar.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_clustering_coefficient"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_clustering_coefficient">[docs]</a>    <span class="k">def</span> <span class="nf">get_clustering_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low_centrality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns the graph clustering coefficient.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low_centrality: Optional[int],</span>
<span class="sd">            The threshold over which to switch to parallel matryoshka. By default 50.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show a loading bar.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_clustering_coefficient_per_node"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_clustering_coefficient_per_node">[docs]</a>    <span class="k">def</span> <span class="nf">get_clustering_coefficient_per_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low_centrality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns clustering coefficients for all nodes in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low_centrality: Optional[int],</span>
<span class="sd">            The threshold over which to switch to parallel matryoshka. By default 50.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show a loading bar.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_comulative_node_degree_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_comulative_node_degree_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_comulative_node_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the comulative node degree up to the given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            Integer ID of the node.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_connected_components_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_connected_components_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_connected_components_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns number a triple with (number of components, number of nodes of the smallest component, number of nodes of the biggest component )</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show a loading bar or not.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_connected_nodes_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_connected_nodes_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_connected_nodes_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of connected nodes in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_cumulative_node_degrees"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_cumulative_node_degrees">[docs]</a>    <span class="k">def</span> <span class="nf">get_cumulative_node_degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector with node cumulative_node_degrees, that is the comulative node degree&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_degree_centrality"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_degree_centrality">[docs]</a>    <span class="k">def</span> <span class="nf">get_degree_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of unweighted degree centrality for all nodes&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_dense_binary_adjacency_matrix"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_dense_binary_adjacency_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_dense_binary_adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns binary dense adjacency matrix.</span>
<span class="sd">        </span>
<span class="sd">        Beware of using this method on big graphs!</span>
<span class="sd">        It&#39;ll use all of your RAM!&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_dense_nodes_mapping"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_dense_nodes_mapping">[docs]</a>    <span class="k">def</span> <span class="nf">get_dense_nodes_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return mapping from instance not trap nodes to dense nodes&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_dense_weighted_adjacency_matrix"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_dense_weighted_adjacency_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_dense_weighted_adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns binary weighted adjacency matrix.</span>
<span class="sd">        </span>
<span class="sd">        Beware of using this method on big graphs!</span>
<span class="sd">        It&#39;ll use all of your RAM!</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weight: Optional[float],</span>
<span class="sd">            The weight value to use for absent edges. By default, `0.0`.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge weights.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_density"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_density">[docs]</a>    <span class="k">def</span> <span class="nf">get_density</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns density of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_destination_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_destination_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_destination_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the non-unique destination nodes names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool,</span>
<span class="sd">            Whether to filter out the undirected edges.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_destination_node_id_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_destination_node_id_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_destination_node_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns destination node ID corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            The edge ID whose destination node ID is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge ID does not exist in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_destination_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_destination_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_destination_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector on the (non unique) destination nodes of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool,</span>
<span class="sd">            Whether to filter out the undirected edges.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_destination_node_name_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_destination_node_name_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_destination_node_name_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns destination node name corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            The edge ID whose destination node name is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_diameter"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_diameter">[docs]</a>    <span class="k">def</span> <span class="nf">get_diameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_infinity</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns diameter of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ignore_infinity: Optional[bool],</span>
<span class="sd">            Whether to ignore infinite distances, which are present when in the graph exist multiple components.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show a loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain nodes.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_diameter_naive"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_diameter_naive">[docs]</a>    <span class="k">def</span> <span class="nf">get_diameter_naive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_infinity</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns diameter of the graph using naive method.</span>
<span class="sd">        </span>
<span class="sd">        Note that there exists the non-naive method for undirected graphs</span>
<span class="sd">        and it is possible to implement a faster method for directed graphs</span>
<span class="sd">        but we still need to get to it, as it will require an updated</span>
<span class="sd">        succinct data structure.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ignore_infinity: Optional[bool],</span>
<span class="sd">            Whether to ignore infinite distances, which are present when in the graph exist multiple components.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show a loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain nodes.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_dijkstra_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_dijkstra_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_dijkstra_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maybe_dst_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">maybe_dst_node_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">compute_predecessors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of minimum paths distances and vector of nodes predecessors from given source node ID and optional destination node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int,</span>
<span class="sd">            Node ID root of the tree of minimum paths.</span>
<span class="sd">        maybe_dst_node_id: Optional[int],</span>
<span class="sd">            Optional target destination. If provided, Dijkstra will stop upon reaching this node.</span>
<span class="sd">        maybe_dst_node_ids: Optional[List[int]],</span>
<span class="sd">            Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.</span>
<span class="sd">        compute_predecessors: Optional[bool],</span>
<span class="sd">            Whether to compute the vector of predecessors.</span>
<span class="sd">        maximal_depth: Optional[int],</span>
<span class="sd">            The maximal depth to execute the DFS for.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool],</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the weights are to be used and the graph does not have weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given source node ID does not exist in the current graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given optional destination node ID does not exist in the current graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If weights are requested to be treated as probabilities but are not between 0 and 1.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains negative weights.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_dijkstra_from_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_dijkstra_from_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_dijkstra_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">maybe_dst_node_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">maybe_dst_node_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">compute_predecessors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of minimum paths distances and vector of nodes predecessors from given source node name and optional destination node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str,</span>
<span class="sd">            Node name root of the tree of minimum paths.</span>
<span class="sd">        maybe_dst_node_name: Optional[str],</span>
<span class="sd">            Optional target destination node name. If provided, Dijkstra will stop upon reaching this node.</span>
<span class="sd">        maybe_dst_node_names: Optional[List[str]],</span>
<span class="sd">            Optional target destination node names. If provided, Dijkstra will stop upon reaching all of these nodes.</span>
<span class="sd">        compute_predecessors: Optional[bool],</span>
<span class="sd">            Whether to compute the vector of predecessors.</span>
<span class="sd">        maximal_depth: Optional[int],</span>
<span class="sd">            The maximal depth to execute the DFS for.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool],</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the weights are to be used and the graph does not have weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given source node name does not exist in the current graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given optional destination node name does not exist in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_directed_destination_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_directed_destination_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_directed_destination_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector on the (non unique) directed destination nodes of the graph&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_directed_edge_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_directed_edge_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_directed_edge_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the sorted directed edge Ids&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_directed_edge_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_directed_edge_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_directed_edge_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the sorted directed edge names&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_directed_edges_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_directed_edges_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_directed_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of directed edges in the graph&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_directed_modularity_from_node_community_memberships"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_directed_modularity_from_node_community_memberships">[docs]</a>    <span class="k">def</span> <span class="nf">get_directed_modularity_from_node_community_memberships</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the directed modularity of the graph from the given memberships.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of provided memberships does not match the number of nodes of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_directed_source_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_directed_source_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_directed_source_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector on the (non unique) directed source nodes of the graph&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_disconnected_nodes_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_disconnected_nodes_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_disconnected_nodes_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of disconnected nodes within the graph.</span>
<span class="sd">        A Disconnected node is a node which is nor a singleton nor a singleton</span>
<span class="sd">        with selfloops.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_eccentricity_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_eccentricity_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_eccentricity_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted eccentricity of the given node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            Node for which to compute the eccentricity.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool],</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node ID does not exist in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_eccentricity_from_node_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_eccentricity_from_node_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_eccentricity_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted eccentricity of the given node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str,</span>
<span class="sd">            Node for which to compute the eccentricity.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node name does not exist in the current graph instance.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_count_from_edge_type_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_count_from_edge_type_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_count_from_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Return number of edges with given edge type ID.</span>
<span class="sd">        </span>
<span class="sd">        If None is given as an edge type ID, the unknown edge type IDs</span>
<span class="sd">        will be returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: Optional[int],</span>
<span class="sd">            The edge type ID to count the edges of.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_count_from_edge_type_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_count_from_edge_type_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_count_from_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Return number of edges with given edge type name.</span>
<span class="sd">        </span>
<span class="sd">        If None is given as an edge type name, the unknown edge types</span>
<span class="sd">        will be returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_name: Optional[str],</span>
<span class="sd">            The edge type name to count the edges of.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_id_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_id_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_id_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns edge ID corresponding to given source and destination node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int,</span>
<span class="sd">            The source node ID.</span>
<span class="sd">        dst: int,</span>
<span class="sd">            The destination node ID.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_id_from_node_ids_and_edge_type_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_id_from_node_ids_and_edge_type_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_id_from_node_ids_and_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Return edge ID for given tuple of nodes and edge type.</span>
<span class="sd">        </span>
<span class="sd">        This method will return an error if the graph does not contain the</span>
<span class="sd">        requested edge with edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int,</span>
<span class="sd">            Source node of the edge.</span>
<span class="sd">        dst: int,</span>
<span class="sd">            Destination node of the edge.</span>
<span class="sd">        edge_type: Optional[int],</span>
<span class="sd">            Edge Type of the edge.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_id_from_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_id_from_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_id_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return edge ID for given tuple of node names.</span>
<span class="sd">        </span>
<span class="sd">        This method will return an error if the graph does not contain the</span>
<span class="sd">        requested edge with edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_name: str,</span>
<span class="sd">            Source node name of the edge.</span>
<span class="sd">        dst_name: str,</span>
<span class="sd">            Destination node name of the edge.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_id_from_node_names_and_edge_type_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_id_from_node_names_and_edge_type_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_id_from_node_names_and_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Return edge ID for given tuple of node names and edge type name.</span>
<span class="sd">        </span>
<span class="sd">        This method will return an error if the graph does not contain the</span>
<span class="sd">        requested edge with edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_name: str,</span>
<span class="sd">            Source node name of the edge.</span>
<span class="sd">        dst_name: str,</span>
<span class="sd">            Destination node name of the edge.</span>
<span class="sd">        edge_type_name: Optional[str],</span>
<span class="sd">            Edge type name.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_ids_with_known_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_ids_with_known_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_ids_with_known_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns edge IDs of the edges with known edge types</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_ids_with_known_edge_types_mask"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_ids_with_known_edge_types_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_ids_with_known_edge_types_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a boolean vector that for each node contains whether it has an</span>
<span class="sd">        unknown edge type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_ids_with_unknown_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_ids_with_unknown_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_ids_with_unknown_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns edge IDs of the edges with unknown edge types</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_ids_with_unknown_edge_types_mask"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_ids_with_unknown_edge_types_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_ids_with_unknown_edge_types_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a boolean vector that for each node contains whether it has an</span>
<span class="sd">        unknown node type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_label_holdout_graphs"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_label_holdout_graphs">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_label_holdout_graphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns edge-label holdout for training ML algorithms on the graph edge labels.</span>
<span class="sd">        This is commonly used for edge type prediction tasks.</span>
<span class="sd">        </span>
<span class="sd">        This method returns two graphs, the train and the test one.</span>
<span class="sd">        The edges of the graph will be splitted in the train and test graphs according</span>
<span class="sd">        to the `train_size` argument.</span>
<span class="sd">        </span>
<span class="sd">        If stratification is enabled, the train and test will have the same ratios of</span>
<span class="sd">        edge types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float,</span>
<span class="sd">            rate target to reserve for training,</span>
<span class="sd">        use_stratification: Optional[bool],</span>
<span class="sd">            Whether to use edge-label stratification,</span>
<span class="sd">        random_state: Optional[int],</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is required but the graph has singleton edge types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_label_kfold"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_label_kfold">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_label_kfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns edge-label kfold for training ML algorithms on the graph edge labels.</span>
<span class="sd">        This is commonly used for edge type prediction tasks.</span>
<span class="sd">        </span>
<span class="sd">        This method returns two graphs, the train and the test one.</span>
<span class="sd">        The edges of the graph will be splitted in the train and test graphs according</span>
<span class="sd">        to the `train_size` argument.</span>
<span class="sd">        </span>
<span class="sd">        If stratification is enabled, the train and test will have the same ratios of</span>
<span class="sd">        edge types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: int,</span>
<span class="sd">            The number of folds.</span>
<span class="sd">        k_index: int,</span>
<span class="sd">            Which fold to use for the validation.</span>
<span class="sd">        use_stratification: Optional[bool],</span>
<span class="sd">            Whether to use edge-label stratification,</span>
<span class="sd">        random_state: Optional[int],</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is required but the graph has singleton edge types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_label_random_holdout"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_label_random_holdout">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_label_random_holdout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns edge-label holdout for training ML algorithms on the graph edge labels.</span>
<span class="sd">        This is commonly used for edge type prediction tasks.</span>
<span class="sd">        </span>
<span class="sd">        This method returns two graphs, the train and the test one.</span>
<span class="sd">        The edges of the graph will be splitted in the train and test graphs according</span>
<span class="sd">        to the `train_size` argument.</span>
<span class="sd">        </span>
<span class="sd">        If stratification is enabled, the train and test will have the same ratios of</span>
<span class="sd">        edge types.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float,</span>
<span class="sd">            rate target to reserve for training,</span>
<span class="sd">        use_stratification: Optional[bool],</span>
<span class="sd">            Whether to use edge-label stratification,</span>
<span class="sd">        random_state: Optional[int],</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is required but the graph has singleton edge types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the sorted edge Ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool,</span>
<span class="sd">            Whether to filter out the undirected edges.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_node_ids_from_edge_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_node_ids_from_edge_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_node_ids_from_edge_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_node_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;Returns result with the edge node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_node_names: List[Tuple[str, str]],</span>
<span class="sd">            The node names whose node IDs is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            When any of the given node name does not exists in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_node_ids_with_known_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_node_ids_with_known_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_node_ids_with_known_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns edge node IDs of the edges with known edge types</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool,</span>
<span class="sd">            Whether to iterated the edges as a directed or undirected edge list.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_node_ids_with_unknown_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_node_ids_with_unknown_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_node_ids_with_unknown_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns edge node IDs of the edges with unknown edge types</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool,</span>
<span class="sd">            Whether to iterated the edges as a directed or undirected edge list.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the sorted edge names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool,</span>
<span class="sd">            Whether to filter out the undirected edges.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_node_names_from_edge_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_node_names_from_edge_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_node_names_from_edge_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;Returns result with the edge node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_node_ids: List[Tuple[int, int]],</span>
<span class="sd">            The node names whose node names is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            When any of the given node IDs does not exists in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_node_names_with_known_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_node_names_with_known_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_node_names_with_known_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns edge node names of the edges with known edge types</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool,</span>
<span class="sd">            Whether to iterated the edges as a directed or undirected edge list.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_node_names_with_unknown_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_node_names_with_unknown_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_node_names_with_unknown_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns edge node names of the edges with unknown edge types</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool,</span>
<span class="sd">            Whether to iterated the edges as a directed or undirected edge list.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_prediction_kfold"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_prediction_kfold">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_prediction_kfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns train and test graph following kfold validation scheme.</span>
<span class="sd">        </span>
<span class="sd">        The edges are splitted into k chunks. The k_index-th chunk is used to build</span>
<span class="sd">        the validation graph, all the other edges create the training graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: int,</span>
<span class="sd">            The number of folds.</span>
<span class="sd">        k_index: int,</span>
<span class="sd">            Which fold to use for the validation.</span>
<span class="sd">        edge_types: Optional[List[Optional[str]]],</span>
<span class="sd">            Edge types to be selected when computing the folds (All the edge types not listed here will be always be used in the training set).</span>
<span class="sd">        random_state: Optional[int],</span>
<span class="sd">            The random_state (seed) to use for the holdout,</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show the loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of requested k folds is one or zero.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given k fold index is greater than the number of k folds.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If edge types have been specified but it&#39;s an empty list.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of k folds is higher than the number of edges in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_type_id_counts_hashmap"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_type_id_counts_hashmap">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_type_id_counts_hashmap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns edge type IDs counts hashmap.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the current graph instance.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_type_id_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_type_id_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_type_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns edge type of given edge.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            edge whose edge type is to be returned.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_type_id_from_edge_type_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_type_id_from_edge_type_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_type_id_from_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Return edge type ID curresponding to given edge type name.</span>
<span class="sd">        </span>
<span class="sd">        If None is given as an edge type ID, None is returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_name: Optional[str],</span>
<span class="sd">            The edge type name whose ID is to be returned.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_type_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_type_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the edge types of the edges&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_type_ids_from_edge_type_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_type_ids_from_edge_type_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_type_ids_from_edge_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;Return translated edge types from string to internal edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_names: List[Optional[str]],</span>
<span class="sd">            Vector of edge types to be converted.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_type_name_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_type_name_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_type_name_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns option with the edge type of the given edge id.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            The edge ID whose edge type is to be returned.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_type_name_from_edge_type_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_type_name_from_edge_type_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_type_name_from_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return edge type name of given edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: int,</span>
<span class="sd">            Id of the edge type.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_type_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_type_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the edge types names&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_type_names_counts_hashmap"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_type_names_counts_hashmap">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_type_names_counts_hashmap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns edge type names counts hashmap.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the current graph instance.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_types_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_types_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of edge types in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_types_total_memory_requirements"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_types_total_memory_requirements">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_types_total_memory_requirements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns how many bytes are currently used to store the edge types&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_types_total_memory_requirements_human_readable"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_types_total_memory_requirements_human_readable">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_types_total_memory_requirements_human_readable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns human readable amount of how many bytes are currently used to store the edge types&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_weight_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_weight_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_weight_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns weight of the given edge id.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            The edge ID whose weight is to be returned.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_weight_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_weight_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_weight_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns weight of the given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int,</span>
<span class="sd">            The node ID of the source node.</span>
<span class="sd">        dst: int,</span>
<span class="sd">            The node ID of the destination node.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_weight_from_node_ids_and_edge_type_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_weight_from_node_ids_and_edge_type_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_weight_from_node_ids_and_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns weight of the given node ids and edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int,</span>
<span class="sd">            The node ID of the source node.</span>
<span class="sd">        dst: int,</span>
<span class="sd">            The node ID of the destination node.</span>
<span class="sd">        edge_type: Optional[int],</span>
<span class="sd">            The edge type ID of the edge.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_weight_from_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_weight_from_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_weight_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns weight of the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_name: str,</span>
<span class="sd">            The node name of the source node.</span>
<span class="sd">        dst_name: str,</span>
<span class="sd">            The node name of the destination node.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_weight_from_node_names_and_edge_type_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_weight_from_node_names_and_edge_type_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_weight_from_node_names_and_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns weight of the given node names and edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: str,</span>
<span class="sd">            The node name of the source node.</span>
<span class="sd">        dst: str,</span>
<span class="sd">            The node name of the destination node.</span>
<span class="sd">        edge_type: Optional[str],</span>
<span class="sd">            The edge type name of the edge.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_weighting_methods"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_weighting_methods">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_weighting_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of the supported edge weighting methods&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_weights"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_weights">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the weights of the graph edges.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_weights_total_memory_requirements"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_weights_total_memory_requirements">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_weights_total_memory_requirements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns how many bytes are currently used to store the edge weights&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edge_weights_total_memory_requirements_human_readable"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edge_weights_total_memory_requirements_human_readable">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_weights_total_memory_requirements_human_readable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns human readable amount of how many bytes are currently used to store the edge weights&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edges_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edges_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of edges of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edges_total_memory_requirement"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edges_total_memory_requirement">[docs]</a>    <span class="k">def</span> <span class="nf">get_edges_total_memory_requirement</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns how many bytes are currently used to store the edges&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_edges_total_memory_requirement_human_readable"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_edges_total_memory_requirement_human_readable">[docs]</a>    <span class="k">def</span> <span class="nf">get_edges_total_memory_requirement_human_readable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns human readable amount of how many bytes are currently used to store the edges&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_eigenvector_centrality"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_eigenvector_centrality">[docs]</a>    <span class="k">def</span> <span class="nf">get_eigenvector_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximum_iterations_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">tollerance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector with unweighted eigenvector centrality.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maximum_iterations_number: Optional[int],</span>
<span class="sd">            The maximum number of iterations to consider.</span>
<span class="sd">        tollerance: Optional[float],</span>
<span class="sd">            The maximum error tollerance for convergence.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_harmonic_centrality"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_harmonic_centrality">[docs]</a>    <span class="k">def</span> <span class="nf">get_harmonic_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Return harmonic centrality for all nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show an indicative progress bar.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_jaccard_coefficient_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_jaccard_coefficient_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_jaccard_coefficient_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the Jaccard index for the two given nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int,</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int,</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the node IDs are higher than the number of nodes in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_jaccard_coefficient_from_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_jaccard_coefficient_from_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_jaccard_coefficient_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">second_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the Jaccard index for the two given nodes from the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_node_name: str,</span>
<span class="sd">            Node name of the first node.</span>
<span class="sd">        second_node_name: str,</span>
<span class="sd">            Node name of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the given node names do not exist in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_k_shortest_path_node_ids_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_k_shortest_path_node_ids_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_k_shortest_path_node_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the k minimum paths node IDs between given source node and destination node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int,</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int,</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        maximal_depth: Optional[int],</span>
<span class="sd">            The maximal depth to execute the BFS for.</span>
<span class="sd">        k: int,</span>
<span class="sd">            Number of paths to find.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node IDs does not exist in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_k_shortest_path_node_ids_from_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_k_shortest_path_node_ids_from_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_k_shortest_path_node_ids_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the k minimum paths node IDs between given source node and destination node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str,</span>
<span class="sd">            Source node name.</span>
<span class="sd">        dst_node_name: str,</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        k: int,</span>
<span class="sd">            Number of paths to find.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node names does not exist in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_k_shortest_path_node_names_from_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_k_shortest_path_node_names_from_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_k_shortest_path_node_names_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the k minimum paths node names between given source node and destination node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str,</span>
<span class="sd">            Source node name.</span>
<span class="sd">        dst_node_name: str,</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        k: int,</span>
<span class="sd">            Number of paths to find.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node names does not exist in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_known_edge_types_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_known_edge_types_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_known_edge_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of edge with known edge type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_known_edge_types_rate"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_known_edge_types_rate">[docs]</a>    <span class="k">def</span> <span class="nf">get_known_edge_types_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns rate of known edge types over total edges number.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_known_node_types_mask"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_known_node_types_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_known_node_types_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean mask of known node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_known_node_types_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_known_node_types_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_known_node_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of node with known node type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_known_node_types_rate"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_known_node_types_rate">[docs]</a>    <span class="k">def</span> <span class="nf">get_known_node_types_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns rate of known node types over total nodes number.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_laplacian_coo_matrix_edges_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_laplacian_coo_matrix_edges_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_laplacian_coo_matrix_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of edges in the laplacian COO matrix representation of the graph&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_laplacian_transformed_graph"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_laplacian_transformed_graph">[docs]</a>    <span class="k">def</span> <span class="nf">get_laplacian_transformed_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted laplacian transformation of the graph&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_max_encodable_edge_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_max_encodable_edge_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_max_encodable_edge_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return maximum encodable edge number&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_maximum_edge_weight"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_maximum_edge_weight">[docs]</a>    <span class="k">def</span> <span class="nf">get_maximum_edge_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the maximum weight, if graph has weights.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain edge weights.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_maximum_multilabel_count"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_maximum_multilabel_count">[docs]</a>    <span class="k">def</span> <span class="nf">get_maximum_multilabel_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of maximum multilabel count.</span>
<span class="sd">        </span>
<span class="sd">        This value is the maximum number of multilabel counts</span>
<span class="sd">        that appear in any given node in the graph&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_maximum_node_degree"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_maximum_node_degree">[docs]</a>    <span class="k">def</span> <span class="nf">get_maximum_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns maximum node degree of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain any node (is an empty graph).&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_maximum_node_types_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_maximum_node_types_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_maximum_node_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns maximum number of node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_memory_stats"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_memory_stats">[docs]</a>    <span class="k">def</span> <span class="nf">get_memory_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string describing the memory usage of all the fields of all the</span>
<span class="sd">        structures used to store the current graph&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_minimum_edge_types_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_minimum_edge_types_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_minimum_edge_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum number of edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_minimum_node_degree"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_minimum_node_degree">[docs]</a>    <span class="k">def</span> <span class="nf">get_minimum_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum node degree of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain any node (is an empty graph).&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_minimum_node_types_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_minimum_node_types_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_minimum_node_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum number of node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_mininum_edge_weight"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_mininum_edge_weight">[docs]</a>    <span class="k">def</span> <span class="nf">get_mininum_edge_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the minimum weight, if graph has weights.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain edge weights.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_minmax_edge_ids_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_minmax_edge_ids_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_minmax_edge_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return range of outbound edges IDs for all the edges bewteen the given</span>
<span class="sd">        source and destination nodes.</span>
<span class="sd">        This operation is meaningfull only in a multigraph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int,</span>
<span class="sd">            Source node.</span>
<span class="sd">        dst: int,</span>
<span class="sd">            Destination node.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_minmax_edge_ids_from_source_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_minmax_edge_ids_from_source_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_minmax_edge_ids_from_source_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return range of outbound edges IDs which have as source the given Node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int,</span>
<span class="sd">            Node for which we need to compute the cumulative_node_degrees range.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_most_central_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_most_central_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_most_central_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns maximum node degree of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_multiple_node_type_ids_from_node_type_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_multiple_node_type_ids_from_node_type_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_multiple_node_type_ids_from_node_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]):</span>
        <span class="sd">&quot;&quot;&quot;Return translated node types from string to internal node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_names: List[Optional[List[str]]],</span>
<span class="sd">            Vector of node types to be converted.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node type names do not exists in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return name of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_neighbour_node_ids_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_neighbour_node_ids_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_neighbour_node_ids_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector of destinations for the given source node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            Node ID whose neighbours are to be retrieved.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_neighbour_node_ids_from_node_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_neighbour_node_ids_from_node_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_neighbour_node_ids_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector of destinations for the given source node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str,</span>
<span class="sd">            Node ID whose neighbours are to be retrieved.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_neighbour_node_names_from_node_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_neighbour_node_names_from_node_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_neighbour_node_names_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector of destination names for the given source node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str,</span>
<span class="sd">            Node name whose neighbours are to be retrieved.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_connected_component_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_connected_component_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_connected_component_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Return a vector with the components each node belongs to.</span>
<span class="sd">        </span>
<span class="sd">        E.g. If we have two components `[0, 2, 3]` and `[1, 4, 5]` the result will look like</span>
<span class="sd">        `[0, 1, 0, 0, 1, 1]`</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show the loading bar.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_count_from_node_type_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_count_from_node_type_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_count_from_node_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Return number of nodes with given node type ID.</span>
<span class="sd">        </span>
<span class="sd">        If None is given as an node type ID, the unknown node types</span>
<span class="sd">        will be returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_id: Optional[int],</span>
<span class="sd">            The node type ID to count the nodes of.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_count_from_node_type_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_count_from_node_type_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_count_from_node_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Return number of nodes with given node type name.</span>
<span class="sd">        </span>
<span class="sd">        If None is given as an node type name, the unknown node types</span>
<span class="sd">        will be returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_name: Optional[str],</span>
<span class="sd">            The node type name to count the nodes of.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_degree_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_degree_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of outbound neighbours of given node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            Integer ID of the node.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_degree_from_node_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_degree_from_node_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_degree_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of outbound neighbours of given node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str,</span>
<span class="sd">            Integer ID of the node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node name does not exist in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_degrees"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_degrees">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted degree of every node in the graph&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_degrees_mean"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_degrees_mean">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_degrees_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted mean node degree of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_degrees_median"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_degrees_median">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_degrees_median</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted median node degree of the graph&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_degrees_mode"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_degrees_mode">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_degrees_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns mode node degree of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_id_from_node_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_id_from_node_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_id_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns result with the node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str,</span>
<span class="sd">            The node name whose node ID is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            When the given node name does not exists in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the sorted nodes Ids&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the src, dst, edge type and weight of a given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            The edge ID whose source, destination, edge type and weight are to be retrieved.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_ids_and_edge_type_id_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_ids_and_edge_type_id_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_ids_and_edge_type_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the src, dst, edge type of a given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            The edge ID whose source, destination and edge type are to be retrieved.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_ids_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_ids_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_ids_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns node names corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            The edge ID whose source and destination node IDs are to e retrieved.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_ids_from_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_ids_from_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_ids_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns result with the node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_names: List[str],</span>
<span class="sd">            The node names whose node IDs is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            When any of the given node name does not exists in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_ids_with_known_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_ids_with_known_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_ids_with_known_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns node IDs of the nodes with known node types</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_ids_with_known_node_types_mask"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_ids_with_known_node_types_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_ids_with_known_node_types_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a boolean vector that for each node contains whether it has an</span>
<span class="sd">        known node type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_ids_with_unknown_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_ids_with_unknown_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_ids_with_unknown_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns node IDs of the nodes with unknown node types</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_ids_with_unknown_node_types_mask"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_ids_with_unknown_node_types_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_ids_with_unknown_node_types_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a boolean vector that for each node contains whether it has an</span>
<span class="sd">        unknown node type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_indegrees"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_indegrees">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_indegrees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the indegree for each node.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_label_holdout_graphs"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_label_holdout_graphs">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_label_holdout_graphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns node-label holdout for training ML algorithms on the graph node labels.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float,</span>
<span class="sd">            rate target to reserve for training,</span>
<span class="sd">        use_stratification: Optional[bool],</span>
<span class="sd">            Whether to use node-label stratification,</span>
<span class="sd">        random_state: Optional[int],</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a single node type.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a multilabel node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_label_holdout_indices"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_label_holdout_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_label_holdout_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns node-label holdout indices for training ML algorithms on the graph node labels.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float,</span>
<span class="sd">            rate target to reserve for training,</span>
<span class="sd">        use_stratification: Optional[bool],</span>
<span class="sd">            Whether to use node-label stratification,</span>
<span class="sd">        random_state: Optional[int],</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a single node type.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a multilabel node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_label_holdout_labels"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_label_holdout_labels">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_label_holdout_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns node-label holdout indices for training ML algorithms on the graph node labels.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float,</span>
<span class="sd">            rate target to reserve for training,</span>
<span class="sd">        use_stratification: Optional[bool],</span>
<span class="sd">            Whether to use node-label stratification,</span>
<span class="sd">        random_state: Optional[int],</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a single node type.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a multilabel node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_label_kfold"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_label_kfold">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_label_kfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns node-label fold for training ML algorithms on the graph node labels.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: int,</span>
<span class="sd">            The number of folds.</span>
<span class="sd">        k_index: int,</span>
<span class="sd">            Which fold to use for the validation.</span>
<span class="sd">        use_stratification: Optional[bool],</span>
<span class="sd">            Whether to use node-label stratification,</span>
<span class="sd">        random_state: Optional[int],</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a single node type.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a multilabel node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_label_random_holdout"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_label_random_holdout">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_label_random_holdout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">use_stratification</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns node-label holdout for training ML algorithms on the graph node labels.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float,</span>
<span class="sd">            rate target to reserve for training,</span>
<span class="sd">        use_stratification: Optional[bool],</span>
<span class="sd">            Whether to use node-label stratification,</span>
<span class="sd">        random_state: Optional[int],</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a single node type.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If stratification is requested but the graph has a multilabel node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_name_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_name_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_name_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns result with the node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            The node ID whose name is to be returned.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the sorted nodes names&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_names_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_names_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_names_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns node names corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            The edge ID whose source and destination node IDs are to e retrieved.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_names_with_known_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_names_with_known_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_names_with_known_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns node names of the nodes with known node types</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_names_with_unknown_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_names_with_unknown_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_names_with_unknown_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns node names of the nodes with unknown node types</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_ontologies"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_ontologies">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_ontologies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the node predicted ontology.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_report_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_report_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_report_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return human-readable html report of the given node.</span>
<span class="sd">        </span>
<span class="sd">        The report, by default, is rendered using html.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            Whether to show a loading bar in graph operations.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_report_from_node_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_report_from_node_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_report_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return human-readable html report of the given node.</span>
<span class="sd">        </span>
<span class="sd">        The report, by default, is rendered using html.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str,</span>
<span class="sd">            Whether to show a loading bar in graph operations.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_sampling_methods"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_sampling_methods">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_sampling_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of the supported node sampling methods&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_type_id_counts_hashmap"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_type_id_counts_hashmap">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_type_id_counts_hashmap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns node type IDs counts hashmap.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the current graph instance.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_type_id_from_node_type_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_type_id_from_node_type_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_type_id_from_node_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return node type ID curresponding to given node type name.</span>
<span class="sd">        </span>
<span class="sd">        If None is given as an node type ID, None is returned.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_name: str,</span>
<span class="sd">            The node type name whose ID is to be returned.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_type_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_type_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the node types of the graph nodes.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_type_ids_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_type_ids_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_type_ids_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns node type of given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            node whose node type is to be returned.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_type_ids_from_node_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_type_ids_from_node_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_type_ids_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return node type ID for the given node name if available.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str,</span>
<span class="sd">            Name of the node.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_type_ids_from_node_type_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_type_ids_from_node_type_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_type_ids_from_node_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;Return translated node types from string to internal node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_names: List[Optional[str]],</span>
<span class="sd">            Vector of node types to be converted.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_type_name_from_node_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_type_name_from_node_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_type_name_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return node type name for the given node name if available.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str,</span>
<span class="sd">            Name of the node.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_type_name_from_node_type_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_type_name_from_node_type_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_type_name_from_node_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return node type name of given node type.</span>
<span class="sd">        </span>
<span class="sd">        There is no need for a unchecked version since we will have to map</span>
<span class="sd">        on the note_types anyway.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_id: int,</span>
<span class="sd">            Id of the node type.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_type_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_type_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the node types names.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_type_names_counts_hashmap"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_type_names_counts_hashmap">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_type_names_counts_hashmap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns node type names counts hashmap.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the current graph instance.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_type_names_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_type_names_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_type_names_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns result of option with the node type of the given node id.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            The node ID whose node types are to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the node types are not available for the current graph instance.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_type_names_from_node_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_type_names_from_node_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_type_names_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns result of option with the node type of the given node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str,</span>
<span class="sd">            The node name whose node types are to be returned.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_types_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_types_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of node types in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_types_total_memory_requirements"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_types_total_memory_requirements">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_types_total_memory_requirements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns how many bytes are currently used to store the node types&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_types_total_memory_requirements_human_readable"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_types_total_memory_requirements_human_readable">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_types_total_memory_requirements_human_readable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns human readable amount of how many bytes are currently used to store the node types&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_node_urls"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_node_urls">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_urls</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector with the node URLs.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_nodes_mapping"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_nodes_mapping">[docs]</a>    <span class="k">def</span> <span class="nf">get_nodes_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the nodes mapping&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_nodes_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_nodes_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_nodes_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of nodes in the graph&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_nodes_total_memory_requirement"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_nodes_total_memory_requirement">[docs]</a>    <span class="k">def</span> <span class="nf">get_nodes_total_memory_requirement</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns how many bytes are currently used to store the nodes&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_nodes_total_memory_requirement_human_readable"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_nodes_total_memory_requirement_human_readable">[docs]</a>    <span class="k">def</span> <span class="nf">get_nodes_total_memory_requirement_human_readable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns human readable amount of how many bytes are currently used to store the nodes&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_not_singletons_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_not_singletons_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_not_singletons_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return set of nodes that are not singletons&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_number_of_triangles"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_number_of_triangles">[docs]</a>    <span class="k">def</span> <span class="nf">get_number_of_triangles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">low_centrality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns total number of triangles ignoring the weights.</span>
<span class="sd">        </span>
<span class="sd">        The method dispatches the fastest method according to the current</span>
<span class="sd">        graph instance. Specifically:</span>
<span class="sd">        - For directed graphs it will use the naive algorithm.</span>
<span class="sd">        - For undirected graphs it will use Bader&#39;s version.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normalize: Optional[bool],</span>
<span class="sd">            Whether to normalize the number of triangles.</span>
<span class="sd">        low_centrality: Optional[int],</span>
<span class="sd">            The threshold over which to switch to parallel matryoshka. By default 50.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show a loading bar.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_number_of_triangles_per_node"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_number_of_triangles_per_node">[docs]</a>    <span class="k">def</span> <span class="nf">get_number_of_triangles_per_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">low_centrality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of triangles in the graph without taking into account the weights.</span>
<span class="sd">        </span>
<span class="sd">        The method dispatches the fastest method according to the current</span>
<span class="sd">        graph instance. Specifically:</span>
<span class="sd">        - For directed graphs it will use the naive algorithm.</span>
<span class="sd">        - For undirected graphs it will use Bader&#39;s version.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normalize: Optional[bool],</span>
<span class="sd">            Whether to normalize the number of triangles.</span>
<span class="sd">        low_centrality: Optional[int],</span>
<span class="sd">            The threshold over which to switch to parallel matryoshka. By default 50.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show a loading bar.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_okapi_bm25_node_feature_propagation"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_okapi_bm25_node_feature_propagation">[docs]</a>    <span class="k">def</span> <span class="nf">get_okapi_bm25_node_feature_propagation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]],</span> <span class="n">iterations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">maximal_distance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">include_central_node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns okapi node features propagation within given maximal distance.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        features: List[Optional[List[float]]],</span>
<span class="sd">            The features to propagate. Use None to represent eventual unknown features.</span>
<span class="sd">        iterations: Optional[int],</span>
<span class="sd">            The number of iterations to execute. By default one.</span>
<span class="sd">        maximal_distance: Optional[int],</span>
<span class="sd">            The distance to consider for the cooccurrences. The default value is 3.</span>
<span class="sd">        k1: Optional[float],</span>
<span class="sd">            The k1 parameter from okapi. Tipicaly between 1.2 and 2.0. It can be seen as a smoothing.</span>
<span class="sd">        b: Optional[float],</span>
<span class="sd">            The b parameter from okapi. Tipicaly 0.75.</span>
<span class="sd">        include_central_node: Optional[bool],</span>
<span class="sd">            Whether to include the central node. By default true.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_okapi_bm25_node_label_propagation"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_okapi_bm25_node_label_propagation">[docs]</a>    <span class="k">def</span> <span class="nf">get_okapi_bm25_node_label_propagation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">maximal_distance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns okapi node label propagation within given maximal distance.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterations: Optional[int],</span>
<span class="sd">            The number of iterations to execute. By default one.</span>
<span class="sd">        maximal_distance: Optional[int],</span>
<span class="sd">            The distance to consider for the cooccurrences. The default value is 3.</span>
<span class="sd">        k1: Optional[float],</span>
<span class="sd">            The k1 parameter from okapi. Tipicaly between 1.2 and 2.0. It can be seen as a smoothing.</span>
<span class="sd">        b: Optional[float],</span>
<span class="sd">            The b parameter from okapi. Tipicaly 0.75.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_one_hot_encoded_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_one_hot_encoded_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">get_one_hot_encoded_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns one-hot encoded edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_one_hot_encoded_known_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_one_hot_encoded_known_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">get_one_hot_encoded_known_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns one-hot encoded known edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_one_hot_encoded_known_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_one_hot_encoded_known_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">get_one_hot_encoded_known_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns one-hot encoded known node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_one_hot_encoded_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_one_hot_encoded_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">get_one_hot_encoded_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns one-hot encoded node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_parallel_edges_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_parallel_edges_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_parallel_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of edges that have multigraph syblings&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_preferential_attachment_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_preferential_attachment_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_preferential_attachment_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted preferential attachment from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int,</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int,</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        normalize: bool,</span>
<span class="sd">            Whether to normalize by the square of maximum degree.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the node IDs are higher than the number of nodes in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_preferential_attachment_from_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_preferential_attachment_from_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_preferential_attachment_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">second_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted preferential attachment from the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_node_name: str,</span>
<span class="sd">            Node name of the first node.</span>
<span class="sd">        second_node_name: str,</span>
<span class="sd">            Node name of the second node.</span>
<span class="sd">        normalize: bool,</span>
<span class="sd">            Whether to normalize by the square of maximum degree.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the given node names do not exist in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_random_nodes"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_random_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">get_random_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes_to_sample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return random unique sorted numbers.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_nodes_to_sample: int,</span>
<span class="sd">            The number of nodes to sample.</span>
<span class="sd">        random_state: int,</span>
<span class="sd">            The random state to use to reproduce the sampling.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_random_subgraph"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_random_subgraph">[docs]</a>    <span class="k">def</span> <span class="nf">get_random_subgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes_number</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns subgraph with given number of nodes.</span>
<span class="sd">        </span>
<span class="sd">        **This method creates a subset of the graph starting from a random node</span>
<span class="sd">        sampled using given random_state and includes all neighbouring nodes until</span>
<span class="sd">        the required number of nodes is reached**. All the edges connecting any</span>
<span class="sd">        of the selected nodes are then inserted into this graph.</span>
<span class="sd">        </span>
<span class="sd">        This is meant to execute distributed node embeddings.</span>
<span class="sd">        It may also sample singleton nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes_number: int,</span>
<span class="sd">            Number of nodes to extract.</span>
<span class="sd">        random_state: Optional[int],</span>
<span class="sd">            Random random_state to use.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show the loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the requested number of nodes is one or less.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph has less than the requested number of nodes.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_random_walk_normalized_laplacian_transformed_graph"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_random_walk_normalized_laplacian_transformed_graph">[docs]</a>    <span class="k">def</span> <span class="nf">get_random_walk_normalized_laplacian_transformed_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted random walk normalized laplacian transformation of the graph&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_resource_allocation_index_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_resource_allocation_index_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_resource_allocation_index_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int,</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int,</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the node IDs are higher than the number of nodes in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_resource_allocation_index_from_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_resource_allocation_index_from_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_resource_allocation_index_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">second_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_node_name: str,</span>
<span class="sd">            Node name of the first node.</span>
<span class="sd">        second_node_name: str,</span>
<span class="sd">            Node name of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the given node names do not exist in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_reversed_bfs_topological_sorting_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_reversed_bfs_topological_sorting_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_reversed_bfs_topological_sorting_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns topological sorting reversed map using breadth-first search from the given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        root_node_id: int,</span>
<span class="sd">            Node ID of node to be used as root of BFS</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given root node ID does not exist in the graph&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_selfloop_nodes_rate"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_selfloop_nodes_rate">[docs]</a>    <span class="k">def</span> <span class="nf">get_selfloop_nodes_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns rate of self-loops.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_selfloops_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_selfloops_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_selfloops_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of self-loops, including also those in eventual multi-edges.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_shortest_path_node_ids_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_shortest_path_node_ids_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_shortest_path_node_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int,</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int,</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        maximal_depth: Optional[int],</span>
<span class="sd">            The maximal depth to execute the BFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node IDs do not exist in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_shortest_path_node_ids_from_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_shortest_path_node_ids_from_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_shortest_path_node_ids_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str,</span>
<span class="sd">            Source node name.</span>
<span class="sd">        dst_node_name: str,</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        maximal_depth: Optional[int],</span>
<span class="sd">            The maximal depth to execute the BFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node names do not exist in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_shortest_path_node_names_from_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_shortest_path_node_names_from_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_shortest_path_node_names_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str,</span>
<span class="sd">            Source node name.</span>
<span class="sd">        dst_node_name: str,</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        maximal_depth: Optional[int],</span>
<span class="sd">            The maximal depth to execute the BFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node names do not exist in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_singleton_edge_type_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_singleton_edge_type_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_singleton_edge_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton edge types IDs.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_singleton_edge_type_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_singleton_edge_type_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_singleton_edge_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton edge types names.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_singleton_edge_types_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_singleton_edge_types_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_singleton_edge_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of singleton edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_singleton_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_singleton_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_singleton_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton node IDs of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_singleton_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_singleton_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_singleton_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton node names of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_singleton_node_type_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_singleton_node_type_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_singleton_node_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton node types IDs.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_singleton_node_type_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_singleton_node_type_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_singleton_node_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton node types names.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_singleton_node_types_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_singleton_node_types_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_singleton_node_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of singleton node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_singleton_nodes_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_singleton_nodes_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_singleton_nodes_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of singleton nodes within the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_singleton_nodes_with_selfloops_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_singleton_nodes_with_selfloops_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_singleton_nodes_with_selfloops_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of singleton nodes with selfloops within the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_singleton_with_selfloops_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_singleton_with_selfloops_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_singleton_with_selfloops_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton_with_selfloops node IDs of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_singleton_with_selfloops_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_singleton_with_selfloops_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_singleton_with_selfloops_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of singleton_with_selfloops node names of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_source_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_source_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_source_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the non-unique source nodes names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool,</span>
<span class="sd">            Whether to filter out the undirected edges.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_source_node_id_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_source_node_id_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_source_node_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns source node ID corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            The edge ID whose source node ID is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge ID does not exist in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_source_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_source_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_source_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the non-unique source nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directed: bool,</span>
<span class="sd">            Whether to filter out the undirected edges.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_source_node_name_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_source_node_name_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_source_node_name_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns source node name corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            The edge ID whose source node name is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_sparse_edge_weighting_methods"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_sparse_edge_weighting_methods">[docs]</a>    <span class="k">def</span> <span class="nf">get_sparse_edge_weighting_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of the supported sparse edge weighting methods&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_star_edge_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_star_edge_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_star_edge_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">central_node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">removed_existing_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">star_points_nodes_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">star_points_node_types_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;Return vector of tuple of Node names that form the edges of the required star.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        central_node: str,</span>
<span class="sd">            Name of the node to use as center of the star.</span>
<span class="sd">        removed_existing_edges: Optional[bool],</span>
<span class="sd">            Whether to filter out the existing edges. By default, true.</span>
<span class="sd">        star_points_nodes_set: Optional[Set[str]],</span>
<span class="sd">            Optional set of nodes to use to create the set of star points.</span>
<span class="sd">        star_points_node_types_set: Optional[Set[str]],</span>
<span class="sd">            Optional set of node types to create the set of star points.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_star_edges"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_star_edges">[docs]</a>    <span class="k">def</span> <span class="nf">get_star_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">central_node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">removed_existing_edges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">star_points_nodes_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">star_points_node_types_set</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;Return vector of tuple of Node IDs that form the edges of the required star.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        central_node: str,</span>
<span class="sd">            Name of the node to use as center of the star.</span>
<span class="sd">        removed_existing_edges: Optional[bool],</span>
<span class="sd">            Whether to filter out the existing edges. By default, true.</span>
<span class="sd">        star_points_nodes_set: Optional[Set[str]],</span>
<span class="sd">            Optional set of nodes to use to create the set of star points.</span>
<span class="sd">        star_points_node_types_set: Optional[Set[str]],</span>
<span class="sd">            Optional set of node types to create the set of star points.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_stress_centrality"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_stress_centrality">[docs]</a>    <span class="k">def</span> <span class="nf">get_stress_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of stress centrality for all nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normalize: Optional[bool],</span>
<span class="sd">            Whether to normalize the values. By default, it is false.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show a loading bar. By default, it is true.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_subsampled_nodes"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_subsampled_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">get_subsampled_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_nodes_to_sample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">root_node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">node_sampling_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">unique</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Return subsampled nodes according to the given method and parameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        number_of_nodes_to_sample: int,</span>
<span class="sd">            The number of nodes to sample.</span>
<span class="sd">        random_state: int,</span>
<span class="sd">            The random state to reproduce the sampling.</span>
<span class="sd">        root_node: Optional[int],</span>
<span class="sd">            The (optional) root node to use to sample. In not provided, a random one is sampled.</span>
<span class="sd">        node_sampling_method: str,</span>
<span class="sd">            The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.</span>
<span class="sd">        unique: Optional[bool],</span>
<span class="sd">            Whether to make the sampled nodes unique.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node sampling method is not supported.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_symmetric_normalized_laplacian_transformed_graph"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_symmetric_normalized_laplacian_transformed_graph">[docs]</a>    <span class="k">def</span> <span class="nf">get_symmetric_normalized_laplacian_transformed_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted symmetric normalized laplacian transformation of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            The graph must be undirected, as we do not currently support this transformation for directed graphs.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_symmetric_normalized_transformed_graph"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_symmetric_normalized_transformed_graph">[docs]</a>    <span class="k">def</span> <span class="nf">get_symmetric_normalized_transformed_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted symmetric normalized transformation of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            The graph must be undirected, as we do not currently support this transformation for directed graphs.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_top_k_central_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_top_k_central_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_top_k_central_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector with unweighted top k central node Ids.</span>
<span class="sd">        </span>
<span class="sd">        If the k passed is bigger than the number of nodes this method will return</span>
<span class="sd">        all the nodes in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: int,</span>
<span class="sd">            Number of central nodes to extract.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given value k is zero.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph has no nodes.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_top_k_central_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_top_k_central_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_top_k_central_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector with top k central node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: int,</span>
<span class="sd">            Number of central nodes to extract.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_total_edge_weights"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_total_edge_weights">[docs]</a>    <span class="k">def</span> <span class="nf">get_total_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return total edge weights, if graph has weights.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain edge weights.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_total_memory_used"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_total_memory_used">[docs]</a>    <span class="k">def</span> <span class="nf">get_total_memory_used</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns how many bytes are currently used to store the given graph&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_transitive_closure"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_transitive_closure">[docs]</a>    <span class="k">def</span> <span class="nf">get_transitive_closure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns graph to the i-th transitivity closure iteration.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterations: Optional[int],</span>
<span class="sd">            The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show a loading bar while building the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_transitivity"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_transitivity">[docs]</a>    <span class="k">def</span> <span class="nf">get_transitivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low_centrality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns transitivity of the graph without taking into account weights.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low_centrality: Optional[int],</span>
<span class="sd">            The threshold over which to switch to parallel matryoshka. By default 50.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show a loading bar.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_trap_nodes_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_trap_nodes_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_trap_nodes_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of traps (nodes without any outgoing edges that are not singletons)</span>
<span class="sd">        This also includes nodes with only a self-loops, therefore singletons with</span>
<span class="sd">        only a self-loops are not considered traps because you could make a walk on them.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_trap_nodes_rate"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_trap_nodes_rate">[docs]</a>    <span class="k">def</span> <span class="nf">get_trap_nodes_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the traps rate of the graph.</span>
<span class="sd">        </span>
<span class="sd">        THIS IS EXPERIMENTAL AND MUST BE PROVEN!&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_triads_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_triads_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_triads_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns total number of triads in the graph without taking into account weights&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_adamic_adar_index_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_adamic_adar_index_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_adamic_adar_index_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the Adamic/Adar Index for the given pair of nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int,</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int,</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the provided one and two node IDs are higher than the</span>
<span class="sd">         number of nodes in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_all_edge_metrics_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_all_edge_metrics_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_all_edge_metrics_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns all the implemented edge metrics for the two given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Specifically, the returned values are:</span>
<span class="sd">        * Adamic Adar</span>
<span class="sd">        * Jaccard coefficient</span>
<span class="sd">        * Resource allocation index</span>
<span class="sd">        * Preferential attachment</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int,</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int,</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        normalize: bool,</span>
<span class="sd">            Whether to normalize within 0 to 1.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node IDs do not exist in the graph this method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_breadth_first_search_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_breadth_first_search_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_breadth_first_search_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">compute_predecessors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of minimum paths distances and vector of nodes predecessors, if requested.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int,</span>
<span class="sd">            Root of the tree of minimum paths.</span>
<span class="sd">        maybe_dst_node_id: Optional[int],</span>
<span class="sd">            Optional target destination. If provided, Dijkstra will stop upon reaching this node.</span>
<span class="sd">        maybe_dst_node_ids: Optional[List[int]],</span>
<span class="sd">            Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.</span>
<span class="sd">        compute_distances: Optional[bool],</span>
<span class="sd">            Whether to compute the vector of distances.</span>
<span class="sd">        compute_predecessors: Optional[bool],</span>
<span class="sd">            Whether to compute the vector of predecessors.</span>
<span class="sd">        compute_visited: Optional[bool],</span>
<span class="sd">            Whether to compute the vector of visited nodes.</span>
<span class="sd">        maximal_depth: Optional[int],</span>
<span class="sd">            The maximal depth to execute the DFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.</span>
<span class="sd">        </span>
<span class="sd">         TODO! Explore chains accelerations!&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_closeness_centrality_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_closeness_centrality_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_closeness_centrality_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return closeness centrality of the requested node.</span>
<span class="sd">        </span>
<span class="sd">        If the given node ID does not exist in the current graph the method</span>
<span class="sd">        will panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            The node ID whose closeness centrality is to be computed.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show an indicative progress bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the graph the method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_comulative_node_degree_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_comulative_node_degree_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_comulative_node_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the comulative node degree up to the given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            Integer ID of the node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_destination_node_id_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_destination_node_id_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_destination_node_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the destination of given edge id without making any boundary check.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            The edge ID whose destination is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will cause an out of bounds.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_destination_node_name_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_destination_node_name_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_destination_node_name_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns destination node name corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            The edge ID whose destination node name is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_dijkstra_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_dijkstra_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_dijkstra_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maybe_dst_node_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">maybe_dst_node_ids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">compute_predecessors</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of minimum paths distances and vector of nodes predecessors, if requested.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int,</span>
<span class="sd">            Root of the tree of minimum paths.</span>
<span class="sd">        maybe_dst_node_id: Optional[int],</span>
<span class="sd">            Optional target destination. If provided, Dijkstra will stop upon reaching this node.</span>
<span class="sd">        maybe_dst_node_ids: Optional[List[int]],</span>
<span class="sd">            Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.</span>
<span class="sd">        compute_predecessors: bool,</span>
<span class="sd">            Whether to compute the vector of predecessors.</span>
<span class="sd">        maximal_depth: Optional[int],</span>
<span class="sd">            The maximal number of iterations to execute Dijkstra for.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool],</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_eccentricity_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_eccentricity_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_eccentricity_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns unweighted eccentricity of the given node.</span>
<span class="sd">        </span>
<span class="sd">        This method will panic if the given node ID does not exists in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            Node for which to compute the eccentricity.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_edge_count_from_edge_type_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_edge_count_from_edge_type_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_edge_count_from_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Return number of edges of the given edge type without checks.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type: Optional[int],</span>
<span class="sd">            The edge type to retrieve count of.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge type ID does not exist in the graph the method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_edge_id_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_edge_id_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_edge_id_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns edge ID corresponding to given source and destination node IDs.</span>
<span class="sd">        </span>
<span class="sd">        The method will panic if the given source and destination node IDs do</span>
<span class="sd">        not correspond to an edge in this graph instance.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int,</span>
<span class="sd">            The source node ID.</span>
<span class="sd">        dst: int,</span>
<span class="sd">            The destination node ID.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs do not exist in the graph the method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_edge_id_from_node_ids_and_edge_type_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_edge_id_from_node_ids_and_edge_type_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_edge_id_from_node_ids_and_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Return edge ID without any checks for given tuple of nodes and edge type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int,</span>
<span class="sd">            Source node of the edge.</span>
<span class="sd">        dst: int,</span>
<span class="sd">            Destination node of the edge.</span>
<span class="sd">        edge_type: Optional[int],</span>
<span class="sd">            Edge Type of the edge.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node IDs or edge type does not exists in the graph this method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_edge_type_id_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_edge_type_id_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_edge_type_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns edge type of given edge.</span>
<span class="sd">        </span>
<span class="sd">        This method will panic if the given edge ID is greater than</span>
<span class="sd">        the number of edges in the graph.</span>
<span class="sd">        Furthermore, if the graph does NOT have edge types, it will NOT</span>
<span class="sd">        return neither an error or a panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            edge whose edge type is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_edge_type_id_from_edge_type_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_edge_type_id_from_edge_type_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_edge_type_id_from_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return edge type ID corresponding to the given edge type name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_name: str,</span>
<span class="sd">            The edge type name whose edge type ID is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge type name does not exists in the considered graph the method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_edge_type_name_from_edge_type_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_edge_type_name_from_edge_type_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_edge_type_name_from_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Return edge type ID corresponding to the given edge type name</span>
<span class="sd">        raising panic if edge type ID does not exists in current graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: Optional[int],</span>
<span class="sd">            The edge type naIDme whose edge type name is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge type ID does not exist in the graph the method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_edge_weight_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_edge_weight_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_edge_weight_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns option with the weight of the given edge id.</span>
<span class="sd">        </span>
<span class="sd">        This method will raise a panic if the given edge ID is higher than</span>
<span class="sd">        the number of edges in the graph. Additionally, it will simply</span>
<span class="sd">        return None if there are no graph weights.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            The edge whose edge weight is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exists in the graph this method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_edge_weight_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_edge_weight_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_edge_weight_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns option with the weight of the given node ids.</span>
<span class="sd">        </span>
<span class="sd">        This method will raise a panic if the given node IDs are higher than</span>
<span class="sd">        the number of nodes in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int,</span>
<span class="sd">            The source node ID.</span>
<span class="sd">        dst: int,</span>
<span class="sd">            The destination node ID.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the two given node IDs does not exists in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_harmonic_centrality_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_harmonic_centrality_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_harmonic_centrality_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return harmonic centrality of the requested node.</span>
<span class="sd">        </span>
<span class="sd">        If the given node ID does not exist in the current graph the method</span>
<span class="sd">        will panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            The node ID whose harmonic centrality is to be computed.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the graph the method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_jaccard_coefficient_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_jaccard_coefficient_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_jaccard_coefficient_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the Jaccard index for the two given nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int,</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int,</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the provided one and two node IDs are higher than the</span>
<span class="sd">         number of nodes in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_k_shortest_path_node_ids_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_k_shortest_path_node_ids_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_k_shortest_path_node_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector of the k minimum paths node IDs between given source node and destination node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int,</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int,</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        k: int,</span>
<span class="sd">            Number of paths to find.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_maximum_node_degree"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_maximum_node_degree">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_maximum_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the maximum node degree.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        The method will return an undefined value (0) when the graph</span>
<span class="sd">        does not contain nodes. In those cases the value is not properly</span>
<span class="sd">        defined.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_maximum_preferential_attachment"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_maximum_preferential_attachment">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_maximum_preferential_attachment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the maximum unweighted preferential attachment score.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the graph does not contain nodes, the return value will be undefined.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_minimum_node_degree"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_minimum_node_degree">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_minimum_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the minimum node degree.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        The method will return an undefined value (0) when the graph</span>
<span class="sd">        does not contain nodes. In those cases the value is not properly</span>
<span class="sd">        defined.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_minimum_preferential_attachment"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_minimum_preferential_attachment">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_minimum_preferential_attachment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the minumum unweighted preferential attachment score.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the graph does not contain nodes, the return value will be undefined.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_minmax_edge_ids_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_minmax_edge_ids_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_minmax_edge_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return range of outbound edges IDs for all the edges bewteen the given</span>
<span class="sd">        source and destination nodes.</span>
<span class="sd">        This operation is meaningfull only in a multigraph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int,</span>
<span class="sd">            Source node.</span>
<span class="sd">        dst: int,</span>
<span class="sd">            Destination node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node type IDs do not exist in the graph this method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_minmax_edge_ids_from_source_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_minmax_edge_ids_from_source_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_minmax_edge_ids_from_source_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return range of outbound edges IDs which have as source the given Node.</span>
<span class="sd">        </span>
<span class="sd">        The method will panic if the given source node ID is higher than</span>
<span class="sd">        the number of nodes in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int,</span>
<span class="sd">            Node for which we need to compute the cumulative_node_degrees range.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_most_central_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_most_central_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_most_central_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns maximum node degree of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        This method fails with a panic if the graph does not have any node.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_node_degree_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_node_degree_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_node_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of outbound neighbours of given node.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            Integer ID of the node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_node_id_from_node_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_node_id_from_node_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_node_id_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns node id from given node name raising a panic if used unproperly.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str,</span>
<span class="sd">            The node name whose node ID is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node name does not exists in the considered graph the method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the src, dst, edge type and weight of a given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        This method will raise a panic when an improper configuration is used.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            The edge ID whose source, destination, edge type and weight are to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_node_ids_and_edge_type_id_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_node_ids_and_edge_type_id_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_node_ids_and_edge_type_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the src, dst, edge type of a given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        This method will raise a panic when an improper configuration is used.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            The edge ID whose source, destination and edge type are to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_node_ids_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_node_ids_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_node_ids_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns node IDs corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        The method will panic if the given edge ID does not exists in the</span>
<span class="sd">        current graph instance.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            The edge ID whose source and destination node IDs are to e retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_node_name_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_node_name_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_node_name_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns result with the node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            The node ID whose name is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_node_names_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_node_names_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_node_names_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns node names corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            The edge ID whose source and destination node IDs are to e retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_node_type_id_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_node_type_id_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_node_type_id_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns option with vector of node types of given node.</span>
<span class="sd">        </span>
<span class="sd">        This method will panic if the given node ID is greater than</span>
<span class="sd">        the number of nodes in the graph.</span>
<span class="sd">        Furthermore, if the graph does NOT have node types, it will NOT</span>
<span class="sd">        return neither an error or a panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            node whose node type is to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        Even though the method will return an option when the node types are</span>
<span class="sd">         not available for the current graph, the behaviour is undefined.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_node_type_names_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_node_type_names_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_node_type_names_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns result of option with the node type of the given node id.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            The node ID whose node types are to be returned.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        This method will return an iterator of None values when the graph</span>
<span class="sd">         does not contain node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_node_type_names_from_node_type_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_node_type_names_from_node_type_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_node_type_names_from_node_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Return node type name of given node type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_ids: List[int],</span>
<span class="sd">            Id of the node type.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        The method will panic if the graph does not contain node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_preferential_attachment_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_preferential_attachment_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_preferential_attachment_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted preferential attachment from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int,</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int,</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        normalize: bool,</span>
<span class="sd">            Whether to normalize within 0 to 1.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the provided one and two node IDs are higher than the</span>
<span class="sd">         number of nodes in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_resource_allocation_index_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_resource_allocation_index_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_resource_allocation_index_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int,</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int,</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the provided one and two node IDs are higher than the</span>
<span class="sd">         number of nodes in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_shortest_path_node_ids_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_shortest_path_node_ids_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_shortest_path_node_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node IDs and distance from given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int,</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int,</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        maximal_depth: Optional[int],</span>
<span class="sd">            The maximal depth to execute the BFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node is a selfloop.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there is no path between the two given nodes.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_shortest_path_node_names_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_shortest_path_node_names_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_shortest_path_node_names_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int,</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int,</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        maximal_depth: Optional[int],</span>
<span class="sd">            The maximal depth to execute the BFS for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_source_node_id_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_source_node_id_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_source_node_id_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the source of given edge id without making any boundary check.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            The edge ID whose source is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will cause an out of bounds.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_source_node_name_from_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_source_node_name_from_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_source_node_name_from_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns source node name corresponding to given edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            The edge ID whose source node name is to be retrieved.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given edge ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_unique_source_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_unique_source_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_unique_source_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns edge ID corresponding to given source and destination node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_id: int,</span>
<span class="sd">            The source node ID.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given source node ID does not exist in the current graph the method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_weighted_closeness_centrality_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_weighted_closeness_centrality_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_closeness_centrality_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return closeness centrality of the requested node.</span>
<span class="sd">        </span>
<span class="sd">        If the given node ID does not exist in the current graph the method</span>
<span class="sd">        will panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            The node ID whose closeness centrality is to be computed.</span>
<span class="sd">        use_edge_weights_as_probabilities: bool,</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the graph the method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_weighted_eccentricity_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_weighted_eccentricity_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_eccentricity_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns weighted eccentricity of the given node.</span>
<span class="sd">        </span>
<span class="sd">        This method will panic if the given node ID does not exists in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            Node for which to compute the eccentricity.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool],</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_weighted_harmonic_centrality_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_weighted_harmonic_centrality_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_harmonic_centrality_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return harmonic centrality of the requested node.</span>
<span class="sd">        </span>
<span class="sd">        If the given node ID does not exist in the current graph the method</span>
<span class="sd">        will panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            The node ID whose harmonic centrality is to be computed.</span>
<span class="sd">        use_edge_weights_as_probabilities: bool,</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the graph the method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_weighted_maximum_preferential_attachment"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_weighted_maximum_preferential_attachment">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_maximum_preferential_attachment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the maximum weighted preferential attachment score.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the graph does not contain nodes, the return value will be undefined.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_weighted_minimum_preferential_attachment"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_weighted_minimum_preferential_attachment">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_minimum_preferential_attachment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the minumum weighted preferential attachment score.</span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the graph does not contain nodes, the return value will be undefined.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_weighted_node_degree_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_weighted_node_degree_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_node_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted sum of outbound neighbours of given node.</span>
<span class="sd">        </span>
<span class="sd">        The method will panic if the given node id is higher than the number of</span>
<span class="sd">        nodes in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            Integer ID of the node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exist in the current graph the method will raise a panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_weighted_preferential_attachment_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_weighted_preferential_attachment_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_preferential_attachment_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted preferential attachment from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int,</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int,</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        normalize: bool,</span>
<span class="sd">            Whether to normalize within 0 to 1.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the provided one and two node IDs are higher than the</span>
<span class="sd">         number of nodes in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_weighted_resource_allocation_index_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_weighted_resource_allocation_index_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_resource_allocation_index_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted Resource Allocation Index for the given pair of nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int,</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int,</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If either of the provided one and two node IDs are higher than the</span>
<span class="sd">         number of nodes in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_weighted_shortest_path_node_ids_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_weighted_shortest_path_node_ids_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_shortest_path_node_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node IDs and distance from given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int,</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int,</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool],</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        maximal_depth: Optional[int],</span>
<span class="sd">            The maximal number of iterations to execute Dijkstra for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unchecked_weighted_shortest_path_node_names_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unchecked_weighted_shortest_path_node_names_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unchecked_weighted_shortest_path_node_names_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int,</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int,</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool],</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        maximal_depth: Optional[int],</span>
<span class="sd">            The maximal number of iterations to execute Dijkstra for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If any of the given node IDs does not exist in the graph the method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_undirected_edges_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_undirected_edges_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_undirected_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of undirected edges of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_undirected_louvain_community_detection"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_undirected_louvain_community_detection">[docs]</a>    <span class="k">def</span> <span class="nf">get_undirected_louvain_community_detection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursion_minimum_improvement</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">first_phase_minimum_improvement</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">patience</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of vectors of communities for each layer of hierarchy minimizing undirected modularity.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        recursion_minimum_improvement: Optional[float],</span>
<span class="sd">            The minimum improvement to warrant another resursion round. By default, zero.</span>
<span class="sd">        first_phase_minimum_improvement: Optional[float],</span>
<span class="sd">            The minimum improvement to warrant another first phase iteration. By default, `0.00001` (not zero because of numerical instability).</span>
<span class="sd">        patience: Optional[int],</span>
<span class="sd">            How many iterations of the first phase to wait for before stopping. By default, `5`.</span>
<span class="sd">        random_state: Optional[int],</span>
<span class="sd">            The random state to use to reproduce this modularity computation. By default, 42.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is not directed.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the `recursion_minimum_improvement` has an invalid value, i.e. NaN or infinity.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the `first_phase_minimum_improvement` has an invalid value, i.e. NaN or infinity.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_undirected_modularity_from_node_community_memberships"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_undirected_modularity_from_node_community_memberships">[docs]</a>    <span class="k">def</span> <span class="nf">get_undirected_modularity_from_node_community_memberships</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the undirected modularity of the graph from the given memberships.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of provided memberships does not match the number of nodes of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_uniform_random_walk_random_nodes"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_uniform_random_walk_random_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">get_uniform_random_walk_random_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">walk_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">unique</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns unique nodes sampled from uniform random walk.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node: int,</span>
<span class="sd">            Node from where to start the random walks.</span>
<span class="sd">        random_state: int,</span>
<span class="sd">            the random_state to use for extracting the nodes and edges.</span>
<span class="sd">        walk_length: int,</span>
<span class="sd">            Length of the random walk.</span>
<span class="sd">        unique: Optional[bool],</span>
<span class="sd">            Whether to make the sampled nodes unique.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node does not exist in the current slack.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unique_directed_edges_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unique_directed_edges_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_directed_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of the unique edges in the graph&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unique_edge_type_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unique_edge_type_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_edge_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the unique edge type IDs of the graph edges.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unique_edge_type_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unique_edge_type_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_edge_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the edge types names&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unique_edges_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unique_edges_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of unique edges of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unique_node_type_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unique_node_type_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_node_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the unique node type IDs of the graph nodes.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unique_node_type_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unique_node_type_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_node_type_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the unique node types names.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unique_selfloops_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unique_selfloops_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_selfloops_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of unique self-loops, excluding those in eventual multi-edges.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unique_source_nodes_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unique_source_nodes_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_source_nodes_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of the source nodes.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unique_undirected_edges_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unique_undirected_edges_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_undirected_edges_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of undirected edges of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unknown_edge_types_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unknown_edge_types_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_unknown_edge_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of unknown edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unknown_edge_types_rate"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unknown_edge_types_rate">[docs]</a>    <span class="k">def</span> <span class="nf">get_unknown_edge_types_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns rate of unknown edge types over total edges number.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unknown_node_types_mask"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unknown_node_types_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_unknown_node_types_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean mask of unknown node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unknown_node_types_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unknown_node_types_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_unknown_node_types_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of nodes with unknown node type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_unknown_node_types_rate"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_unknown_node_types_rate">[docs]</a>    <span class="k">def</span> <span class="nf">get_unknown_node_types_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns rate of unknown node types over total nodes number.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_all_shortest_paths"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_all_shortest_paths">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_all_shortest_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with weighted shortest paths computed up to the given depth.</span>
<span class="sd">        </span>
<span class="sd">        The returned graph will have no selfloops.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterations: Optional[int],</span>
<span class="sd">            The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool],</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show a loading bar while building the graph.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains negative weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_closeness_centrality"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_closeness_centrality">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_closeness_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Return closeness centrality for all nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        use_edge_weights_as_probabilities: bool,</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show an indicative progress bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains negative weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_degree_centrality"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_degree_centrality">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_degree_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector of weighted degree centrality for all nodes&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_diameter_naive"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_diameter_naive">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_diameter_naive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_infinity</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns diameter of the graph using naive method.</span>
<span class="sd">        </span>
<span class="sd">        Note that there exists the non-naive method for undirected graphs</span>
<span class="sd">        and it is possible to implement a faster method for directed graphs</span>
<span class="sd">        but we still need to get to it, as it will require an updated</span>
<span class="sd">        succinct data structure.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ignore_infinity: Optional[bool],</span>
<span class="sd">            Whether to ignore infinite distances, which are present when in the graph exist multiple components.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool],</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show a loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain nodes.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains negative weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_eccentricity_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_eccentricity_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_eccentricity_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns weighted eccentricity of the given node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            Node for which to compute the eccentricity.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool],</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node ID does not exist in the graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If weights are requested to be treated as probabilities but are not between 0 and 1.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains negative weights.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_eccentricity_from_node_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_eccentricity_from_node_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_eccentricity_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns weighted eccentricity of the given node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str,</span>
<span class="sd">            Node for which to compute the eccentricity.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool],</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node name does not exist in the graph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If weights are requested to be treated as probabilities but are not between 0 and 1.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains negative weights.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_eigenvector_centrality"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_eigenvector_centrality">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_eigenvector_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximum_iterations_number</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">tollerance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns vector with unweighted eigenvector centrality.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maximum_iterations_number: Optional[int],</span>
<span class="sd">            The maximum number of iterations to consider.</span>
<span class="sd">        tollerance: Optional[float],</span>
<span class="sd">            The maximum error tollerance for convergence.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_harmonic_centrality"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_harmonic_centrality">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_harmonic_centrality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Return harmonic centrality for all nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool],</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show an indicative progress bar.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_maximum_node_degree"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_maximum_node_degree">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_maximum_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the maximum weighted node degree&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_minimum_node_degree"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_minimum_node_degree">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_minimum_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the minimum weighted node degree&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_node_degree_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_node_degree_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_node_degree_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted sum of outbound neighbours of given node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            Integer ID of the node.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_node_degrees"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_node_degrees">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_node_degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted degree of every node in the graph&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_node_degrees_mean"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_node_degrees_mean">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_node_degrees_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns weighted mean node degree of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_node_degrees_median"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_node_degrees_median">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_node_degrees_median</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns weighted median node degree of the graph&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_node_indegrees"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_node_indegrees">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_node_indegrees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the weighted indegree (total weighted inbound edge weights) for each node.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_preferential_attachment_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_preferential_attachment_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_preferential_attachment_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted preferential attachment from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int,</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int,</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        normalize: bool,</span>
<span class="sd">            Whether to normalize by the square of maximum degree.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the node IDs are higher than the number of nodes in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_preferential_attachment_from_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_preferential_attachment_from_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_preferential_attachment_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">second_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted preferential attachment from the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_node_name: str,</span>
<span class="sd">            Node name of the first node.</span>
<span class="sd">        second_node_name: str,</span>
<span class="sd">            Node name of the second node.</span>
<span class="sd">        normalize: bool,</span>
<span class="sd">            Whether to normalize by the square of maximum degree.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the given node names do not exist in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_resource_allocation_index_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_resource_allocation_index_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_resource_allocation_index_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">destination_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted Resource Allocation Index for the given pair of nodes from the given node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node_id: int,</span>
<span class="sd">            Node ID of the first node.</span>
<span class="sd">        destination_node_id: int,</span>
<span class="sd">            Node ID of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the node IDs are higher than the number of nodes in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_resource_allocation_index_from_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_resource_allocation_index_from_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_resource_allocation_index_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">second_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the weighted Resource Allocation Index for the given pair of nodes from the given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_node_name: str,</span>
<span class="sd">            Node name of the first node.</span>
<span class="sd">        second_node_name: str,</span>
<span class="sd">            Node name of the second node.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If either of the given node names do not exist in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_shortest_path_node_ids_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_shortest_path_node_ids_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_shortest_path_node_ids_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node ids.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_id: int,</span>
<span class="sd">            Source node ID.</span>
<span class="sd">        dst_node_id: int,</span>
<span class="sd">            Destination node ID.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool],</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        maximal_depth: Optional[int],</span>
<span class="sd">            The maximal number of iterations to execute Dijkstra for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node IDs do not exist in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_shortest_path_node_ids_from_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_shortest_path_node_ids_from_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_shortest_path_node_ids_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str,</span>
<span class="sd">            Source node name.</span>
<span class="sd">        dst_node_name: str,</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool],</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        maximal_depth: Optional[int],</span>
<span class="sd">            The maximal number of iterations to execute Dijkstra for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node names do not exist in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_shortest_path_node_names_from_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_shortest_path_node_names_from_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_shortest_path_node_names_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">use_edge_weights_as_probabilities</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">maximal_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns minimum path node names from given node names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_node_name: str,</span>
<span class="sd">            Source node name.</span>
<span class="sd">        dst_node_name: str,</span>
<span class="sd">            Destination node name.</span>
<span class="sd">        use_edge_weights_as_probabilities: Optional[bool],</span>
<span class="sd">            Whether to treat the edge weights as probabilities.</span>
<span class="sd">        maximal_depth: Optional[int],</span>
<span class="sd">            The maximal number of iterations to execute Dijkstra for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node names do not exist in the current graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_singleton_nodes_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_singleton_nodes_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_singleton_nodes_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of weighted singleton nodes, i.e. nodes with weighted node degree equal to zero&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_top_k_central_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_top_k_central_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_top_k_central_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return vector with weighted top k central node Ids.</span>
<span class="sd">        </span>
<span class="sd">        If the k passed is bigger than the number of nodes this method will return</span>
<span class="sd">        all the nodes in the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: int,</span>
<span class="sd">            Number of central nodes to extract.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the current graph instance does not contain edge weights.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given value k is zero.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.get_weighted_triads_number"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.get_weighted_triads_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_weighted_triads_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns total number of triads in the weighted graph&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_constant_edge_weights"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_constant_edge_weights">[docs]</a>    <span class="k">def</span> <span class="nf">has_constant_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph has constant weights.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain edge weights.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_default_graph_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_default_graph_name">[docs]</a>    <span class="k">def</span> <span class="nf">has_default_graph_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return if graph has name that is not the default one.</span>
<span class="sd">        </span>
<span class="sd">        TODO: use a default for the default graph name&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_disconnected_nodes"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_disconnected_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">has_disconnected_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if nodes which are nor singletons nor</span>
<span class="sd">        singletons with selfloops.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_edge_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_edge_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">has_edge_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether edge passing between given node ids exists.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int,</span>
<span class="sd">            Source node id.</span>
<span class="sd">        dst: int,</span>
<span class="sd">            Destination node id.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_edge_from_node_ids_and_edge_type_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_edge_from_node_ids_and_edge_type_id">[docs]</a>    <span class="k">def</span> <span class="nf">has_edge_from_node_ids_and_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether edge with the given type passing between given nodes exists.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: int,</span>
<span class="sd">            The source node of the edge.</span>
<span class="sd">        dst: int,</span>
<span class="sd">            The destination node of the edge.</span>
<span class="sd">        edge_type: Optional[int],</span>
<span class="sd">            The (optional) edge type.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_edge_from_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_edge_from_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">has_edge_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether if edge passing between given nodes exists.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_name: str,</span>
<span class="sd">            The source node name of the edge.</span>
<span class="sd">        dst_name: str,</span>
<span class="sd">            The destination node name of the edge.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_edge_from_node_names_and_edge_type_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_edge_from_node_names_and_edge_type_name">[docs]</a>    <span class="k">def</span> <span class="nf">has_edge_from_node_names_and_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether if edge with type passing between given nodes exists.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_name: str,</span>
<span class="sd">            The source node name of the edge.</span>
<span class="sd">        dst_name: str,</span>
<span class="sd">            The destination node name of the edge.</span>
<span class="sd">        edge_type_name: Optional[str],</span>
<span class="sd">            The (optional) edge type name.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_edge_type_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_edge_type_id">[docs]</a>    <span class="k">def</span> <span class="nf">has_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph has the given edge type id.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: int,</span>
<span class="sd">            id of the edge.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_edge_type_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_edge_type_name">[docs]</a>    <span class="k">def</span> <span class="nf">has_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph has the given edge type name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_name: str,</span>
<span class="sd">            Name of the edge.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">has_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing whether graph has edge types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_edge_types_oddities"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_edge_types_oddities">[docs]</a>    <span class="k">def</span> <span class="nf">has_edge_types_oddities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the graph has any known edge type-related graph oddities.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_edge_weights"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_edge_weights">[docs]</a>    <span class="k">def</span> <span class="nf">has_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing whether graph has weights.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_edge_weights_representing_probabilities"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_edge_weights_representing_probabilities">[docs]</a>    <span class="k">def</span> <span class="nf">has_edge_weights_representing_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether graph has weights that can represent probabilities&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_edges"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_edges">[docs]</a>    <span class="k">def</span> <span class="nf">has_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return if the graph has any edges.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_homogeneous_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_homogeneous_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">has_homogeneous_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the edges have an homogenous edge type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_homogeneous_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_homogeneous_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">has_homogeneous_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the nodes have an homogenous node type.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_known_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_known_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">has_known_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there are known edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_known_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_known_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">has_known_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there are known node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_multilabel_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_multilabel_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">has_multilabel_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if graph has multilabel node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_negative_edge_weights"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_negative_edge_weights">[docs]</a>    <span class="k">def</span> <span class="nf">has_negative_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing whether graph has negative weights.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain weights.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_node_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_node_name">[docs]</a>    <span class="k">def</span> <span class="nf">has_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph has the given node name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str,</span>
<span class="sd">            Name of the node.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_node_name_and_node_type_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_node_name_and_node_type_name">[docs]</a>    <span class="k">def</span> <span class="nf">has_node_name_and_node_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">node_type_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the given node name and node type name exist in current graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str,</span>
<span class="sd">            The node name.</span>
<span class="sd">        node_type_name: Optional[List[str]],</span>
<span class="sd">            The node types name.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_node_oddities"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_node_oddities">[docs]</a>    <span class="k">def</span> <span class="nf">has_node_oddities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the graph has any known node-related graph oddities&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_node_type_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_node_type_id">[docs]</a>    <span class="k">def</span> <span class="nf">has_node_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph has the given node type id.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_id: int,</span>
<span class="sd">            id of the node.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_node_type_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_node_type_name">[docs]</a>    <span class="k">def</span> <span class="nf">has_node_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph has the given node type name.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_name: str,</span>
<span class="sd">            Name of the node.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">has_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if graph has node types&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_node_types_oddities"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_node_types_oddities">[docs]</a>    <span class="k">def</span> <span class="nf">has_node_types_oddities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the graph has any known node type-related graph oddities.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_nodes"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">has_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return if the graph has any nodes.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_nodes_sorted_by_decreasing_outbound_node_degree"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_nodes_sorted_by_decreasing_outbound_node_degree">[docs]</a>    <span class="k">def</span> <span class="nf">has_nodes_sorted_by_decreasing_outbound_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the node IDs are sorted by decreasing outbound node degree.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_nodes_sorted_by_increasing_outbound_node_degree"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_nodes_sorted_by_increasing_outbound_node_degree">[docs]</a>    <span class="k">def</span> <span class="nf">has_nodes_sorted_by_increasing_outbound_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the node IDs are sorted by increasing outbound node degree.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_nodes_sorted_by_lexicographic_order"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_nodes_sorted_by_lexicographic_order">[docs]</a>    <span class="k">def</span> <span class="nf">has_nodes_sorted_by_lexicographic_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the node IDs are sorted by decreasing outbound node degree.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_same_adjacency_matrix"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_same_adjacency_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">has_same_adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if the graphs share the same adjacency matrix.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph,</span>
<span class="sd">            The other graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_selfloop_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_selfloop_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">has_selfloop_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the given node ID has a selfloop.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            Source node id.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_selfloops"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_selfloops">[docs]</a>    <span class="k">def</span> <span class="nf">has_selfloops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if graph has self-loops.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_singleton_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_singleton_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">has_singleton_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there is at least singleton edge type, that is a edge type that only appears once.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_singleton_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_singleton_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">has_singleton_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there is at least singleton node type, that is a node type that only appears once.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_singleton_nodes"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_singleton_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">has_singleton_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if graph has singletons.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_singleton_nodes_with_selfloops"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_singleton_nodes_with_selfloops">[docs]</a>    <span class="k">def</span> <span class="nf">has_singleton_nodes_with_selfloops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if graph has singletons&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_trap_nodes"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_trap_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">has_trap_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the graph has trap nodes.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_unknown_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_unknown_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">has_unknown_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there are unknown edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_unknown_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_unknown_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">has_unknown_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether there are unknown node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.has_weighted_singleton_nodes"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.has_weighted_singleton_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">has_weighted_singleton_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether a graph has one or more weighted singleton nodes.</span>
<span class="sd">        </span>
<span class="sd">        A weighted singleton node is a node whose weighted node degree is 0.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain edge weights.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.is_compatible"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.is_compatible">[docs]</a>    <span class="k">def</span> <span class="nf">is_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if the graphs are compatible.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph,</span>
<span class="sd">            The other graph.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If a graph is directed and the other is undirected.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has edge weights and the other does not.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has node types and the other does not.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has edge types and the other does not.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.is_connected"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.is_connected">[docs]</a>    <span class="k">def</span> <span class="nf">is_connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether the graph is connected.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show the loading bar while computing the connected components, if necessary.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.is_directed"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.is_directed">[docs]</a>    <span class="k">def</span> <span class="nf">is_directed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if graph is directed.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.is_multigraph"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.is_multigraph">[docs]</a>    <span class="k">def</span> <span class="nf">is_multigraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return if there are multiple edges between two node&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.is_singleton_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.is_singleton_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">is_singleton_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            The node to be checked for.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.is_singleton_from_node_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.is_singleton_from_node_name">[docs]</a>    <span class="k">def</span> <span class="nf">is_singleton_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str,</span>
<span class="sd">            The node name to be checked for.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.is_singleton_with_selfloops_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.is_singleton_with_selfloops_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">is_singleton_with_selfloops_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton with self-loops.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            The node to be checked for.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.is_trap_node_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.is_trap_node_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">is_trap_node_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a trap.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            Integer ID of the node, if this is bigger that the number of nodes it will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.is_unchecked_connected_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.is_unchecked_connected_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">is_unchecked_connected_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is not a singleton nor a singleton with selfloop.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            The node to be checked for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exists in the graph this method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.is_unchecked_disconnected_node_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.is_unchecked_disconnected_node_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">is_unchecked_disconnected_node_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton or a singleton with selfloop.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            The node to be checked for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exists in the graph this method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.is_unchecked_singleton_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.is_unchecked_singleton_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">is_unchecked_singleton_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            The node to be checked for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exists in the graph this method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.is_unchecked_singleton_from_node_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.is_unchecked_singleton_from_node_name">[docs]</a>    <span class="k">def</span> <span class="nf">is_unchecked_singleton_from_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton.</span>
<span class="sd">        </span>
<span class="sd">        Nota that this method will raise a panic if caled with unproper</span>
<span class="sd">        parametrization.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name: str,</span>
<span class="sd">            The node name to be checked for.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node name does not exist in the graph this method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.is_unchecked_singleton_with_selfloops_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.is_unchecked_singleton_with_selfloops_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">is_unchecked_singleton_with_selfloops_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a singleton with self-loops.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            The node to be checked for.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.is_unchecked_trap_node_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.is_unchecked_trap_node_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">is_unchecked_trap_node_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns boolean representing if given node is a trap.</span>
<span class="sd">        </span>
<span class="sd">        If the provided node_id is higher than the number of nodes in the graph,</span>
<span class="sd">        the method will panic.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            Integer ID of the node, if this is bigger that the number of nodes it will panic.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        If the given node ID does not exists in the graph this method will panic.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.must_be_connected"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.must_be_connected">[docs]</a>    <span class="k">def</span> <span class="nf">must_be_connected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph is not connected.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is not connected.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.must_be_multigraph"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.must_be_multigraph">[docs]</a>    <span class="k">def</span> <span class="nf">must_be_multigraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph does not have edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is not a multigraph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.must_be_undirected"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.must_be_undirected">[docs]</a>    <span class="k">def</span> <span class="nf">must_be_undirected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph does not have edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is directed.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.must_have_edges"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.must_have_edges">[docs]</a>    <span class="k">def</span> <span class="nf">must_have_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph has a maximal weighted</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edges.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.must_have_nodes"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.must_have_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">must_have_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph does not have any node.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have nodes.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.must_not_be_multigraph"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.must_not_be_multigraph">[docs]</a>    <span class="k">def</span> <span class="nf">must_not_be_multigraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph does not have edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is a multigraph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.must_not_contain_unknown_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.must_not_contain_unknown_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">must_not_contain_unknown_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph contains unknown edge types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains unknown edge types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.must_not_contain_unknown_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.must_not_contain_unknown_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">must_not_contain_unknown_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph contains unknown node types.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not contain node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph contains unknown node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.must_not_contain_weighted_singleton_nodes"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.must_not_contain_weighted_singleton_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">must_not_contain_weighted_singleton_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises an error if the graph contains zero weighted degree.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edges.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.overlap_textual_report"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.overlap_textual_report">[docs]</a>    <span class="k">def</span> <span class="nf">overlap_textual_report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Return rendered textual report about the graph overlaps.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph,</span>
<span class="sd">            graph to create overlap report with.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to shor the loading bars.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.overlaps"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.overlaps">[docs]</a>    <span class="k">def</span> <span class="nf">overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether given graph has any edge overlapping with current graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph,</span>
<span class="sd">            The graph to check against.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If a graph is directed and the other is undirected.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has edge weights and the other does not.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has node types and the other does not.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one of the two graphs has edge types and the other does not.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.random_holdout"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.random_holdout">[docs]</a>    <span class="k">def</span> <span class="nf">random_holdout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">include_all_edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">min_number_overlaps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns random holdout for training ML algorithms on the graph edges.</span>
<span class="sd">        </span>
<span class="sd">        The holdouts returned are a tuple of graphs. In neither holdouts the</span>
<span class="sd">        graph connectivity is necessarily preserved. To maintain that, use</span>
<span class="sd">        the method `connected_holdout`.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_size: float,</span>
<span class="sd">            rate target to reserve for training</span>
<span class="sd">        random_state: Optional[int],</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        include_all_edge_types: Optional[bool],</span>
<span class="sd">            Whether to include all the edges between two nodes.</span>
<span class="sd">        edge_types: Optional[List[Optional[str]]],</span>
<span class="sd">            The edges to include in validation set.</span>
<span class="sd">        min_number_overlaps: Optional[int],</span>
<span class="sd">            The minimum number of overlaps to include the edge into the validation set.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show the loading bar.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the edge types have been specified but the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the minimum number of overlaps have been specified but the graph is not a multigraph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If one or more of the given edge type names is not present in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.random_spanning_arborescence_kruskal"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.random_spanning_arborescence_kruskal">[docs]</a>    <span class="k">def</span> <span class="nf">random_spanning_arborescence_kruskal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">undesired_edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns set of edges composing a spanning tree and connected components.</span>
<span class="sd">        </span>
<span class="sd">        The spanning tree is NOT minimal.</span>
<span class="sd">        The given random_state is NOT the root of the tree.</span>
<span class="sd">        </span>
<span class="sd">        This method, additionally, allows for undesired edge types to be</span>
<span class="sd">        used to build the spanning tree only in extremis when it is utterly</span>
<span class="sd">        necessary in order to complete the spanning arborescence.</span>
<span class="sd">        </span>
<span class="sd">        The quintuple returned contains:</span>
<span class="sd">        - Set of the edges used in order to build the spanning arborescence.</span>
<span class="sd">        - Vector of the connected component of each node.</span>
<span class="sd">        - Number of connected components.</span>
<span class="sd">        - Minimum component size.</span>
<span class="sd">        - Maximum component size.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        random_state: Optional[int],</span>
<span class="sd">            The random_state to use for the holdout,</span>
<span class="sd">        undesired_edge_types: Optional[Set[Optional[int]]],</span>
<span class="sd">            Which edge types id to try to avoid.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show a loading bar or not.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remap_from_graph"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remap_from_graph">[docs]</a>    <span class="k">def</span> <span class="nf">remap_from_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Graph</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return graph remapped towards nodes of the given graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Graph,</span>
<span class="sd">            The graph to remap towards.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remap_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remap_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">remap_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns graph remapped using given node IDs ordering.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_ids: List[int],</span>
<span class="sd">            The node Ids to remap the graph to.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node IDs are not unique.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node IDs are not available for all the values in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remap_from_node_names"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remap_from_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">remap_from_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns graph remapped using given node names ordering.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_names: List[str],</span>
<span class="sd">            The node names to remap the graph to.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node names are not unique.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node names are not available for all the values in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remap_unchecked_from_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remap_unchecked_from_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">remap_unchecked_from_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns graph remapped using given node IDs ordering.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_ids: List[int],</span>
<span class="sd">            The node Ids to remap the graph to.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Safety</span>
<span class="sd">        ------</span>
<span class="sd">        This method will cause a panic if the node IDs are either:</span>
<span class="sd">         * Not unique</span>
<span class="sd">         * Not available for each of the node IDs of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remove_components"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remove_components">[docs]</a>    <span class="k">def</span> <span class="nf">remove_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">node_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">edge_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">minimum_component_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">top_k_components</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;remove all the components that are not connected to interesting</span>
<span class="sd">        nodes and edges.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_names: Optional[List[str]],</span>
<span class="sd">            The name of the nodes of which components to keep.</span>
<span class="sd">        node_types: Optional[List[Optional[str]]],</span>
<span class="sd">            The types of the nodes of which components to keep.</span>
<span class="sd">        edge_types: Optional[List[Optional[str]]],</span>
<span class="sd">            The types of the edges of which components to keep.</span>
<span class="sd">        minimum_component_size: Optional[int],</span>
<span class="sd">            Optional, Minimum size of the components to keep.</span>
<span class="sd">        top_k_components: Optional[int],</span>
<span class="sd">            Optional, number of components to keep sorted by number of nodes.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show the loading bar.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remove_edge_type_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remove_edge_type_id">[docs]</a>    <span class="k">def</span> <span class="nf">remove_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove given edge type ID from all edges.</span>
<span class="sd">        </span>
<span class="sd">        If any given edge remains with no edge type, that edge is labeled</span>
<span class="sd">        with edge type None. Note that the modification DOES NOT happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: int,</span>
<span class="sd">            The edge type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge type ID does not exists in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remove_edge_type_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remove_edge_type_name">[docs]</a>    <span class="k">def</span> <span class="nf">remove_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove given edge type name from all edges.</span>
<span class="sd">        </span>
<span class="sd">        If any given edge remains with no edge type, that edge is labeled</span>
<span class="sd">        with edge type None. Note that the modification DOES NOT happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_name: str,</span>
<span class="sd">            The edge type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge type name does not exists in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remove_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remove_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">remove_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove edge types from the graph.</span>
<span class="sd">        </span>
<span class="sd">        Note that the modification does not happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remove_edge_weights"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remove_edge_weights">[docs]</a>    <span class="k">def</span> <span class="nf">remove_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove edge weights from the graph.</span>
<span class="sd">        </span>
<span class="sd">        Note that the modification does not happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge weights.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remove_inplace_edge_type_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remove_inplace_edge_type_ids">[docs]</a>    <span class="k">def</span> <span class="nf">remove_inplace_edge_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove given edge type ID from all edges.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: int,</span>
<span class="sd">            The edge type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is a multigraph.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge type ID does not exists in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remove_inplace_edge_type_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remove_inplace_edge_type_name">[docs]</a>    <span class="k">def</span> <span class="nf">remove_inplace_edge_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove given edge type name from all edges.</span>
<span class="sd">        </span>
<span class="sd">        If any given edge remains with no edge type, that edge is labeled</span>
<span class="sd">        with edge type None. Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_name: str,</span>
<span class="sd">            The edge type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge type name does not exists in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remove_inplace_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remove_inplace_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">remove_inplace_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove edge types from the graph.</span>
<span class="sd">        </span>
<span class="sd">        Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is a multigraph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remove_inplace_edge_weights"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remove_inplace_edge_weights">[docs]</a>    <span class="k">def</span> <span class="nf">remove_inplace_edge_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove edge weights from the graph.</span>
<span class="sd">        </span>
<span class="sd">        Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge weights.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remove_inplace_node_type_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remove_inplace_node_type_ids">[docs]</a>    <span class="k">def</span> <span class="nf">remove_inplace_node_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove given node type ID from all nodes.</span>
<span class="sd">        </span>
<span class="sd">        If any given node remains with no node type, that node is labeled</span>
<span class="sd">        with node type None. Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_id_to_remove: int,</span>
<span class="sd">            The node type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node type ID does not exists in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remove_inplace_node_type_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remove_inplace_node_type_name">[docs]</a>    <span class="k">def</span> <span class="nf">remove_inplace_node_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove given node type name from all nodes.</span>
<span class="sd">        </span>
<span class="sd">        If any given node remains with no node type, that node is labeled</span>
<span class="sd">        with node type None. Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_name: str,</span>
<span class="sd">            The node type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node type name does not exists in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remove_inplace_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remove_inplace_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">remove_inplace_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove node types from the graph.</span>
<span class="sd">        </span>
<span class="sd">        Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remove_inplace_singleton_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remove_inplace_singleton_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">remove_inplace_singleton_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove singleton edge types from all edges.</span>
<span class="sd">        </span>
<span class="sd">        If any given edge remains with no edge type, that edge is labeled</span>
<span class="sd">        with edge type None. Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remove_inplace_singleton_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remove_inplace_singleton_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">remove_inplace_singleton_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove singleton node types from all nodes.</span>
<span class="sd">        </span>
<span class="sd">        If any given node remains with no node type, that node is labeled</span>
<span class="sd">        with node type None. Note that the modification happens inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remove_node_type_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remove_node_type_id">[docs]</a>    <span class="k">def</span> <span class="nf">remove_node_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove given node type ID from all nodes.</span>
<span class="sd">        </span>
<span class="sd">        If any given node remains with no node type, that node is labeled</span>
<span class="sd">        with node type None. Note that the modification DOES NOT happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_id: int,</span>
<span class="sd">            The node type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node type ID does not exists in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remove_node_type_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remove_node_type_name">[docs]</a>    <span class="k">def</span> <span class="nf">remove_node_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove given node type name from all nodes.</span>
<span class="sd">        </span>
<span class="sd">        If any given node remains with no node type, that node is labeled</span>
<span class="sd">        with node type None. Note that the modification DOES NOT happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_name: str,</span>
<span class="sd">            The node type ID to remove.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node type name does not exists in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remove_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remove_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">remove_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove node types from the graph.</span>
<span class="sd">        </span>
<span class="sd">        Note that the modification does not happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remove_singleton_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remove_singleton_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">remove_singleton_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove singleton edge types from all edges.</span>
<span class="sd">        </span>
<span class="sd">        If any given edge remains with no edge type, that edge is labeled</span>
<span class="sd">        with edge type None. Note that the modification DOES NOT happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edge types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.remove_singleton_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.remove_singleton_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">remove_singleton_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove singleton node types from all nodes.</span>
<span class="sd">        </span>
<span class="sd">        If any given node remains with no node type, that node is labeled</span>
<span class="sd">        with node type None. Note that the modification DOES NOT happen inplace.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have node types.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.replace"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.replace">[docs]</a>    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name_mapping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="n">node_type_name_mapping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="n">edge_type_name_mapping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;Replace given node, node type and edge type names.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_name_mapping: Optional[Dict[str, str]],</span>
<span class="sd">            The node names to replace.</span>
<span class="sd">        node_type_name_mapping: Optional[Dict[str, str]],</span>
<span class="sd">            The node type names to replace.</span>
<span class="sd">        edge_type_name_mapping: Optional[Dict[str, str]],</span>
<span class="sd">            The edge type names to replace.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node names mapping would lead to nodes duplication.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.report"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.report">[docs]</a>    <span class="k">def</span> <span class="nf">report</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns report relative to the graph metrics</span>
<span class="sd">        </span>
<span class="sd">        The report includes the following metrics by default:</span>
<span class="sd">        * Name of the graph</span>
<span class="sd">        * Whether the graph is directed or undirected</span>
<span class="sd">        * Number of singleton nodes</span>
<span class="sd">        * Number of nodes</span>
<span class="sd">        - If the graph has nodes, we also compute:</span>
<span class="sd">        * Minimum unweighted node degree</span>
<span class="sd">        * Maximum unweighted node degree</span>
<span class="sd">        * Unweighted node degree mean</span>
<span class="sd">        * Number of edges</span>
<span class="sd">        * Number of self-loops</span>
<span class="sd">        * Number of singleton with self-loops</span>
<span class="sd">        * Whether the graph is a multigraph</span>
<span class="sd">        * Number of parallel edges</span>
<span class="sd">        * Number of directed edges</span>
<span class="sd">        - If the graph has edges, we also compute:</span>
<span class="sd">        * Rate of self-loops</span>
<span class="sd">        * Whether the graph has weighted edges</span>
<span class="sd">        - If the graph has weights, we also compute:</span>
<span class="sd">        * Minimum weighted node degree</span>
<span class="sd">        * Maximum weighted node degree</span>
<span class="sd">        * Weighted node degree mean</span>
<span class="sd">        * The total edge weights</span>
<span class="sd">        * Whether the graph has node types</span>
<span class="sd">        - If the graph has node types, we also compute:</span>
<span class="sd">        * Whether the graph has singleton node types</span>
<span class="sd">        * The number of node types</span>
<span class="sd">        * The number of nodes with unknown node types</span>
<span class="sd">        * The number of nodes with known node types</span>
<span class="sd">        * Whether the graph has edge types</span>
<span class="sd">        - If the graph has edge types, we also compute:</span>
<span class="sd">        * Whether the graph has singleton edge types</span>
<span class="sd">        * The number of edge types</span>
<span class="sd">        * The number of edges with unknown edge types</span>
<span class="sd">        * The number of edges with known edge types</span>
<span class="sd">        </span>
<span class="sd">        On request, since it takes more time to compute it, the method also provides:&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.sample_negatives"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.sample_negatives">[docs]</a>    <span class="k">def</span> <span class="nf">sample_negatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">negatives_number</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">seed_graph</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Graph</span><span class="p">],</span> <span class="n">only_from_same_component</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns Graph with given amount of negative edges as positive edges.</span>
<span class="sd">        </span>
<span class="sd">        The graph generated may be used as a testing negatives partition to be</span>
<span class="sd">        fed into the argument &quot;graph_to_avoid&quot; of the link_prediction or the</span>
<span class="sd">        skipgrams algorithm</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        negatives_number: int,</span>
<span class="sd">            Number of negatives edges to include.</span>
<span class="sd">        random_state: Optional[int],</span>
<span class="sd">            random_state to use to reproduce negative edge set.</span>
<span class="sd">        seed_graph: Optional[Graph],</span>
<span class="sd">            Optional graph to use to filter the negative edges. The negative edges generated when this variable is provided will always have a node within this graph.</span>
<span class="sd">        only_from_same_component: Optional[bool],</span>
<span class="sd">            Whether to sample negative edges only from nodes that are from the same component.</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show the loading bar.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.set_all_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.set_all_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">set_all_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Replace all edge types (if present) and set all the edge to edge_type.</span>
<span class="sd">        </span>
<span class="sd">        This DOES NOT happen inplace, but created a new instance of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type: str,</span>
<span class="sd">            The edge type to assing to all the edges.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.set_all_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.set_all_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">set_all_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Replace all node types (if present) and set all the node to node_type.</span>
<span class="sd">        </span>
<span class="sd">        This DOES NOT happen inplace, but created a new instance of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type: str,</span>
<span class="sd">            The node type to assing to all the nodes.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.set_inplace_all_edge_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.set_inplace_all_edge_types">[docs]</a>    <span class="k">def</span> <span class="nf">set_inplace_all_edge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Replace all edge types (if present) and set all the edge to edge_type.</span>
<span class="sd">        </span>
<span class="sd">        This happens INPLACE, that is edits the current graph instance.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type: str,</span>
<span class="sd">            The edge type to assing to all the edges.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph does not have edges.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the graph is a multigraph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.set_inplace_all_node_types"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.set_inplace_all_node_types">[docs]</a>    <span class="k">def</span> <span class="nf">set_inplace_all_node_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Replace all node types (if present) and set all the node to node_type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type: str,</span>
<span class="sd">            The node type to assing to all the nodes.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.set_name"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.set_name">[docs]</a>    <span class="k">def</span> <span class="nf">set_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the name of the graph.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name: str,</span>
<span class="sd">            Name of the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.sort_by_bfs_topological_sorting_from_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.sort_by_bfs_topological_sorting_from_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">sort_by_bfs_topological_sorting_from_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with node IDs sorted using a BFS</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        root_node_id: int,</span>
<span class="sd">            Node ID of node to be used as root of BFS</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given root node ID does not exist in the graph&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.sort_by_decreasing_outbound_node_degree"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.sort_by_decreasing_outbound_node_degree">[docs]</a>    <span class="k">def</span> <span class="nf">sort_by_decreasing_outbound_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with node IDs sorted by decreasing outbound node degree&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.sort_by_increasing_outbound_node_degree"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.sort_by_increasing_outbound_node_degree">[docs]</a>    <span class="k">def</span> <span class="nf">sort_by_increasing_outbound_node_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with node IDs sorted by increasing outbound node degree&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.sort_by_node_lexicographic_order"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.sort_by_node_lexicographic_order">[docs]</a>    <span class="k">def</span> <span class="nf">sort_by_node_lexicographic_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns graph with node IDs sorted by lexicographic order&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.spanning_arborescence_kruskal"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.spanning_arborescence_kruskal">[docs]</a>    <span class="k">def</span> <span class="nf">spanning_arborescence_kruskal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Returns consistent spanning arborescence using Kruskal.</span>
<span class="sd">        </span>
<span class="sd">        The spanning tree is NOT minimal.</span>
<span class="sd">        </span>
<span class="sd">        The quintuple returned contains:</span>
<span class="sd">        - Set of the edges used in order to build the spanning arborescence.</span>
<span class="sd">        - Vector of the connected component of each node.</span>
<span class="sd">        - Number of connected components.</span>
<span class="sd">        - Minimum component size.</span>
<span class="sd">        - Maximum component size.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose: Optional[bool],</span>
<span class="sd">            Whether to show a loading bar or not.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.strongly_connected_components"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.strongly_connected_components">[docs]</a>    <span class="k">def</span> <span class="nf">strongly_connected_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns list of nodes of the various strongly connected components.</span>
<span class="sd">        </span>
<span class="sd">        This is an implementation of Tarjan algorithm.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.textual_report"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.textual_report">[docs]</a>    <span class="k">def</span> <span class="nf">textual_report</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return html short textual report of the graph.</span>
<span class="sd">        </span>
<span class="sd">        TODO! Add reports on triangles</span>
<span class="sd">        TODO! Add reports on connected components</span>
<span class="sd">        TODO! Add reports on various node metrics</span>
<span class="sd">        TODO! Add reports on various edge metrics</span>
<span class="sd">        NOTE! Most of the above TODOs will require first to implement the</span>
<span class="sd">        support for the fast computation of the inbound edges in a directed</span>
<span class="sd">        graphs&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.to_anti_diagonal"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.to_anti_diagonal">[docs]</a>    <span class="k">def</span> <span class="nf">to_anti_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the graph from the anti-diagonal adjacency matrix.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.to_arrowhead"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.to_arrowhead">[docs]</a>    <span class="k">def</span> <span class="nf">to_arrowhead</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the graph from the arrowhead adjacency matrix.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.to_bidiagonal"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.to_bidiagonal">[docs]</a>    <span class="k">def</span> <span class="nf">to_bidiagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the graph from the bidiagonal adjacency matrix.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.to_complementary"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.to_complementary">[docs]</a>    <span class="k">def</span> <span class="nf">to_complementary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the complementary graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.to_directed"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.to_directed">[docs]</a>    <span class="k">def</span> <span class="nf">to_directed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new instance of the current graph as directed&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.to_directed_inplace"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.to_directed_inplace">[docs]</a>    <span class="k">def</span> <span class="nf">to_directed_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert inplace the graph to directed.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.to_dot"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.to_dot">[docs]</a>    <span class="k">def</span> <span class="nf">to_dot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print the current graph in a format compatible with Graphviz dot&#39;s format&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.to_lower_triangular"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.to_lower_triangular">[docs]</a>    <span class="k">def</span> <span class="nf">to_lower_triangular</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the directed graph from the lower triangular adjacency matrix.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.to_main_diagonal"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.to_main_diagonal">[docs]</a>    <span class="k">def</span> <span class="nf">to_main_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the graph from the main diagonal adjacency matrix.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.to_transposed"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.to_transposed">[docs]</a>    <span class="k">def</span> <span class="nf">to_transposed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the graph from the transposed adjacency matrix.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.to_upper_triangular"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.to_upper_triangular">[docs]</a>    <span class="k">def</span> <span class="nf">to_upper_triangular</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the directed graph from the upper triangular adjacency matrix.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.validate_edge_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.validate_edge_id">[docs]</a>    <span class="k">def</span> <span class="nf">validate_edge_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Validates provided edge ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_id: int,</span>
<span class="sd">            Edge ID to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge ID does not exists in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.validate_edge_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.validate_edge_ids">[docs]</a>    <span class="k">def</span> <span class="nf">validate_edge_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Validates provided edge IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_ids: List[int],</span>
<span class="sd">            Edge IDs to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given edge ID does not exists in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.validate_edge_type_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.validate_edge_type_id">[docs]</a>    <span class="k">def</span> <span class="nf">validate_edge_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Validates provided edge type ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_id: Optional[int],</span>
<span class="sd">            edge type ID to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given edge type ID does not exists in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.validate_edge_type_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.validate_edge_type_ids">[docs]</a>    <span class="k">def</span> <span class="nf">validate_edge_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_type_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;Validates provided edge type IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_type_ids: List[Optional[int]],</span>
<span class="sd">            Vector of edge type IDs to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no edge types in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.validate_node_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.validate_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">validate_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Validates provided node ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id: int,</span>
<span class="sd">            node ID to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node ID does not exists in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.validate_node_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.validate_node_ids">[docs]</a>    <span class="k">def</span> <span class="nf">validate_node_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Validates all provided node IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_ids: List[int],</span>
<span class="sd">            node IDs to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the given node ID does not exists in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.validate_node_type_id"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.validate_node_type_id">[docs]</a>    <span class="k">def</span> <span class="nf">validate_node_type_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Validates provided node type ID.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_id: Optional[int],</span>
<span class="sd">            Node type ID to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the given node type ID does not exists in the graph.&quot;&quot;&quot;</span></div>
    
    
    
<div class="viewcode-block" id="Graph.validate_node_type_ids"><a class="viewcode-back" href="../../../grape.ensmallen.html#grape.ensmallen.graph.Graph.validate_node_type_ids">[docs]</a>    <span class="k">def</span> <span class="nf">validate_node_type_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;Validates provided node type IDs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_type_ids: List[Optional[int]],</span>
<span class="sd">            Vector of node type IDs to validate.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If there are no node types in the graph.&quot;&quot;&quot;</span></div></div>
    
    
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Cappelleti Luca, Fontana Tommaso.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>